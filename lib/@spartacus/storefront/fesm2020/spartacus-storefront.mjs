import * as i3 from '@angular/common';
import { CommonModule, DOCUMENT, isPlatformServer, isPlatformBrowser } from '@angular/common';
import * as i0 from '@angular/core';
import { Injectable, Directive, Input, HostBinding, HostListener, EventEmitter, Output, NgModule, Inject, isDevMode, Component, ApplicationRef, Injector, PLATFORM_ID, ComponentFactory, TemplateRef, InjectionToken, APP_INITIALIZER, Optional, ComponentFactoryResolver, SecurityContext, ViewChild, ChangeDetectorRef, ChangeDetectionStrategy, Pipe, forwardRef, ContentChild, ViewChildren, APP_BOOTSTRAP_LISTENER, inject } from '@angular/core';
import * as i1 from '@spartacus/core';
import { Config, resolveApplicable, isNotNullable, DeferLoadingStrategy, MODULE_INITIALIZER, provideDefaultConfig, ANONYMOUS_CONSENT_STATUS, I18nModule, FeaturesConfigModule, isNotUndefined, ConfigChunk, DefaultConfigChunk, deepMerge, CxEvent, getLastValueSync, PageType, SMART_EDIT_CONTEXT, SMART_EDIT_DUMMY_COMPONENT_TYPE, GlobalMessageType, RoutingModule as RoutingModule$1, WindowRef, LanguageService, provideConfig, AuthGuard, UrlModule, isObject, LANGUAGE_CONTEXT_ID, CURRENCY_CONTEXT_ID, SiteContextModule, ContextServiceMap, ContainerBackgroundOptions, ConfigModule, FeatureConfigService, THEME_CONTEXT_ID, EMAIL_PATTERN, PASSWORD_PATTERN, UserAddressService, PageMetaModule, ScrollBehavior, OCC_USER_ID_ANONYMOUS, NotificationType, OAuthFlow, UrlMatcherService, DEFAULT_URL_MATCHER, createFrom, BaseCoreModule } from '@spartacus/core';
import { BehaviorSubject, combineLatest, Subscription, of, Observable, ReplaySubject, defer, forkJoin, EMPTY, concat, isObservable, from, Subject, timer, using, asapScheduler, interval, merge } from 'rxjs';
import { filter, tap, map, take, first, mergeMap, distinctUntilChanged, switchMap, shareReplay, mapTo, share, startWith, finalize, skipWhile, endWith, withLatestFrom, scan, delayWhen, catchError, debounceTime, skip, pluck, observeOn, pairwise } from 'rxjs/operators';
import { __decorate, __param } from 'tslib';
import * as i1$1 from '@angular/platform-browser';
import * as i1$2 from '@angular/router';
import { Router, NavigationStart, RouterModule, NavigationEnd, Scroll } from '@angular/router';
import * as i1$3 from '@angular/service-worker';
import { SwRegistrationOptions, ServiceWorkerModule } from '@angular/service-worker';
import * as i3$1 from '@angular/forms';
import { FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR, UntypedFormGroup, UntypedFormControl, Validators, UntypedFormArray } from '@angular/forms';
import * as i2 from '@ng-select/ng-select';
import { NgSelectModule } from '@ng-select/ng-select';
import * as i3$2 from 'ngx-infinite-scroll';
import { InfiniteScrollModule } from 'ngx-infinite-scroll';
import { HttpUrlEncodingCodec } from '@angular/common/http';
import { ofType } from '@ngrx/effects';
import { ROUTER_NAVIGATED } from '@ngrx/router-store';
import * as i1$4 from '@ngrx/store';

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/** The element attribute used to store the focus state */
const FOCUS_ATTR = 'data-cx-focus';
/** The element attribute used to store the focus group state */
const FOCUS_GROUP_ATTR = 'data-cx-focus-group';
var TrapFocus;
(function (TrapFocus) {
    /**
     * Will trap the focus at the start of the focus group.
     */
    TrapFocus["start"] = "start";
    /**
     * Will trap the focus only at the end of the focus group.
     */
    TrapFocus["end"] = "end";
    /**
     * Will not trap the focus in both directions. This is actually not are
     * a great example of focus trap, but it will give the benefit of keyboard
     * tabbing by arrows.
     */
    TrapFocus["both"] = "both";
})(TrapFocus || (TrapFocus = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class BaseFocusService {
}
BaseFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BaseFocusService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
BaseFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BaseFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BaseFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Abstract directive that provides a common interface for all focus directives:
 * - Block Focus
 * - Persist Focus
 * - Escape Focus
 * - Auto Focus
 * - Tab Focus
 * - Trap Focus
 * - Lock Focus
 */
class BaseFocusDirective {
    constructor(elementRef, service) {
        this.elementRef = elementRef;
        this.service = service;
        /**
         * A default config can be provided for each directive if a specific focus directive
         * is used directly. i.e. `<div cxAutoFocus></div>`
         */
        this.defaultConfig = {};
    }
    ngOnInit() {
        this.setDefaultConfiguration();
        this.requiredTabindex = -1;
    }
    // empty, but sub classes might have an implementation
    ngOnChanges(_changes) {
        // Intentional empty method
    }
    /**
     * Override the (input) config if it undefined or an empty string, with the
     * `defaultConfig`. The `defaultConfig` might be specified for each directive
     * differently. If a specific directive is used (i.e. `cxAutoFocus`), the
     * specific (inherited) defaultConfig will be used.
     */
    setDefaultConfiguration() {
        if ((!this.config || this.config === '') && this.defaultConfig) {
            this.config = this.defaultConfig;
        }
    }
    /**
     * Helper method to return the host element for the directive
     * given by the `elementRef`.
     */
    get host() {
        return this.elementRef.nativeElement;
    }
    /**
     * Force a tabindex on the host element if it is _required_ to make the element
     * focusable. If the element is focusable by nature or by a given tabindex, the
     * `tabindex` is not applied.
     *
     * Buttons, active links, etc. do no need an explicit tabindex to receive focus.
     */
    set requiredTabindex(tabindex) {
        if (this.requiresExplicitTabIndex) {
            this.tabindex = tabindex;
        }
    }
    /**
     * Returns true if the host element does not have a tabindex defined
     * and it also doesn't get focus by browsers nature (i.e. button or
     * active link).
     */
    get requiresExplicitTabIndex() {
        return (this.tabindex === undefined &&
            ['button', 'input', 'select', 'textarea'].indexOf(this.host.tagName.toLowerCase()) === -1 &&
            !(this.host.tagName === 'A' &&
                (this.host.hasAttribute('href') ||
                    this.host.hasAttribute('routerlink') ||
                    this.host.getAttribute('ng-reflect-router-link'))));
    }
}
BaseFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BaseFocusDirective, deps: [{ token: i0.ElementRef }, { token: BaseFocusService }], target: i0.ɵɵFactoryTarget.Directive });
BaseFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: BaseFocusDirective, inputs: { tabindex: "tabindex" }, host: { properties: { "attr.tabindex": "this.tabindex" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BaseFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: BaseFocusService }]; }, propDecorators: { tabindex: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.tabindex']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive implementation that adds a CSS class to the host element
 * when the moused is used to focus an element. As soon as the keyboard
 * is used, the class is removed.
 *
 * This feature must be explicitly enabled with the `disableMouseFocus` config.
 *
 * The appearance of the visual focus depends on the CSS implementation to
 * begin with. Spartacus styles add a blue border around each focusable element.
 * This can be considered annoying by keyboard users, as they won't need such a
 * strong indication of the selected element.
 */
class VisibleFocusDirective extends BaseFocusDirective {
    constructor() {
        super(...arguments);
        this.defaultConfig = {
            disableMouseFocus: true,
        };
        /** Controls a css class to hide focus visible CSS rules */
        this.mouseFocus = false;
    }
    handleMousedown() {
        if (this.shouldFocusVisible) {
            this.mouseFocus = true;
        }
    }
    handleKeydown(event) {
        if (this.shouldFocusVisible) {
            this.mouseFocus = !this.isNavigating(event);
        }
    }
    /**
     * Indicates whether the configurations setup to disable visual focus.
     */
    get shouldFocusVisible() {
        return this.config?.disableMouseFocus;
    }
    /**
     * Indicates whether the event is used to navigate the storefront. Some keyboard events
     * are used by mouse users to fill a form or interact with the OS or browser.
     */
    isNavigating(event) {
        // when the cmd or ctrl keys are used, the user doesn't navigate the storefront
        if (event.metaKey) {
            return false;
        }
        // when the tab key is used, users are for navigating away from the current (form) element
        if (event.code === 'Tab') {
            return true;
        }
        // If the user fill in a form, we don't considering it part of storefront navigation.
        if (['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
            return false;
        }
        return true;
    }
}
VisibleFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: VisibleFocusDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
VisibleFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: VisibleFocusDirective, host: { listeners: { "mousedown": "handleMousedown()", "keydown": "handleKeydown($event)" }, properties: { "class.mouse-focus": "this.mouseFocus" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: VisibleFocusDirective, decorators: [{
            type: Directive
        }], propDecorators: { mouseFocus: [{
                type: HostBinding,
                args: ['class.mouse-focus']
            }], handleMousedown: [{
                type: HostListener,
                args: ['mousedown']
            }], handleKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
// { selector: '[cxBlockFocus]' }
class BlockFocusDirective extends VisibleFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = { block: true };
        // @Input('cxBlockFocus')
        this.config = {};
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.config.block) {
            this.tabindex = -1;
        }
    }
}
BlockFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BlockFocusDirective, deps: [{ token: i0.ElementRef }, { token: BaseFocusService }], target: i0.ɵɵFactoryTarget.Directive });
BlockFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: BlockFocusDirective, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BlockFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: BaseFocusService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const GLOBAL_GROUP = '_g_';
/**
 * Shared service to persist the focus for an element or a group
 * of elements. The persisted element focus can be used to persist
 * the focus for a DOM tree, so that the focus remains after a repaint
 * or reoccurs when a DOM tree is "unlocked".
 */
class PersistFocusService extends BaseFocusService {
    constructor() {
        super(...arguments);
        // this is going to fail as we have sub services. They will al have their own map.
        // We must bring this to a singleton map.
        this.focus = new Map();
    }
    get(group) {
        return this.focus.get(group || GLOBAL_GROUP);
    }
    /**
     * Persist the keyboard focus state for the given key. The focus is stored globally
     * or for the given group.
     */
    set(key, group) {
        if (key) {
            this.focus.set(group || GLOBAL_GROUP, key);
        }
    }
    /**
     * Clears the persisted keyboard focus state globally or for the given group.
     */
    clear(group) {
        this.focus.delete(group || GLOBAL_GROUP);
    }
    /**
     * Returns the group for the host element based on the configured group or
     * by the `data-cx-focus-group` attribute stored on the host.
     */
    getPersistenceGroup(host, config) {
        return config?.group ? config.group : host?.getAttribute(FOCUS_GROUP_ATTR);
    }
}
PersistFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PersistFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
PersistFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PersistFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PersistFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive that provides persistence of the focused state. This is useful
 * when a group of focusable elements got refocused or even recreated. That
 * happens often when the DOM is constructed with an `*ngIf` or `*ngFor`.
 *
 * The focus state is based on a configured _key_, which can be passed in the
 * config input, either by using a string primitive or `PersistFocusConfig.key`:
 *
 * ```html
 * <button cxPersistFocus="myKey"></button>
 * <button cxFocus="myKey"></button>
 * <button [cxFocus]="{{key:'myKey'}"></button>
 * ```
 *
 * The focus state can be part of a focus _group_, so that the state is shared
 * and remember for the given group. In order to detect the persistence for a
 * given element, we store the persistence key as a data attribute (`data-cx-focus`):
 *
 * ```html
 * <button data-cx-focus="myKey"></button>
 * ```
 *
 * Other keyboard focus directives can read the key to understand whether the element
 * should retrieve focus.
 *
 */
class PersistFocusDirective extends BlockFocusDirective {
    handleFocus(event) {
        this.service.set(this.key, this.group);
        event?.preventDefault();
        event?.stopPropagation();
    }
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = {};
        /**
         * The persistence key can be passed directly or through the `FocusConfig.key`.
         * While this could be considered a global key, the likeliness of conflicts
         * is very small since the key is cleared when the focus is changed.
         */
        // @Input('cxPersistFocus')
        this.config = {};
    }
    ngOnInit() {
        super.ngOnInit();
        this.attr = this.key ? this.key : undefined;
    }
    setDefaultConfiguration() {
        if (typeof this.config === 'string' && this.config !== '') {
            this.config = { key: this.config };
        }
        super.setDefaultConfiguration();
    }
    /**
     * Focus the element explicitly if it was focused before.
     */
    ngAfterViewInit() {
        if (this.isPersisted) {
            this.host.focus({ preventScroll: true });
        }
    }
    get isPersisted() {
        return !!this.key && this.service.get(this.group) === this.key;
    }
    /**
     * Returns the key for the host element, which is used to persist the
     * focus state. This is useful in cases where the DOM is rebuild.
     */
    get key() {
        return this.config?.key;
    }
    /**
     * returns the persistence group (if any) for the focusable elements.
     */
    get group() {
        return this.service.getPersistenceGroup(this.host, this.config);
    }
}
PersistFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PersistFocusDirective, deps: [{ token: i0.ElementRef }, { token: PersistFocusService }], target: i0.ɵɵFactoryTarget.Directive });
PersistFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: PersistFocusDirective, host: { listeners: { "focus": "handleFocus($event)" }, properties: { "attr.data-cx-focus": "this.attr" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PersistFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: PersistFocusService }]; }, propDecorators: { attr: [{
                type: HostBinding,
                args: [`attr.${FOCUS_ATTR}`]
            }], handleFocus: [{
                type: HostListener,
                args: ['focus', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SelectFocusUtility {
    constructor() {
        /**
         * Query selectors used to query focusable child elements of the host element.
         * The selectors are supplemented with `:not([disabled])` and `:not([hidden])`.
         */
        this.focusableSelectors = [
            'a[href]',
            'button',
            '[tabindex]',
            'input',
            'select',
            'textarea',
        ];
        // like to leave out the following as we don't use it, and make this list exensible.
        //   `[contentEditable=true]`, // very unlikely to suport as we're not a business tool
        //   `iframe`, // we really don't like iframes...
        //   `area[href]`, // very debatable!
        this.focusableSelectorSuffix = ':not([disabled]):not([hidden]):not([aria-hidden])';
    }
    query(host, selector) {
        if (!selector || selector === '') {
            return [];
        }
        return Array.from(host?.querySelectorAll(selector));
    }
    findFirstFocusable(host, config = { autofocus: true }) {
        const selector = typeof config?.autofocus === 'string' ? config.autofocus : '[autofocus]';
        // fallback to first focusable
        return (this.query(host, selector).find((el) => !this.isHidden(el)) ||
            this.findFocusable(host).find((el) => Boolean(el)));
    }
    /**
     * returns all focusable child elements of the host element. The element selectors
     * are build from the `focusableSelectors`.
     *
     * @param host the `HTMLElement` used to query focusable elements
     * @param locked indicates whether inactive (`tabindex="-1"`) focusable elements should be returned
     * @param invisible indicates whether hidden focusable elements should be returned
     */
    findFocusable(host, locked = false, invisible = false) {
        let suffix = this.focusableSelectorSuffix;
        if (!locked) {
            suffix += `:not([tabindex='-1'])`;
        }
        const selector = this.focusableSelectors
            .map((s) => (s += suffix))
            .join(',');
        return this.query(host, selector).filter((el) => !invisible ? !this.isHidden(el) : Boolean(el));
    }
    /**
     * Indicates whether the element is hidden by CSS. There are various CSS rules and
     * HTML structures which can lead to an hidden or invisible element. An `offsetParent`
     * of null indicates that the element or any of it's decendants is hidden (`display:none`).
     *
     * Oother techniques use the visibility (`visibility: hidden`), opacity (`opacity`) or
     * phyisical location on the element itself or any of it's anchestor elements. Those
     * technique require to work with the _computed styles_, which will cause a performance
     * downgrade. We don't do this in the standard implementaton.
     */
    isHidden(el) {
        return el.offsetParent === null;
    }
}
SelectFocusUtility.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SelectFocusUtility, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SelectFocusUtility.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SelectFocusUtility, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SelectFocusUtility, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class EscapeFocusService extends PersistFocusService {
    constructor(selectFocusUtil) {
        super();
        this.selectFocusUtil = selectFocusUtil;
    }
    shouldFocus(config) {
        return !!config?.focusOnEscape;
    }
    handleEscape(host, config, event) {
        if (this.shouldFocus(config)) {
            if (host !== event.target) {
                host.focus({ preventScroll: true });
                event.preventDefault();
                event.stopPropagation();
            }
            else {
                if (config?.focusOnDoubleEscape) {
                    this.selectFocusUtil
                        .findFirstFocusable(host, { autofocus: true })
                        ?.focus();
                }
            }
        }
    }
}
EscapeFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: EscapeFocusService, deps: [{ token: SelectFocusUtility }], target: i0.ɵɵFactoryTarget.Injectable });
EscapeFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: EscapeFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: EscapeFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: SelectFocusUtility }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive to focus the host element whenever the `escape` key is captured.
 * UiEvents bubble up by nature, which is why the `cxEscGroup` can be used
 * on a tree of elements. Each time the escape key is used, the focus will
 * move up in the DOM tree.
 *
 */
class EscapeFocusDirective extends PersistFocusDirective {
    /**
     * Handles the escape key event.
     * @param event the native keyboard event which contains the escape keydown event
     */
    handleEscape(event) {
        if (this.service.shouldFocus(this.config)) {
            this.service.handleEscape(this.host, this.config, event);
        }
        this.esc.emit(this.service.shouldFocus(this.config));
    }
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = { focusOnEscape: true };
        this.esc = new EventEmitter();
    }
    ngOnInit() {
        if (this.service.shouldFocus(this.config)) {
            this.requiredTabindex = -1;
        }
        super.ngOnInit();
    }
}
EscapeFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: EscapeFocusDirective, deps: [{ token: i0.ElementRef }, { token: EscapeFocusService }], target: i0.ɵɵFactoryTarget.Directive });
EscapeFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: EscapeFocusDirective, outputs: { esc: "esc" }, host: { listeners: { "keydown.escape": "handleEscape($event)" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: EscapeFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: EscapeFocusService }]; }, propDecorators: { esc: [{
                type: Output
            }], handleEscape: [{
                type: HostListener,
                args: ['keydown.escape', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AutoFocusService extends EscapeFocusService {
    /**
     * Returns the first focusable child element of the host element.
     */
    findFirstFocusable(host, config = { autofocus: true }) {
        if (config?.autofocus === ':host') {
            return host;
        }
        else if (this.hasPersistedFocus(host, config)) {
            return this.getPersisted(host, this.getPersistenceGroup(host, config));
        }
        else {
            return this.selectFocusUtil.findFirstFocusable(host, config) || host;
        }
    }
    /**
     * Indicates whether any of the focusable child elements is focused.
     */
    hasPersistedFocus(host, config) {
        return !!this.getPersisted(host, this.getPersistenceGroup(host, config));
    }
    /**
     * Returns the element that has a persisted focus state.
     *
     * @param host the `HTMLElement` used to query for focusable children
     * @param group the optional group for the persistent state, to separate different focus
     *   groups and remain the persistence
     */
    getPersisted(host, group) {
        if (!this.get(group)) {
            return;
        }
        const focussed = Array.from(host?.querySelectorAll(`[${FOCUS_ATTR}='${this.get(group)}']`));
        return focussed.length > 0 ? focussed[0] : undefined;
    }
}
AutoFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AutoFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
AutoFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AutoFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AutoFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive that focus the first nested _focusable_ element based on state and configuration:
 *
 * 1. focusable element that was left in a focused state (aka _persisted_ focus)
 * 2. focusable element selected by configured CSS selector (i.e. 'button[type=submit]')
 * 3. focusable element marked with the native HTML5 `autofocus` attribute
 * 4. first focusable element
 * 5. the host element, in case the configured CSS selector is `:host`.
 *
 * Example configurations:
 *
 * `<div cxAutoFocus>[...]</div>`
 *
 * `<div [cxAutoFocus]="{autofocus: false}">[...]</div>`
 *
 * `<div [cxAutoFocus]="{autofocus: 'button.active'}">[...]</div>`
 *
 * `<div [cxAutoFocus]="{autofocus: ':host'}">[...]</div>`
 *
 * When your element is added dynamically (ie. by using an *ngIf or after a DOM change), the
 * focus can be refreshed by using the refreshFocus configuration.
 */
class AutoFocusDirective extends EscapeFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        /** The AutoFocusDirective will be using autofocus by default  */
        this.defaultConfig = { autofocus: true };
    }
    /**
     * Focus the element explicitly if it was focussed before.
     */
    ngAfterViewInit() {
        if (this.shouldAutofocus) {
            this.handleFocus();
        }
        if (!this.shouldAutofocus || this.hasPersistedFocus) {
            super.ngAfterViewInit();
        }
    }
    ngOnChanges(changes) {
        // responsible for refresh focus based on the configured refresh property name
        if (!!changes.config?.currentValue?.refreshFocus) {
            // ensure the autofocus when it's to provided initially
            if (!this.config.autofocus) {
                this.config.autofocus = true;
            }
            this.handleFocus();
        }
        super.ngOnChanges(changes);
    }
    /**
     * Mimic the focus without setting the actual focus on the host. The first
     * focusable child element will be focussed.
     */
    handleFocus(event) {
        if (this.shouldAutofocus) {
            if (!event?.target || event.target === this.host) {
                this.firstFocusable?.focus();
            }
            else {
                event.target.focus();
            }
        }
        super.handleFocus(event);
    }
    /**
     * Helper function to get the first focusable child element
     */
    get hasPersistedFocus() {
        return this.service.hasPersistedFocus(this.host, this.config);
    }
    /**
     * Helper function to indicate whether we should use autofocus for the
     * child elements.
     */
    get shouldAutofocus() {
        return !!this.config?.autofocus;
    }
    /**
     * Helper function to get the first focusable child element.
     *
     * We keep this private to not pollute the API.
     */
    get firstFocusable() {
        return this.service.findFirstFocusable(this.host, this.config);
    }
}
AutoFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AutoFocusDirective, deps: [{ token: i0.ElementRef }, { token: AutoFocusService }], target: i0.ɵɵFactoryTarget.Directive });
AutoFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: AutoFocusDirective, usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AutoFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: AutoFocusService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TabFocusService extends AutoFocusService {
    /**
     * Moves to the next (or previous) tab.
     */
    moveTab(host, config, increment, event) {
        if (config?.tab) {
            const next = config.tab === 'scroll'
                ? this.findNextScrollable(host, config, increment)
                : this.findNext(host, config, increment);
            next?.focus();
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * builds out virtual slides out of the full scrollable area, to allow
     * for maximum flexibility for the underlying layout without using hardcoded
     * slide sizes.
     */
    findNextScrollable(host, config, increment) {
        const active = this.getActiveChild(host, config);
        if (!active) {
            return;
        }
        // slide count
        const virtualSlideCount = Math.round(host.scrollWidth / host.clientWidth);
        // find current virtual slide
        const currentVirtualSlide = Math.round(active.offsetLeft / (host.scrollWidth / virtualSlideCount));
        let nextVirtualSlide = currentVirtualSlide + increment;
        if (increment === 1 /* MOVE_FOCUS.NEXT */ &&
            nextVirtualSlide >= virtualSlideCount) {
            nextVirtualSlide = 0;
        }
        if (increment === -1 /* MOVE_FOCUS.PREV */ && nextVirtualSlide < 0) {
            nextVirtualSlide = virtualSlideCount - 1;
        }
        const firstItemOnNextSlide = this.getChildren(host, config)?.find((tab) => tab.offsetLeft >=
            (host.scrollWidth / virtualSlideCount) * nextVirtualSlide);
        return firstItemOnNextSlide;
    }
    findNext(host, config, increment) {
        const childs = this.getChildren(host, config);
        let activeIndex = childs?.findIndex((c) => c === this.getActiveChild(host, config));
        if (!activeIndex || activeIndex === -1) {
            activeIndex = 0;
        }
        activeIndex += increment;
        if (increment === 1 /* MOVE_FOCUS.NEXT */ && activeIndex >= childs?.length) {
            activeIndex = childs.length - 1;
        }
        if (increment === -1 /* MOVE_FOCUS.PREV */ && activeIndex < 0) {
            activeIndex = 0;
        }
        return childs ? childs[activeIndex] : undefined;
    }
    /**
     * Returns the active focusable child element. If there's no active
     * focusable child element, the first focusable child is returned.
     */
    getActiveChild(host, config) {
        const persisted = this.getPersisted(host, config?.group);
        if (persisted) {
            return persisted;
        }
        const children = this.getChildren(host, config);
        let index = children.findIndex((tab) => this.isActive(tab));
        if (!index || index === -1) {
            index = 0;
        }
        return children[index];
    }
    getChildren(host, config) {
        if (typeof config.tab === 'string' && config.tab !== 'scroll') {
            return this.selectFocusUtil.query(host, config.tab);
        }
        else {
            return this.findFocusable(host, true);
        }
    }
    /**
     * Returns all focusable child elements of the host element.
     *
     * @param host The host element is used to query child focusable elements.
     * @param locked Indicates if locked elements (tabindex=-1) should be returned, defaults to false.
     * @param invisible Indicates if invisible child elements should be returned, defaults to false.
     */
    findFocusable(host, locked = false, invisible = false) {
        return this.selectFocusUtil.findFocusable(host, locked, invisible);
    }
    isActive(el) {
        const child = document.activeElement;
        const selector = child?.tagName;
        return (el === child ||
            (!!selector &&
                !!Array.from(el.querySelectorAll(selector)).find((e) => e === child)));
    }
}
TabFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
TabFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive to move the focus of ("locked") child elements. This is useful
 * for a nested list of tabs, carousel slides or any group of elements that
 * requires horizontal navigation.
 */
class TabFocusDirective extends AutoFocusDirective {
    handleNextTab(event) {
        if (this.config?.tab) {
            this.service.moveTab(this.host, this.config, 1 /* MOVE_FOCUS.NEXT */, event);
        }
    }
    handlePreviousTab(event) {
        if (this.config?.tab) {
            this.service.moveTab(this.host, this.config, -1 /* MOVE_FOCUS.PREV */, event);
        }
    }
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        /** `tab` defaults to true if the directive `cxTabFocus` is used. */
        this.defaultConfig = { tab: true };
        // @Input('cxTabFocus')
        this.config = {};
    }
}
TabFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabFocusDirective, deps: [{ token: i0.ElementRef }, { token: TabFocusService }], target: i0.ɵɵFactoryTarget.Directive });
TabFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: TabFocusDirective, host: { listeners: { "keydown.arrowRight": "handleNextTab($event)", "keydown.arrowLeft": "handlePreviousTab($event)" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: TabFocusService }]; }, propDecorators: { handleNextTab: [{
                type: HostListener,
                args: ['keydown.arrowRight', ['$event']]
            }], handlePreviousTab: [{
                type: HostListener,
                args: ['keydown.arrowLeft', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TrapFocusService extends TabFocusService {
    /**
     * Indicates whether any of the child elements of the host are focusable.
     *
     * @param host `HTMLElement` that is used to query the focusable elements.
     */
    hasFocusableChildren(host) {
        return this.findFocusable(host).length > 0;
    }
    /**
     * Focus the next or previous element of all available focusable elements.
     * The focus is _trapped_ in case there's no next or previous available element.
     * The focus will automatically move the start or end of the list.
     */
    moveFocus(host, config, increment, event) {
        const focusable = this.findFocusable(host);
        let index = focusable.findIndex((v) => v === event.target) + increment;
        const shouldMoveFocus = (index >= 0 && index < focusable.length) ||
            (index < 0 && this.getTrapStart(config.trap)) ||
            (index >= focusable.length && this.getTrapEnd(config.trap));
        if (shouldMoveFocus) {
            if (index >= focusable.length) {
                index = 0;
            }
            if (index < 0) {
                index = focusable.length - 1;
            }
            event.preventDefault();
            event.stopPropagation();
            const el = focusable[index];
            el.focus();
        }
    }
    getTrapStart(trap) {
        return trap === true || trap === TrapFocus.start;
    }
    getTrapEnd(trap) {
        return trap === true || trap === TrapFocus.end;
    }
}
TrapFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TrapFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
TrapFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TrapFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TrapFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive that keeps the focus inside the focusable child elements,
 * also known as a _focus trap_.
 */
class TrapFocusDirective extends TabFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = { trap: true };
        // @Input('cxTrapFocus')
        this.config = {};
        this.handleTrapDown = (event) => {
            if (!!this.config.trap) {
                this.moveFocus(event, 1 /* MOVE_FOCUS.NEXT */);
            }
        };
        this.handleTrapUp = (event) => {
            if (!!this.config.trap) {
                this.moveFocus(event, -1 /* MOVE_FOCUS.PREV */);
            }
        };
    }
    /**
     * Moves the focus of the element reference up or down, depending on the increment.
     * The focus of the element is trapped to avoid it from going out of the group.
     *
     * @param event UIEvent that is used to get the target element. The event is blocked
     *   from standard execution and further bubbling.
     * @param increment indicates whether the next or previous is focussed.
     */
    moveFocus(event, increment) {
        if (this.service.hasFocusableChildren(this.host)) {
            this.service.moveFocus(this.host, this.config, increment, event);
        }
    }
}
TrapFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TrapFocusDirective, deps: [{ token: i0.ElementRef }, { token: TrapFocusService }], target: i0.ɵɵFactoryTarget.Directive });
TrapFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: TrapFocusDirective, host: { listeners: { "keydown.arrowdown": "handleTrapDown($event)", "keydown.tab": "handleTrapDown($event)", "keydown.arrowup": "handleTrapUp($event)", "keydown.shift.tab": "handleTrapUp($event)" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TrapFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: TrapFocusService }]; }, propDecorators: { handleTrapDown: [{
                type: HostListener,
                args: ['keydown.arrowdown', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.tab', ['$event']]
            }], handleTrapUp: [{
                type: HostListener,
                args: ['keydown.arrowup', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.shift.tab', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class LockFocusService extends TrapFocusService {
}
LockFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LockFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
LockFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LockFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LockFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Focusable elements exclude hidden elements by default, but this contradicts with
 * unlocking (hidden) elements.
 */
const UNLOCK_HIDDEN_ELEMENTS = true;
/**
 * Directive that adds persistence for focussed element in case
 * the elements are being rebuild. This happens often when change
 * detection kicks in because of new data set from the backend.
 */
class LockFocusDirective extends TrapFocusDirective {
    /**
     * When the user selects enter or space, the focusable childs are
     * unlocked, which means that the tabindex is set to 0.
     */
    handleEnter(event) {
        if (this.shouldLock && this.host === event.target) {
            this.unlockFocus(event);
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * In case any of the children elements is touched by the mouse,
     * we unlock the group to not break the mouse-experience.
     */
    handleClick(event) {
        if (this.shouldLock && this.isLocked) {
            this.unlockFocus(event);
            event.stopPropagation();
        }
    }
    constructor(elementRef, service, renderer) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.renderer = renderer;
        this.defaultConfig = { lock: true };
        // @Input('cxLockFocus')
        this.config = {};
        /**
         * Emits an event when the host is unlocked.
         */
        this.unlock = new EventEmitter();
    }
    lockFocus() {
        this.addTabindexToChildren(-1);
    }
    unlockFocus(event) {
        this.unlock.emit(true);
        this.addTabindexToChildren(0);
        // we focus the host if the event was triggered from a child
        if (event?.target === this.host) {
            // we wait a few milliseconds, mainly because firefox will otherwise apply
            // the mouse event on the new focused child element
            setTimeout(() => {
                super.handleFocus(event);
            }, 100);
        }
    }
    ngOnInit() {
        super.ngOnInit();
        this.shouldLock = this.config?.lock;
        if (this.shouldLock) {
            this.tabindex = 0;
            // Locked elements will be set to `autofocus` by default if it's not
            // been configured. This will ensure that autofocus kicks in upon unlock.
            if (!this.config.hasOwnProperty('autofocus')) {
                this.config.autofocus = true;
            }
            // Locked elements will be set to `focusOnEscape` by default if it's not
            // been configured. This will ensure that  the host gets locked again when
            // `escape` is pressed.
            if (!this.config.hasOwnProperty('focusOnEscape')) {
                this.config.focusOnEscape = !(this.config?.focusOnEscape === false);
            }
        }
    }
    ngAfterViewInit() {
        if (this.shouldLock) {
            /**
             * If the component hosts a group of focusable children elements,
             * we persist the group key to the children, so that they can taken this
             * into account when they persist their focus state.
             */
            if (!!this.group) {
                const group = this.group;
                this.service.findFocusable(this.host).forEach((el) => 
                // we must do this in after view init as
                this.renderer.setAttribute(el, FOCUS_GROUP_ATTR, group));
            }
            if (this.shouldAutofocus) {
                this.handleFocus();
            }
        }
        super.ngAfterViewInit();
    }
    handleFocus(event) {
        if (this.shouldLock) {
            if (this.shouldUnlockAfterAutofocus(event)) {
                // Delay unlocking in case the host is using `ChangeDetectionStrategy.Default`
                setTimeout(() => this.unlockFocus(event));
            }
            else {
                setTimeout(() => this.lockFocus());
                event?.stopPropagation();
                return;
            }
        }
        super.handleFocus(event);
    }
    handleEscape(event) {
        if (this.shouldLock) {
            this.service.clear(this.config.group);
        }
        super.handleEscape(event);
    }
    /**
     * When the handleFocus is called without an actual event, it's coming from Autofocus.
     * In this case we unlock the focusable children in case there's a focusable child that
     * was unlocked before.
     *
     * We keep this private to not polute the API.
     */
    shouldUnlockAfterAutofocus(event) {
        return !event && this.service.hasPersistedFocus(this.host, this.config);
    }
    /**
     * Add the tabindex attribute to the focusable children elements
     */
    addTabindexToChildren(i = 0) {
        if (this.shouldLock) {
            this.isLocked = i === -1;
            if (!(this.hasFocusableChildren && i === 0) || i === 0) {
                this.focusable.forEach((el) => this.renderer.setAttribute(el, 'tabindex', i.toString()));
            }
        }
    }
    /**
     * Utility method, returns all focusable children for the host element.
     *
     * We keep this private to not polute the API.
     */
    get hasFocusableChildren() {
        return this.service.hasFocusableChildren(this.host);
    }
    /**
     * Returns the focusable children of the host element. If the host element
     * is configured to be locked, the query is restricted to child elements
     * with a tabindex !== `-1`.
     *
     * We keep this private to not polute the API.
     */
    get focusable() {
        return this.service.findFocusable(this.host, this.shouldLock, UNLOCK_HIDDEN_ELEMENTS);
    }
}
LockFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LockFocusDirective, deps: [{ token: i0.ElementRef }, { token: LockFocusService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
LockFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: LockFocusDirective, outputs: { unlock: "unlock" }, host: { listeners: { "keydown.enter": "handleEnter($event)", "keydown.space": "handleEnter($event)", "click": "handleClick($event)" }, properties: { "class.focus-lock": "this.shouldLock", "class.is-locked": "this.isLocked" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LockFocusDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: LockFocusService }, { type: i0.Renderer2 }]; }, propDecorators: { shouldLock: [{
                type: HostBinding,
                args: ['class.focus-lock']
            }], isLocked: [{
                type: HostBinding,
                args: ['class.is-locked']
            }], unlock: [{
                type: Output
            }], handleEnter: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }], handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class KeyboardFocusService extends LockFocusService {
}
KeyboardFocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
KeyboardFocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FocusDirective extends LockFocusDirective {
    constructor(elementRef, service, renderer) {
        super(elementRef, service, renderer);
        this.elementRef = elementRef;
        this.service = service;
        this.renderer = renderer;
        this.defaultConfig = {};
        this.config = {};
    }
}
FocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FocusDirective, deps: [{ token: i0.ElementRef }, { token: KeyboardFocusService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
FocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: FocusDirective, selector: "[cxFocus]", inputs: { config: ["cxFocus", "config"] }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FocusDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxFocus]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: KeyboardFocusService }, { type: i0.Renderer2 }]; }, propDecorators: { config: [{
                type: Input,
                args: ['cxFocus']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const directives = [
    // PersistFocusDirective,
    // VisibleFocusDirective,
    // BlockFocusDirective,
    // AutoFocusDirective,
    // EscapeFocusDirective,
    // LockFocusDirective,
    // TrapFocusDirective,
    // TabFocusDirective,
    FocusDirective,
];
class KeyboardFocusModule {
}
KeyboardFocusModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
KeyboardFocusModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusModule, declarations: [
        // PersistFocusDirective,
        // VisibleFocusDirective,
        // BlockFocusDirective,
        // AutoFocusDirective,
        // EscapeFocusDirective,
        // LockFocusDirective,
        // TrapFocusDirective,
        // TabFocusDirective,
        FocusDirective], imports: [CommonModule], exports: [
        // PersistFocusDirective,
        // VisibleFocusDirective,
        // BlockFocusDirective,
        // AutoFocusDirective,
        // EscapeFocusDirective,
        // LockFocusDirective,
        // TrapFocusDirective,
        // TabFocusDirective,
        FocusDirective] });
KeyboardFocusModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [...directives],
                    exports: [...directives],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MockKeyboardFocusDirective {
    constructor() {
        this.config = {};
    }
}
MockKeyboardFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MockKeyboardFocusDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
MockKeyboardFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: MockKeyboardFocusDirective, selector: "[cxFocus]", inputs: { config: ["cxFocus", "config"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MockKeyboardFocusDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxFocus]',
                }]
        }], propDecorators: { config: [{
                type: Input,
                args: ['cxFocus']
            }] } });
class KeyboardFocusTestingModule {
}
KeyboardFocusTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
KeyboardFocusTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusTestingModule, declarations: [MockKeyboardFocusDirective], exports: [MockKeyboardFocusDirective] });
KeyboardFocusTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusTestingModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: KeyboardFocusTestingModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MockKeyboardFocusDirective],
                    exports: [MockKeyboardFocusDirective],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
// export * from './autofocus/index';
// export * from './base/index';
// export * from './block/index';
// export * from './escape/index';
// export * from './lock/index';
// export * from './on-navigate/index';
// export * from './persist/index';
// export * from './tab/index';
// export * from './trap/index';
// export * from './visible/index';
// export * from './keyboard-focus.model';

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Types of dialog openings supported
 */
var DIALOG_TYPE;
(function (DIALOG_TYPE) {
    DIALOG_TYPE["POPOVER"] = "POPOVER";
    DIALOG_TYPE["POPOVER_CENTER"] = "POPOVER_CENTER";
    DIALOG_TYPE["POPOVER_CENTER_BACKDROP"] = "POPOVER_CENTER_BACKDROP";
    DIALOG_TYPE["DIALOG"] = "DIALOG";
    DIALOG_TYPE["SIDEBAR_START"] = "SIDEBAR_START";
    DIALOG_TYPE["SIDEBAR_END"] = "SIDEBAR_END";
})(DIALOG_TYPE || (DIALOG_TYPE = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
let LaunchRenderStrategy = class LaunchRenderStrategy {
    constructor(document, rendererFactory) {
        this.document = document;
        this.rendererFactory = rendererFactory;
        // List of called references; only used for rendered elements
        this.renderedCallers = [];
        /**
         * Classes to apply to the component when the dialog is a DIALOG
         */
        this.dialogClasses = ['d-block', 'fade', 'modal', 'show'];
        /**
         * Classes to apply to the component when the dialog is a POPOVER
         */
        this.popoverClasses = ['cx-dialog-popover'];
        /**
         * Classes to apply to the component when the dialog is a POPOVER_CENTER
         */
        this.popoverCenterClasses = ['cx-dialog-popover-center'];
        /**
         * Classes to apply to the component when the dialog is a POPOVER_CENTER with a backdrop
         */
        this.popoverCenterBackdropClasses = [
            'cx-dialog-popover-center-backdrop',
        ];
        /**
         * Classes to apply to the component when the dialog is a SIDEBAR_END
         */
        this.sidebarEndClasses = ['cx-sidebar-end'];
        /**
         * Classes to apply to the component when the dialog is a SIDEBAR_START
         */
        this.sidebarStartClasses = ['cx-sidebar-start'];
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    /**
     * Determines if element should render
     *
     * @param caller
     * @param config
     */
    shouldRender(caller, config) {
        return (Boolean(config.component) &&
            (this.renderedCallers.some((el) => el.caller === caller)
                ? !!config.multi
                : true));
    }
    applyClasses(component, dialogType) {
        let classes = [];
        // TODO: make classes configurable
        switch (dialogType) {
            case DIALOG_TYPE.DIALOG:
                classes = this.dialogClasses;
                this.renderer.addClass(this.document.body, 'modal-open');
                break;
            case DIALOG_TYPE.POPOVER:
                classes = this.popoverClasses;
                break;
            case DIALOG_TYPE.POPOVER_CENTER:
                classes = this.popoverCenterClasses;
                break;
            case DIALOG_TYPE.POPOVER_CENTER_BACKDROP:
                classes = this.popoverCenterBackdropClasses;
                break;
            case DIALOG_TYPE.SIDEBAR_END:
                classes = this.sidebarEndClasses;
                break;
            case DIALOG_TYPE.SIDEBAR_START:
                classes = this.sidebarStartClasses;
                break;
        }
        for (const newClass of classes) {
            this.renderer.addClass(component.location.nativeElement, newClass);
        }
    }
    /**
     * Method to call when rendered element is destroyed
     * The element will be removed from the list of rendered elements
     *
     * @param caller
     * @param _config optional parameters used in children strategies
     */
    remove(caller, config) {
        this.renderedCallers = this.renderedCallers.filter((el) => el.caller !== caller);
        if (config?.dialogType === DIALOG_TYPE.DIALOG) {
            this.renderer.removeClass(this.document.body, 'modal-open');
        }
    }
    getPriority() {
        return -10 /* Priority.LOW */; // low, as it's a default matcher
    }
};
LaunchRenderStrategy = __decorate([
    __param(0, Inject(DOCUMENT))
], LaunchRenderStrategy);

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The `BREAKPOINT` typing defaults to five default screen names:
 * xs, sm, md, lg, xl.
 *
 * The type can be extended to allow for custom screens, such as XLL or `tablet`.
 *
 * While the screen names are fully configurable, other features might have
 * pre-configured layout settings per screen. Page layouts or table configurations,
 * for example, are driven by screen size. In case you change the screen size or
 * introduce new screen names, you might loose out on these configurations.
 */
var BREAKPOINT;
(function (BREAKPOINT) {
    BREAKPOINT["xs"] = "xs";
    BREAKPOINT["sm"] = "sm";
    BREAKPOINT["md"] = "md";
    BREAKPOINT["lg"] = "lg";
    BREAKPOINT["xl"] = "xl";
})(BREAKPOINT || (BREAKPOINT = {}));
/**
 * The LayoutConfig supports the configuration of page slots by page templates
 * or page sections, such as headers and footers. The configuration also supports
 * adaptive design per breakpoint (not per device type), so that the DOM is (re)rendered
 * por a given breakpoint.
 */
class LayoutConfig {
}
LayoutConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LayoutConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LayoutConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LayoutConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LayoutConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class LaunchDialogService {
    get data$() {
        return this._dataSubject.asObservable();
    }
    constructor(renderStrategies, layoutConfig) {
        this.renderStrategies = renderStrategies;
        this.layoutConfig = layoutConfig;
        this._dialogClose = new BehaviorSubject(undefined);
        this._dataSubject = new BehaviorSubject(undefined);
        this.renderStrategies = this.renderStrategies || [];
    }
    /**
     * Open the dialog
     *
     * @param caller LAUNCH_CALLER
     * @param openElement button's Element ref
     * @param vcr View Container Ref of the container for inline rendering
     * @param data optional data which could be passed to dialog
     */
    openDialog(caller, openElement, vcr, data) {
        const component = this.launch(caller, vcr, data);
        if (component) {
            return combineLatest([component, this.dialogClose]).pipe(filter(([, close]) => close !== undefined), tap(([comp]) => {
                openElement?.nativeElement.focus();
                this.clear(caller);
                comp?.destroy();
            }), map(([comp]) => comp));
        }
    }
    /**
     * Render the element based on the strategy from the launch configuration
     *
     * @param caller LAUNCH_CALLER
     * @param vcr View Container Ref of the container for inline rendering
     */
    launch(caller, vcr, data) {
        const config = this.findConfiguration(caller);
        if (config) {
            const renderer = this.getStrategy(config);
            // Render if the strategy exists
            if (renderer) {
                this._dialogClose.next(undefined);
                this._dataSubject.next(data);
                return renderer.render(config, caller, vcr);
            }
        }
        else if (isDevMode()) {
            console.warn('No configuration provided for caller ' + caller);
        }
    }
    /**
     * Opens dialog and subscribe in the service. Should be used if the trigger component might get destroyed while the component is open.
     *
     * @param caller Launch Caller
     * @param openElement Element to open
     * @param data Data to provide to the rendered element
     */
    openDialogAndSubscribe(caller, openElement, data) {
        this.openDialog(caller, openElement, undefined, data)
            ?.pipe(take(1))
            .subscribe();
    }
    /**
     * Util method to remove element from rendered elements list
     *
     * @param caller LAUNCH_CALLER
     */
    clear(caller) {
        const config = this.findConfiguration(caller);
        if (config) {
            const renderer = this.getStrategy(config);
            // Render if the strategy exists
            if (renderer) {
                renderer.remove(caller, config);
            }
        }
    }
    get dialogClose() {
        return this._dialogClose.asObservable();
    }
    closeDialog(reason) {
        this._dialogClose.next(reason);
    }
    /**
     * Returns the configuration for the caller
     *
     * @param caller LAUNCH_CALLER
     */
    findConfiguration(caller) {
        if (this.layoutConfig?.launch) {
            return this.layoutConfig.launch[caller];
        }
        return undefined;
    }
    /**
     * Returns the render strategy based on the configuration
     *
     * @param config Configuration for launch
     */
    getStrategy(config) {
        return resolveApplicable(this.renderStrategies, [config]);
    }
}
LaunchDialogService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LaunchDialogService, deps: [{ token: LaunchRenderStrategy }, { token: LayoutConfig }], target: i0.ɵɵFactoryTarget.Injectable });
LaunchDialogService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LaunchDialogService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LaunchDialogService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LaunchRenderStrategy]
                }] }, { type: LayoutConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AnonymousConsentManagementBannerComponent {
    constructor(anonymousConsentsService, vcr, launchDialogService) {
        this.anonymousConsentsService = anonymousConsentsService;
        this.vcr = vcr;
        this.launchDialogService = launchDialogService;
        this.subscriptions = new Subscription();
        this.bannerVisible$ = this.anonymousConsentsService.isBannerVisible();
    }
    viewDetails() {
        this.hideBanner();
        const dialog = this.launchDialogService.openDialog("ANONYMOUS_CONSENT" /* LAUNCH_CALLER.ANONYMOUS_CONSENT */, undefined, this.vcr);
        if (dialog) {
            this.subscriptions.add(dialog.subscribe());
        }
    }
    allowAll() {
        this.subscriptions.add(this.anonymousConsentsService
            .giveAllConsents()
            .pipe(tap(() => this.hideBanner()))
            .subscribe());
    }
    hideBanner() {
        this.anonymousConsentsService.toggleBannerDismissed(true);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
AnonymousConsentManagementBannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentManagementBannerComponent, deps: [{ token: i1.AnonymousConsentsService }, { token: i0.ViewContainerRef }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
AnonymousConsentManagementBannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: AnonymousConsentManagementBannerComponent, selector: "cx-anonymous-consent-management-banner", ngImport: i0, template: "<ng-container *ngIf=\"bannerVisible$ | async as bannerVisible\">\n  <div\n    [ngClass]=\"{ 'anonymous-consent-banner-hidden': !bannerVisible }\"\n    class=\"anonymous-consent-banner\"\n  >\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-lg-7 col-xs-12\">\n          <div class=\"cx-banner-title\">\n            {{ 'anonymousConsents.banner.title' | cxTranslate }}\n          </div>\n          <div class=\"cx-banner-description\">\n            {{ 'anonymousConsents.banner.description' | cxTranslate }}\n          </div>\n        </div>\n\n        <div class=\"col-lg-5 col-xs-12 cx-banner-buttons\">\n          <button class=\"btn btn-secondary\" (click)=\"viewDetails()\">\n            {{ 'anonymousConsents.banner.viewDetails' | cxTranslate }}\n          </button>\n          <button class=\"btn btn-primary\" (click)=\"allowAll()\">\n            {{ 'anonymousConsents.banner.allowAll' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentManagementBannerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-anonymous-consent-management-banner', template: "<ng-container *ngIf=\"bannerVisible$ | async as bannerVisible\">\n  <div\n    [ngClass]=\"{ 'anonymous-consent-banner-hidden': !bannerVisible }\"\n    class=\"anonymous-consent-banner\"\n  >\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-lg-7 col-xs-12\">\n          <div class=\"cx-banner-title\">\n            {{ 'anonymousConsents.banner.title' | cxTranslate }}\n          </div>\n          <div class=\"cx-banner-description\">\n            {{ 'anonymousConsents.banner.description' | cxTranslate }}\n          </div>\n        </div>\n\n        <div class=\"col-lg-5 col-xs-12 cx-banner-buttons\">\n          <button class=\"btn btn-secondary\" (click)=\"viewDetails()\">\n            {{ 'anonymousConsents.banner.viewDetails' | cxTranslate }}\n          </button>\n          <button class=\"btn btn-primary\" (click)=\"allowAll()\">\n            {{ 'anonymousConsents.banner.allowAll' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: i1.AnonymousConsentsService }, { type: i0.ViewContainerRef }, { type: LaunchDialogService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class InlineRenderStrategy extends LaunchRenderStrategy {
    constructor(document, rendererFactory, componentFactoryResolver) {
        super(document, rendererFactory);
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * Renders the component from the configuration in the view container ref
     *
     * @param config
     * @param caller
     * @param vcr
     */
    render(config, caller, vcr) {
        // Only render if a ViewContainerRef is provided
        if (vcr && this.shouldRender(caller, config)) {
            const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
            const component = vcr.createComponent(template);
            if (config?.dialogType) {
                this.applyClasses(component, config?.dialogType);
            }
            this.renderedCallers.push({ caller, element: vcr.element, component });
            return of(component);
        }
        else if (isDevMode()) {
            if (!vcr) {
                console.warn(`No view container ref provided for ${caller}`);
            }
            else {
                console.warn(`Element for ${caller} already rendered. To allow multi rendering add property multi: true.`);
            }
        }
    }
    hasMatch(config) {
        return Boolean(config.inline);
    }
}
InlineRenderStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: InlineRenderStrategy, deps: [{ token: DOCUMENT }, { token: i0.RendererFactory2 }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Injectable });
InlineRenderStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: InlineRenderStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: InlineRenderStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.RendererFactory2 }, { type: i0.ComponentFactoryResolver }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class InlineRootRenderStrategy extends LaunchRenderStrategy {
    constructor(document, rendererFactory, componentFactoryResolver, injector) {
        super(document, rendererFactory);
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    get hostComponent() {
        return this.injector.get(ApplicationRef)?.components?.[0];
    }
    render(config, caller) {
        if (this.shouldRender(caller, config)) {
            const componentFactory = this.componentFactoryResolver.resolveComponentFactory(config.component);
            const contentInjector = Injector.create({
                providers: [],
            });
            const componentRef = componentFactory.create(contentInjector);
            this.injector.get(ApplicationRef)?.attachView(componentRef.hostView);
            this.renderer.appendChild(this.hostComponent?.location.nativeElement, componentRef.location.nativeElement);
            if (config?.dialogType) {
                this.applyClasses(componentRef, config?.dialogType);
            }
            this.renderedCallers.push({ caller, component: componentRef });
            return of(componentRef);
        }
    }
    hasMatch(config) {
        return Boolean(config.inlineRoot);
    }
}
InlineRootRenderStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: InlineRootRenderStrategy, deps: [{ token: DOCUMENT }, { token: i0.RendererFactory2 }, { token: i0.ComponentFactoryResolver }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
InlineRootRenderStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: InlineRootRenderStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: InlineRootRenderStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.RendererFactory2 }, { type: i0.ComponentFactoryResolver }, { type: i0.Injector }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var OutletPosition;
(function (OutletPosition) {
    OutletPosition["REPLACE"] = "replace";
    OutletPosition["BEFORE"] = "before";
    OutletPosition["AFTER"] = "after";
})(OutletPosition || (OutletPosition = {}));
const AVOID_STACKED_OUTLETS = false;
const USE_STACKED_OUTLETS = true;
/**
 * Token for injecting outlet related context to the component rendered in the outlet
 */
class OutletContextData {
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class OutletService {
    constructor() {
        this.templatesRefs = {
            [OutletPosition.BEFORE]: new Map(),
            [OutletPosition.REPLACE]: new Map(),
            [OutletPosition.AFTER]: new Map(),
        };
    }
    /**
     * @param templateOrFactory A `ComponentFactory` that inserts a component dynamically.
     */
    add(outlet, templateOrFactory, position = OutletPosition.REPLACE) {
        const store = this.templatesRefs[position];
        if (store) {
            const existing = store.get(outlet) || [];
            const newValue = existing.concat([templateOrFactory]);
            store.set(outlet, newValue);
        }
    }
    /**
     *
     * Returns a single object or multiple objects for the given outlet reference,
     * depending on the `stacked` argument.
     *
     * @param outlet The outlet reference
     * @param position the outlet position, `OutletPosition.before`, `OutletPosition.AFTER` or `OutletPosition.REPLACE`
     * @param stacked Indicates whether an array of outlet components is returned
     */
    get(outlet, position = OutletPosition.REPLACE, stacked = AVOID_STACKED_OUTLETS) {
        const store = this.templatesRefs[position] ||
            this.templatesRefs[OutletPosition.REPLACE];
        const templateRef = store.get(outlet);
        if (templateRef && !stacked) {
            return templateRef[0];
        }
        return templateRef;
    }
    remove(outlet, position = OutletPosition.REPLACE, value) {
        const store = this.templatesRefs[position] ||
            this.templatesRefs[OutletPosition.REPLACE];
        this.removeValueOrAll(store, outlet, value);
    }
    removeValueOrAll(store, outlet, value) {
        if (!value && store.has(outlet)) {
            store.delete(outlet);
        }
        else if (value && store.has(outlet)) {
            let existing = store.get(outlet);
            existing = existing?.filter((val) => val !== value);
            if (existing) {
                store.set(outlet, existing);
            }
        }
    }
}
OutletService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
OutletService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class OutletRefDirective {
    constructor(tpl, outletService) {
        this.tpl = tpl;
        this.outletService = outletService;
    }
    ngOnInit() {
        this.outletService.add(this.cxOutletRef, this.tpl, this.cxOutletPos);
    }
    ngOnDestroy() {
        this.outletService.remove(this.cxOutletRef, this.cxOutletPos, this.tpl);
    }
}
OutletRefDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRefDirective, deps: [{ token: i0.TemplateRef }, { token: OutletService }], target: i0.ɵɵFactoryTarget.Directive });
OutletRefDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: OutletRefDirective, selector: "[cxOutletRef]", inputs: { cxOutletRef: "cxOutletRef", cxOutletPos: "cxOutletPos" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxOutletRef]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: OutletService }]; }, propDecorators: { cxOutletRef: [{
                type: Input
            }], cxOutletPos: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class OutletRefModule {
}
OutletRefModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRefModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OutletRefModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: OutletRefModule, declarations: [OutletRefDirective], imports: [CommonModule], exports: [OutletRefDirective] });
OutletRefModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRefModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRefModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [OutletRefDirective],
                    exports: [OutletRefDirective],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class OutletRendererService {
    constructor() {
        this.outletRefs = new BehaviorSubject(new Map());
    }
    /**
     * Dynamically render the templates in the specified array
     *
     * @param outlet
     */
    render(outlet) {
        if (this.outletRefs.value.size !== 0) {
            this.outletRefs.value.get(outlet)?.render();
        }
    }
    /**
     * Register outlet to be available to render dynamically
     *
     * @param cxOutlet
     * @param context
     */
    register(cxOutlet, context) {
        this.outletRefs.next(this.outletRefs.value.set(cxOutlet, context));
    }
    /**
     * Returns map of outlets
     *
     */
    getOutletRef(outlet) {
        return this.outletRefs.asObservable().pipe(map((val) => val.get(outlet)), filter(isNotNullable));
    }
}
OutletRendererService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRendererService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
OutletRendererService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRendererService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRendererService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The IntersectionService uses the native IntersectionObserver (v2), which
 * can be used to implement pre-loading and deferred loading of DOM content.
 *
 */
class IntersectionService {
    constructor(config) {
        this.config = config;
    }
    /**
     * Returns an Observable that emits only once a boolean value whenever
     * the given element has shown in the view port.
     *
     * The returned observable will only emit the first value. The
     * observable must be cleaned up either way, since the value might never emit; it
     * depends on whether the element appears in the view port.
     *
     * @param element - HTML element
     * @param options - Allows to specify an optional root margin, in order to fire before the element shows up in the viewport
     * @param intersectingCondition - Allows to specify an intersecting condition.
     * If this parameter is not set, then the transition state of the element will be verified whenever the element intersects the view port.
     * @returns Element intersects?
     */
    isIntersected(element, options, intersectingCondition) {
        return this.intersects(element, options, intersectingCondition).pipe(first((v) => v === true));
    }
    /**
     * Returns an observable that emits for every change of intersection of a given element.
     *
     * @param element - HTML element
     * @param options - Allows to specify an optional root margin, in order to fire before the element shows up in the viewport
     * @param intersectingCondition - Allows to specify an intersecting condition.
     * If this parameter is not set, then the transition state of the element will be verified whenever the element intersects the view port.
     * @returns Element intersects?
     */
    isIntersecting(element, options, intersectingCondition) {
        return this.intersects(element, options, intersectingCondition);
    }
    /**
     * Indicates whenever the element intersects the view port. An optional margin
     * is used to intersects before the element shows up in the viewport.
     * A value is emitted each time the element intersects.
     */
    intersects(element, options = {}, intersectingCondition) {
        return this.createIntersectionObservable(element, options).pipe(mergeMap((entries) => entries), map((entry) => intersectingCondition
            ? intersectingCondition(entry)
            : entry.isIntersecting), distinctUntilChanged());
    }
    createIntersectionObservable(element, options) {
        return new Observable((observer) => {
            const rootMargin = this.getRootMargin(options);
            const intersectOptions = { rootMargin, threshold: options.threshold };
            const intersectionObserver = new IntersectionObserver((entries) => {
                observer.next(entries);
            }, intersectOptions);
            intersectionObserver.observe(element);
            return () => {
                intersectionObserver.disconnect();
            };
        });
    }
    getRootMargin(options = {}) {
        if (options.rootMargin) {
            return options.rootMargin;
        }
        const layoutConfig = this.config;
        if (layoutConfig.deferredLoading &&
            layoutConfig.deferredLoading.intersectionMargin) {
            return layoutConfig.deferredLoading.intersectionMargin;
        }
    }
}
IntersectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IntersectionService, deps: [{ token: LayoutConfig }], target: i0.ɵɵFactoryTarget.Injectable });
IntersectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IntersectionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IntersectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: LayoutConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The defer loading serivce is used to defer loading of DOM elements
 * until the elements are required for the user experience.
 */
class DeferLoaderService {
    constructor(platformId, config, intersectionService) {
        this.platformId = platformId;
        this.config = config;
        this.intersectionService = intersectionService;
        this.globalLoadStrategy =
            config.deferredLoading?.strategy ?? DeferLoadingStrategy.INSTANT;
    }
    /**
     * Defer loading till the element intersects the viewport.
     *
     * We evaluate whether we instantly load the element for different reasons:
     * - we run in SSR mode
     * - there's no global strategy given
     * - the global loading strategy is set to INSTANT loading,
     *   and the loading strategy in the given is not set to DEFER
     * - the loading strategy in the given options is set to INSTANT
     */
    load(element, options) {
        if (this.shouldLoadInstantly((options || {}).deferLoading)) {
            return of(true);
        }
        else {
            return this.intersectionService.isIntersected(element, options);
        }
    }
    shouldLoadInstantly(elementLoadingStrategy) {
        return (isPlatformServer(this.platformId) ||
            elementLoadingStrategy === DeferLoadingStrategy.INSTANT ||
            (elementLoadingStrategy !== DeferLoadingStrategy.DEFER &&
                this.globalLoadStrategy === DeferLoadingStrategy.INSTANT));
    }
}
DeferLoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DeferLoaderService, deps: [{ token: PLATFORM_ID }, { token: LayoutConfig }, { token: IntersectionService }], target: i0.ɵɵFactoryTarget.Injectable });
DeferLoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DeferLoaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DeferLoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: LayoutConfig }, { type: IntersectionService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class OutletDirective {
    constructor(vcr, templateRef, outletService, deferLoaderService, outletRendererService) {
        this.vcr = vcr;
        this.templateRef = templateRef;
        this.outletService = outletService;
        this.deferLoaderService = deferLoaderService;
        this.outletRendererService = outletRendererService;
        this.renderedTemplate = [];
        this.renderedComponents = new Map();
        /**
         * Observable with current outlet context
         */
        this.outletContext$ = new ReplaySubject(1);
        this.loaded = new EventEmitter(true);
        this.cxComponentRefChange = new EventEmitter();
        this.subscription = new Subscription();
    }
    /**
     * Renders view for outlet or defers it, depending on the input `cxOutletDefer`
     */
    render() {
        this.vcr.clear();
        this.renderedTemplate = [];
        this.renderedComponents.clear();
        this.subscription.unsubscribe();
        this.subscription = new Subscription();
        if (this.cxOutletDefer) {
            this.deferLoading();
        }
        else {
            this.build();
        }
    }
    ngOnChanges(changes) {
        if (changes.cxOutlet) {
            this.render();
            this.outletRendererService.register(this.cxOutlet, this);
        }
        if (changes.cxOutletContext) {
            this.outletContext$.next(this.cxOutletContext);
        }
    }
    deferLoading() {
        this.loaded.emit(false);
        const hostElement = this.getHostElement(this.vcr.element.nativeElement);
        // Although the deferLoaderService might emit only once, as long as the hostElement
        // isn't being loaded, there's no value being emitted. Therefore we need to clean up
        // the subscription on destroy.
        this.subscription.add(this.deferLoaderService
            .load(hostElement, this.cxOutletDefer)
            .subscribe(() => {
            this.build();
            this.loaded.emit(true);
        }));
    }
    /**
     * Renders view for outlet
     */
    build() {
        this.buildOutlet(OutletPosition.BEFORE);
        this.buildOutlet(OutletPosition.REPLACE);
        this.buildOutlet(OutletPosition.AFTER);
    }
    /**
     * Renders view in a given position for outlet
     */
    buildOutlet(position) {
        let templates = (this.outletService.get(this.cxOutlet, position, USE_STACKED_OUTLETS));
        templates = templates?.filter((el) => !this.renderedTemplate.includes(el));
        if (!templates && position === OutletPosition.REPLACE) {
            templates = [this.templateRef];
        }
        // Just in case someone extended the `OutletService` and
        // returns a singular object.
        if (!Array.isArray(templates)) {
            templates = [templates];
        }
        const components = [];
        templates.forEach((obj) => {
            const component = this.create(obj, position);
            if (component) {
                components.push(component);
            }
        });
        this.renderedComponents.set(position, components);
    }
    /**
     * Renders view based on the given template or component factory
     */
    create(tmplOrFactory, position) {
        this.renderedTemplate.push(tmplOrFactory);
        if (tmplOrFactory instanceof ComponentFactory) {
            const component = this.vcr.createComponent(tmplOrFactory, undefined, this.getComponentInjector(position));
            this.cxComponentRefChange.emit(component);
            return component;
        }
        else if (tmplOrFactory instanceof TemplateRef) {
            const view = this.vcr.createEmbeddedView(tmplOrFactory, {
                $implicit: this.cxOutletContext,
            });
            // we do not know if content is created dynamically or not
            // so we apply change detection anyway
            view.markForCheck();
            this.cxComponentRefChange.emit(view);
            return view;
        }
    }
    /**
     * Returns injector with OutletContextData that can be injected to the component
     * rendered in the outlet
     */
    getComponentInjector(position) {
        const contextData = {
            reference: this.cxOutlet,
            position,
            context: this.cxOutletContext,
            context$: this.outletContext$.asObservable(),
        };
        return Injector.create({
            providers: [
                {
                    provide: OutletContextData,
                    useValue: contextData,
                },
            ],
            parent: this.vcr.injector,
        });
    }
    /**
     * Returns the closest `HtmlElement`, by iterating over the
     * parent nodes of the given element.
     *
     * We avoid traversing the parent _elements_, as this is blocking
     * ie11 implementations. One of the spare exclusions we make to not
     * supporting ie11.
     *
     * @param element
     */
    getHostElement(element) {
        if (element instanceof HTMLElement) {
            return element;
        }
        return this.getHostElement(element.parentNode);
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.outletContext$.complete();
    }
}
OutletDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: OutletService }, { token: DeferLoaderService }, { token: OutletRendererService }], target: i0.ɵɵFactoryTarget.Directive });
OutletDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: OutletDirective, selector: "[cxOutlet]", inputs: { cxOutlet: "cxOutlet", cxOutletContext: "cxOutletContext", cxOutletDefer: "cxOutletDefer", cxComponentRef: "cxComponentRef" }, outputs: { loaded: "loaded", cxComponentRefChange: "cxComponentRefChange" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxOutlet]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: OutletService }, { type: DeferLoaderService }, { type: OutletRendererService }]; }, propDecorators: { cxOutlet: [{
                type: Input
            }], cxOutletContext: [{
                type: Input
            }], cxOutletDefer: [{
                type: Input
            }], loaded: [{
                type: Output
            }], cxComponentRef: [{
                type: Input
            }], cxComponentRefChange: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @private We plan to drive the outlets by standard configuration
 */
const PROVIDE_OUTLET_OPTIONS = new InjectionToken('PROVIDE_OUTLET_OPTIONS');
/**
 * Helper function to register a component for an outlet.
 *
 * @param options.id unique id of the outlet
 * @param options.component Component to be registered for the outlet
 * @param options.position Component's position in the outlet (default: `OutletPosition.AFTER`)
 */
function provideOutlet(options) {
    return {
        provide: PROVIDE_OUTLET_OPTIONS,
        useValue: options,
        multi: true,
    };
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @private
 */
function registerOutletsFactory(providedOutletOptions, componentFactoryResolver, outletService) {
    const result = () => {
        (providedOutletOptions ?? []).forEach((options) => {
            const factory = componentFactoryResolver.resolveComponentFactory(options.component);
            outletService.add(options.id, factory, options.position ?? OutletPosition.AFTER);
        });
    };
    return result;
}
class OutletModule {
    static forRoot() {
        return {
            ngModule: OutletModule,
            providers: [
                {
                    provide: APP_INITIALIZER,
                    useFactory: registerOutletsFactory,
                    deps: [
                        [new Optional(), PROVIDE_OUTLET_OPTIONS],
                        ComponentFactoryResolver,
                        OutletService,
                    ],
                    multi: true,
                },
            ],
        };
    }
    static forChild() {
        return {
            ngModule: OutletModule,
            providers: [
                {
                    provide: MODULE_INITIALIZER,
                    useFactory: registerOutletsFactory,
                    deps: [
                        [new Optional(), PROVIDE_OUTLET_OPTIONS],
                        ComponentFactoryResolver,
                        OutletService,
                    ],
                    multi: true,
                },
            ],
        };
    }
}
OutletModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
OutletModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: OutletModule, declarations: [OutletDirective], imports: [CommonModule], exports: [OutletDirective] });
OutletModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [OutletDirective],
                    exports: [OutletDirective],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class OutletRenderStrategy extends LaunchRenderStrategy {
    constructor(document, rendererFactory, outletService, componentFactoryResolver, outletRendererService) {
        super(document, rendererFactory);
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.outletService = outletService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.outletRendererService = outletRendererService;
    }
    /**
     * Renders the element in the configured outlet
     *
     * @param config
     * @param caller
     * @param vcr
     */
    render(config, caller) {
        if (this.shouldRender(caller, config)) {
            const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
            this.outletService.add(config.outlet, template, config.position ? config.position : OutletPosition.BEFORE);
            this.outletRendererService.render(config.outlet);
            this.renderedCallers.push({ caller });
            return this.outletRendererService.getOutletRef(config.outlet).pipe(map((outletDirective) => {
                const components = outletDirective.renderedComponents.get(config.position ? config.position : OutletPosition.BEFORE);
                return components
                    .reverse()
                    .find((component) => component.componentType === template.componentType);
            }), tap((component) => {
                if (config?.dialogType && component) {
                    this.applyClasses(component, config?.dialogType);
                }
            }));
        }
    }
    hasMatch(config) {
        return Boolean(config.outlet);
    }
    remove(caller, config) {
        const template = this.componentFactoryResolver.resolveComponentFactory(config.component);
        this.outletService.remove(config.outlet, config.position ? config.position : OutletPosition.BEFORE, template);
        super.remove(caller, config);
    }
}
OutletRenderStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRenderStrategy, deps: [{ token: DOCUMENT }, { token: i0.RendererFactory2 }, { token: OutletService }, { token: i0.ComponentFactoryResolver }, { token: OutletRendererService }], target: i0.ɵɵFactoryTarget.Injectable });
OutletRenderStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRenderStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OutletRenderStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.RendererFactory2 }, { type: OutletService }, { type: i0.ComponentFactoryResolver }, { type: OutletRendererService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class RoutingRenderStrategy extends LaunchRenderStrategy {
    constructor(document, rendererFactory, routingService) {
        super(document, rendererFactory);
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.routingService = routingService;
    }
    /**
     * Navigates to the route configured for the caller
     */
    render(config, _caller) {
        this.routingService.go(config);
    }
    hasMatch(config) {
        return Boolean(config.cxRoute);
    }
}
RoutingRenderStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingRenderStrategy, deps: [{ token: DOCUMENT }, { token: i0.RendererFactory2 }, { token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Injectable });
RoutingRenderStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingRenderStrategy, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingRenderStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.RendererFactory2 }, { type: i1.RoutingService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class LaunchDialogModule {
    static forRoot() {
        return {
            ngModule: LaunchDialogModule,
            providers: [{ provide: LayoutConfig, useExisting: Config }],
        };
    }
}
LaunchDialogModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LaunchDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LaunchDialogModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: LaunchDialogModule });
LaunchDialogModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LaunchDialogModule, providers: [
        {
            provide: LaunchRenderStrategy,
            useExisting: OutletRenderStrategy,
            multi: true,
        },
        {
            provide: LaunchRenderStrategy,
            useExisting: InlineRenderStrategy,
            multi: true,
        },
        {
            provide: LaunchRenderStrategy,
            useExisting: RoutingRenderStrategy,
            multi: true,
        },
        {
            provide: LaunchRenderStrategy,
            useExisting: InlineRootRenderStrategy,
            multi: true,
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LaunchDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: OutletRenderStrategy,
                            multi: true,
                        },
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: InlineRenderStrategy,
                            multi: true,
                        },
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: RoutingRenderStrategy,
                            multi: true,
                        },
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: InlineRootRenderStrategy,
                            multi: true,
                        },
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var ICON_TYPE;
(function (ICON_TYPE) {
    ICON_TYPE["ACTIVE"] = "ACTIVE";
    ICON_TYPE["ADDRESS_BOOK"] = "ADDRESS_BOOK";
    ICON_TYPE["AMEX"] = "AMEX";
    ICON_TYPE["CARET_DOWN"] = "CARET_DOWN";
    ICON_TYPE["CARET_LEFT"] = "CARET_LEFT";
    ICON_TYPE["CARET_RIGHT"] = "CARET_RIGHT";
    ICON_TYPE["CARET_UP"] = "CARET_UP";
    ICON_TYPE["CART"] = "CART";
    ICON_TYPE["CHECK"] = "CHECK";
    ICON_TYPE["CIRCLE"] = "CIRCLE";
    ICON_TYPE["CLIPBOARD_LIST"] = "CLIPBOARD_LIST";
    ICON_TYPE["CLOCK"] = "CLOCK";
    ICON_TYPE["CLOSE"] = "CLOSE";
    ICON_TYPE["COLLAPSE"] = "COLLAPSE";
    ICON_TYPE["CREDIT_CARD"] = "CREDIT_CARD";
    ICON_TYPE["DINERS_CLUB"] = "DINERS_CLUB";
    ICON_TYPE["DOWNLOAD"] = "DOWNLOAD";
    ICON_TYPE["EMPTY_HEART"] = "EMPTY_HEART";
    ICON_TYPE["ERROR"] = "ERROR";
    ICON_TYPE["EXPAND"] = "EXPAND";
    ICON_TYPE["EXPAND_ARROWS"] = "EXPAND_ARROWS";
    ICON_TYPE["EYE"] = "EYE";
    ICON_TYPE["EYE_SLASH"] = "EYE_SLASH";
    ICON_TYPE["FILE"] = "FILE";
    ICON_TYPE["FILTER"] = "FILTER";
    ICON_TYPE["GRID"] = "GRID";
    ICON_TYPE["HEART"] = "HEART";
    ICON_TYPE["INFO"] = "INFO";
    ICON_TYPE["LINK_OUT"] = "LINK_OUT";
    ICON_TYPE["LIST"] = "LIST";
    ICON_TYPE["MASTER_CARD"] = "MASTER_CARD";
    ICON_TYPE["OFF"] = "OFF";
    ICON_TYPE["ON"] = "ON";
    ICON_TYPE["ORDER"] = "ORDER";
    ICON_TYPE["PENCIL"] = "PENCIL";
    ICON_TYPE["RESET"] = "RESET";
    ICON_TYPE["REPEAT"] = "REPEAT";
    ICON_TYPE["SEARCH"] = "SEARCH";
    ICON_TYPE["SORT"] = "SORT";
    ICON_TYPE["SORT_AMOUNT_DOWN"] = "SORT_AMOUNT_DOWN";
    ICON_TYPE["SORT_AMOUNT_UP"] = "SORT_AMOUNT_UP";
    ICON_TYPE["SORT_DOWN"] = "SORT_DOWN";
    ICON_TYPE["STAR"] = "STAR";
    ICON_TYPE["SUCCESS"] = "SUCCESS";
    ICON_TYPE["TRASH"] = "TRASH";
    ICON_TYPE["USER_FRIENDS"] = "USER_FRIENDS";
    ICON_TYPE["VISA"] = "VISA";
    ICON_TYPE["WARNING"] = "WARNING";
    ICON_TYPE["HEADSET"] = "HEADSET";
    ICON_TYPE["ATTACHMENT"] = "ATTACHMENT";
    ICON_TYPE["UPLOAD"] = "UPLOAD";
    ICON_TYPE["USER"] = "USER";
    ICON_TYPE["ARROW_LEFT"] = "ARROW_LEFT";
    ICON_TYPE["ARROW_RIGHT"] = "ARROW_RIGHT";
    ICON_TYPE["ARROW_DOWN"] = "ARROW_DOWN";
    ICON_TYPE["ARROW_UP"] = "ARROW_UP";
})(ICON_TYPE || (ICON_TYPE = {}));
class IconConfig {
}
IconConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
IconConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });
/**
 * Each ICON type can have an companied resource type, such as SVG, LINK (font) or just TEXT.
 * The resources will be automatically loaded in case they're required for the `ICON_TYPE`.
 */
var IconResourceType;
(function (IconResourceType) {
    /**
     * An svg based icon requires an SVG resource that must be loaded,
     * this is typically a sprite svg file.
     */
    IconResourceType["SVG"] = "svg";
    /**
     * A font based ICON might require an additional CSS file to be loaded.
     */
    IconResourceType["LINK"] = "link";
    /**
     * Text based icons will simply add the ICON string to the DOM. Text icons do not need an image
     * or CSS pseudo class (i.e. :before), as the text itself is the icon (i.e. +)
     */
    IconResourceType["TEXT"] = "text";
})(IconResourceType || (IconResourceType = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const fontawesomeIconConfig = {
    icon: {
        symbols: {
            ACTIVE: 'fas fa-check',
            ADDRESS_BOOK: 'far fa-address-book',
            AMEX: 'fab fa-cc-amex',
            CARET_DOWN: 'fas fa-angle-down',
            CARET_LEFT: 'fas fa-angle-left',
            CARET_RIGHT: 'fas fa-angle-right',
            CARET_UP: 'fas fa-angle-up',
            CART: 'fas fa-shopping-cart',
            CHECK: 'fas fa-check',
            CIRCLE: 'fas fa-circle',
            CLIPBOARD_LIST: 'fas fa-clipboard-list',
            CLOCK: 'far fa-clock',
            CLOSE: 'fas fa-times',
            COLLAPSE: 'fas fa-minus',
            CREDIT_CARD: 'fas fa-credit-card',
            DINERS_CLUB: 'fab fa-cc-diners-club',
            DOWNLOAD: 'fas fa-download',
            EMPTY_HEART: 'far fa-heart',
            ERROR: 'fas fa-exclamation-circle',
            EXPAND_ARROWS: 'fas fa-expand',
            EXPAND: 'fas fa-plus',
            EYE_SLASH: 'fas fa-eye-slash',
            EYE: 'fas fa-eye',
            FILE: 'fas fa-file',
            FILTER: 'fas fa-filter',
            GRID: 'fas fa-th-large',
            HEART: 'fas fa-heart',
            INFO: 'fas fa-info-circle',
            LINK_OUT: 'fas fa-external-link-alt',
            LIST: 'fas fa-bars',
            MASTER_CARD: 'fab fa-cc-mastercard',
            OFF: 'fas fa-toggle-off',
            ON: 'fas fa-toggle-on',
            ORDER: 'fas fa-clipboard-list',
            PDF_FILE: 'fas fa-file-pdf',
            PENCIL: 'fas fa-pencil-alt',
            REPEAT: 'fas fa-retweet',
            RESET: 'fas fa-times-circle',
            SEARCH: 'fas fa-search',
            SORT_AMOUNT_DOWN: 'fas fa-sort-amount-down',
            SORT_AMOUNT_UP: 'fas fa-sort-amount-up',
            SORT_DOWN: 'fas fa-sort-down',
            SORT: 'fas fa-sort',
            STAR: 'fas fa-star',
            SUCCESS: 'fas fa-check-circle',
            TRASH: 'fas fa-trash',
            USER_FRIENDS: 'fas fa-user-friends',
            VISA: 'fab fa-cc-visa',
            WARNING: 'fas fa-exclamation-triangle',
            HEADSET: 'fas fa-headset',
            ATTACHMENT: 'fas fa-paperclip',
            UPLOAD: 'fas fa-upload',
            USER: 'fas fa-user',
            ARROW_LEFT: 'fas fa-arrow-left',
            ARROW_RIGHT: 'fas  fa-arrow-right',
            ARROW_DOWN: 'fas  fa-arrow-down',
            ARROW_UP: 'fas  fa-arrow-up',
        },
        resources: [
            {
                type: IconResourceType.LINK,
                url: '',
            },
        ],
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class IconLoaderService {
    constructor(winRef, iconConfig, sanitizer) {
        this.winRef = winRef;
        this.iconConfig = iconConfig;
        this.sanitizer = sanitizer;
        this.loadedResources = [];
    }
    /**
     * Returns an html fragment which can be added to the DOM in a safe way.
     */
    getHtml(type) {
        if (this.isResourceType(type, IconResourceType.SVG)) {
            const url = this.sanitizer.sanitize(SecurityContext.URL, this.getSvgPath(type) || null);
            if (url) {
                const useElement = this.winRef.document.createElement('use');
                useElement.setAttribute('xlink:href', url);
                const svgElement = this.winRef.document.createElement('svg');
                svgElement.appendChild(useElement);
                return this.sanitizer.bypassSecurityTrustHtml(svgElement.outerHTML);
            }
        }
        if (this.isResourceType(type, IconResourceType.TEXT)) {
            const symbol = this.getSymbol(type);
            if (symbol) {
                const helperDiv = this.winRef.document.createElement('div');
                helperDiv.textContent = symbol;
                return this.sanitizer.bypassSecurityTrustHtml(helperDiv.innerHTML);
            }
        }
    }
    /**
     * Return the direction for which the icon should mirror (ltr vs rtl). The icon direction
     * is configurable, but optional, as only a few icons should be flipped for rtl direction.
     */
    getFlipDirection(type) {
        return this.config?.flipDirection?.[type];
    }
    /**
     *
     * Returns the symbol class(es) for the icon type.
     */
    getStyleClasses(iconType) {
        return this.getSymbol(iconType) || '';
    }
    /**
     * Indicates whether the given `ICON_TYPE` is configured for
     * the given `IconResourceType`.
     */
    isResourceType(iconType, resourceType) {
        return (this.config?.resources !== undefined &&
            !!this.config.resources.find((res) => res.types && res.type === resourceType && res.types.includes(iconType)));
    }
    /**
     * Returns the path to the svg link. The link supports path names
     * as well, if the config a[[s been setup to support a svg file path.
     * Additionally, the icon prefix will be taken into account to prefix the
     * icon IDs in the SVG.
     */
    getSvgPath(iconType) {
        const svgResource = this.config?.resources?.find((res) => res.type === IconResourceType.SVG &&
            res.types &&
            res.types.includes(iconType));
        if (svgResource) {
            return svgResource.url
                ? `${svgResource.url}#${this.getSymbol(iconType)}`
                : `#${this.getSymbol(iconType)}`;
        }
    }
    /**
     * Loads the resource url (if any) for the given icon.
     * The icon will only be loaded once.
     *
     * NOTE: this is not working when the shadow is used as there's
     * no head element available and the link must be loaded for every
     * web component.
     */
    addLinkResource(iconType) {
        const resource = this.findResource(iconType, IconResourceType.LINK);
        if (resource?.url && !this.loadedResources.includes(resource.url)) {
            this.loadedResources.push(resource.url);
            // using DOM APIs, so need to sanitize our URLs manually
            const sanitizedUrl = this.sanitizer.sanitize(SecurityContext.URL, resource.url);
            if (sanitizedUrl) {
                const head = this.winRef.document.getElementsByTagName('head')[0];
                const link = this.winRef.document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = sanitizedUrl;
                head.appendChild(link);
            }
        }
    }
    findResource(iconType, resourceType) {
        if (!this.config?.resources) {
            return;
        }
        let resource = this.config.resources.find((res) => res.type === resourceType && res.types && res.types.includes(iconType));
        // no specific resource found, let's try to find a one-size-fits-all resource
        if (!resource) {
            resource = this.config.resources.find((res) => (res.type === resourceType && !res.types) ||
                (res.types && res.types.length === 0));
        }
        return resource;
    }
    getSymbol(iconType) {
        if (this.config && this.config.symbols && this.config.symbols[iconType]) {
            return this.config.symbols[iconType];
        }
    }
    get config() {
        return this.iconConfig.icon;
    }
}
IconLoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconLoaderService, deps: [{ token: i1.WindowRef }, { token: IconConfig }, { token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Injectable });
IconLoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconLoaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconLoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: IconConfig }, { type: i1$1.DomSanitizer }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The ltr and rtl directions can be used to configure the storefront for a certain direction, both statically
 * or dynamically.
 *
 * The HTML5 "auto" value is not supported in Spartacus, as it's considered to be too fragile for the global
 * direction.
 */
var DirectionMode;
(function (DirectionMode) {
    /**
     * Indicates Left to Right direction.
     */
    DirectionMode["LTR"] = "ltr";
    /**
     * Indicates Right to Left direction.
     */
    DirectionMode["RTL"] = "rtl";
})(DirectionMode || (DirectionMode = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 *
 * The icon component can be added in different ways:
 *
 * With the component selector:
 * `<cx-icon type="SEARCH"></cx-icon>`
 *
 * With the attribute selector:
 * `<span cxIcon="STAR"></span>`
 *
 * Additionally, content can be projected to the icon:
 *
 * `<button cxIcon="HAPPY">happy label</button>`
 *
 * The above button would become (based on a TEXT resource type):
 * `<button>😊happy label</button>`
 *
 * While the content is projected, the icon itself doesn't require an
 * additional DOM node which is an advantage over the component selector.
 */
class IconComponent {
    /**
     * The cxIcon directive is bound to the icon type. You can feed the `ICON_TYPE` to
     * accomplish a configurable button in the UI.
     */
    set cxIcon(type) {
        this.setIcon(type);
    }
    /**
     * The type input parameter is bound to the icon type. You can feed the `ICON_TYPE` to
     * accomplish a configurable button in the UI.
     */
    set type(type) {
        this.setIcon(type);
    }
    constructor(iconLoader, elementRef, renderer) {
        this.iconLoader = iconLoader;
        this.elementRef = elementRef;
        this.renderer = renderer;
    }
    setIcon(type) {
        if (!type || type === '') {
            return;
        }
        this.icon = this.iconLoader.getHtml(type);
        this.addStyleClasses(type);
        this.iconLoader.addLinkResource(type);
        this.flipIcon(type);
    }
    /**
     * The icons supports flipping for some icons to support rtl and ltr directions.
     */
    flipIcon(type) {
        // TODO: this can be dropped with the next major release.
        if (!this.iconLoader.getFlipDirection) {
            return;
        }
        const iconDirection = this.iconLoader.getFlipDirection(type);
        this.flipAtLtr = iconDirection === DirectionMode.LTR;
        this.flipAtRtl = iconDirection === DirectionMode.RTL;
    }
    /**
     * Adds the style classes and the link resource (if available).
     */
    addStyleClasses(type) {
        this.renderer.addClass(this.host, 'cx-icon');
        this.styleClasses?.forEach((cls) => this.renderer.removeClass(this.host, cls));
        this.styleClasses = this.iconLoader.getStyleClasses(type)?.split(' ');
        this.styleClasses?.forEach((cls) => {
            if (cls !== '') {
                this.renderer.addClass(this.host, cls);
            }
        });
    }
    get host() {
        return this.elementRef.nativeElement;
    }
}
IconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconComponent, deps: [{ token: IconLoaderService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
IconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: { cxIcon: "cxIcon", type: "type" }, host: { properties: { "class.flip-at-rtl": "this.flipAtRtl", "class.flip-at-ltr": "this.flipAtLtr" } }, ngImport: i0, template: "<i [outerHTML]=\"icon\"></i><ng-content></ng-content>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-icon,[cxIcon]', template: "<i [outerHTML]=\"icon\"></i><ng-content></ng-content>\n" }]
        }], ctorParameters: function () { return [{ type: IconLoaderService }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { cxIcon: [{
                type: Input
            }], type: [{
                type: Input
            }], flipAtRtl: [{
                type: HostBinding,
                args: ['class.flip-at-rtl']
            }], flipAtLtr: [{
                type: HostBinding,
                args: ['class.flip-at-ltr']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultIconConfig = {
    icon: {
        flipDirection: {
            CARET_RIGHT: DirectionMode.RTL,
            CARET_LEFT: DirectionMode.RTL,
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class IconModule {
}
IconModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IconModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: IconModule, declarations: [IconComponent], imports: [CommonModule], exports: [IconComponent] });
IconModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconModule, providers: [
        provideDefaultConfig(defaultIconConfig),
        // TODO: move the opinionated fontawesome config to a recipe
        provideDefaultConfig(fontawesomeIconConfig),
    ], imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [IconComponent],
                    imports: [CommonModule],
                    providers: [
                        provideDefaultConfig(defaultIconConfig),
                        // TODO: move the opinionated fontawesome config to a recipe
                        provideDefaultConfig(fontawesomeIconConfig),
                    ],
                    exports: [IconComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
// PRIVATE TESTING UTIL
class MockIconComponent {
}
MockIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MockIconComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MockIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: MockIconComponent, selector: "cx-icon,[cxIcon]", inputs: { cxIcon: "cxIcon", type: "type" }, ngImport: i0, template: `{{ type || cxIcon }}`, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MockIconComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-icon,[cxIcon]',
                    template: `{{ type || cxIcon }}`,
                }]
        }], propDecorators: { cxIcon: [{
                type: Input
            }], type: [{
                type: Input
            }] } });
const mockComponents = [MockIconComponent];
class MockIconLoaderService {
    getHtml() {
        // Intentional empty method
    }
    getStyleClasses() {
        // Intentional empty method
    }
    addStyleClasses() {
        // Intentional empty method
    }
    addLinkResource() {
        // Intentional empty method
    }
}
class IconTestingModule {
}
IconTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IconTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: IconTestingModule, declarations: [MockIconComponent], exports: [MockIconComponent] });
IconTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconTestingModule, providers: [
        {
            provide: IconLoaderService,
            useClass: MockIconLoaderService,
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: IconTestingModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: mockComponents,
                    exports: mockComponents,
                    providers: [
                        {
                            provide: IconLoaderService,
                            useClass: MockIconLoaderService,
                        },
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
// TODO: Improve a11y with better text appropriate to usage (example: loading cart spinner)
class SpinnerComponent {
    constructor() {
        // Intentional empty constructor
    }
}
SpinnerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SpinnerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SpinnerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: SpinnerComponent, selector: "cx-spinner", ngImport: i0, template: "<div class=\"loader-container\" role=\"status\">\n  <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n</div>\n", dependencies: [{ kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SpinnerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-spinner', template: "<div class=\"loader-container\" role=\"status\">\n  <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n</div>\n" }]
        }], ctorParameters: function () { return []; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ConsentManagementFormComponent {
    constructor() {
        this.consentGiven = false;
        this.requiredConsents = [];
        this.consentChanged = new EventEmitter();
        // Intentional empty constructor
    }
    ngOnInit() {
        if (this.consent) {
            this.consentGiven = Boolean(this.consent.consentState === ANONYMOUS_CONSENT_STATUS.GIVEN);
        }
        else {
            if (this.consentTemplate && this.consentTemplate.currentConsent) {
                if (this.consentTemplate.currentConsent.consentWithdrawnDate) {
                    this.consentGiven = false;
                }
                else if (this.consentTemplate.currentConsent.consentGivenDate) {
                    this.consentGiven = true;
                }
            }
        }
    }
    onConsentChange() {
        this.consentGiven = !this.consentGiven;
        this.consentChanged.emit({
            given: this.consentGiven,
            template: this.consentTemplate,
        });
    }
    isRequired(templateId) {
        return templateId ? this.requiredConsents.includes(templateId) : false;
    }
}
ConsentManagementFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ConsentManagementFormComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ConsentManagementFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: { consentTemplate: "consentTemplate", requiredConsents: "requiredConsents", consent: "consent" }, outputs: { consentChanged: "consentChanged" }, ngImport: i0, template: "<div class=\"form-check\">\n  <label>\n    <input\n      type=\"checkbox\"\n      class=\"form-check-input\"\n      (change)=\"onConsentChange()\"\n      [checked]=\"consentGiven\"\n      [disabled]=\"isRequired(consentTemplate?.id)\"\n    />\n    <span class=\"form-check-label cx-be-bold\">\n      {{ consentTemplate?.name }}\n    </span>\n    <br />\n    <span class=\"form-check-label\">\n      {{ consentTemplate?.description }}\n    </span>\n  </label>\n</div>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ConsentManagementFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-consent-management-form', template: "<div class=\"form-check\">\n  <label>\n    <input\n      type=\"checkbox\"\n      class=\"form-check-input\"\n      (change)=\"onConsentChange()\"\n      [checked]=\"consentGiven\"\n      [disabled]=\"isRequired(consentTemplate?.id)\"\n    />\n    <span class=\"form-check-label cx-be-bold\">\n      {{ consentTemplate?.name }}\n    </span>\n    <br />\n    <span class=\"form-check-label\">\n      {{ consentTemplate?.description }}\n    </span>\n  </label>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { consentTemplate: [{
                type: Input
            }], requiredConsents: [{
                type: Input
            }], consent: [{
                type: Input
            }], consentChanged: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AnonymousConsentDialogComponent {
    handleClick(event) {
        // Close on click outside the dialog window
        if (event.target.tagName === this.el.nativeElement.tagName) {
            this.close('Cross click');
        }
    }
    constructor(config, anonymousConsentsService, el, launchDialogService) {
        this.config = config;
        this.anonymousConsentsService = anonymousConsentsService;
        this.el = el;
        this.launchDialogService = launchDialogService;
        this.role = 'dialog';
        this.modal = true;
        this.subscriptions = new Subscription();
        this.showLegalDescription = true;
        this.iconTypes = ICON_TYPE;
        this.requiredConsents = [];
        this.focusConfig = {
            trap: true,
            block: true,
            autofocus: 'input[type="checkbox"]',
            focusOnEscape: true,
        };
        if (this.config.anonymousConsents) {
            this.showLegalDescription =
                this.config.anonymousConsents.showLegalDescriptionInDialog;
            if (this.config.anonymousConsents.requiredConsents) {
                this.requiredConsents = this.config.anonymousConsents.requiredConsents;
            }
        }
    }
    ngOnInit() {
        this.templates$ = this.anonymousConsentsService.getTemplates();
        this.consents$ = this.anonymousConsentsService.getConsents();
        this.loading$ = this.anonymousConsentsService.getLoadTemplatesLoading();
    }
    close(reason) {
        this.launchDialogService.closeDialog(reason);
    }
    rejectAll() {
        this.subscriptions.add(combineLatest([this.templates$, this.consents$])
            .pipe(take(1), distinctUntilChanged(), tap(([templates, consents]) => templates.forEach((template) => {
            const consent = this.getCorrespondingConsent(template, consents);
            if (consent &&
                this.anonymousConsentsService.isConsentGiven(consent)) {
                if (this.isRequiredConsent(template)) {
                    return;
                }
                if (template.id) {
                    this.anonymousConsentsService.withdrawConsent(template.id);
                }
            }
        })))
            .subscribe());
        this.close('rejectAll');
    }
    allowAll() {
        this.subscriptions.add(combineLatest([this.templates$, this.consents$])
            .pipe(take(1), distinctUntilChanged(), tap(([templates, consents]) => templates.forEach((template) => {
            const consent = this.getCorrespondingConsent(template, consents);
            if (consent &&
                (consent.consentState == null ||
                    this.anonymousConsentsService.isConsentWithdrawn(consent))) {
                if (this.isRequiredConsent(template)) {
                    return;
                }
                if (template.id) {
                    this.anonymousConsentsService.giveConsent(template.id);
                }
            }
        })))
            .subscribe());
        this.close('allowAll');
    }
    isRequiredConsent(template) {
        return Boolean(template.id &&
            this.config.anonymousConsents?.requiredConsents &&
            this.config.anonymousConsents.requiredConsents.includes(template.id));
    }
    onConsentChange({ given, template, }) {
        if (template.id) {
            if (given) {
                this.anonymousConsentsService.giveConsent(template.id);
            }
            else {
                this.anonymousConsentsService.withdrawConsent(template.id);
            }
        }
    }
    getCorrespondingConsent(template, consents = []) {
        for (const consent of consents) {
            if (template.id === consent.templateCode) {
                return consent;
            }
        }
        return null;
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
AnonymousConsentDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentDialogComponent, deps: [{ token: i1.AnonymousConsentsConfig }, { token: i1.AnonymousConsentsService }, { token: i0.ElementRef }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
AnonymousConsentDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: AnonymousConsentDialogComponent, selector: "cx-anonymous-consent-dialog", host: { listeners: { "click": "handleClick($event)" }, properties: { "attr.role": "this.role", "attr.aria-modal": "this.modal" } }, ngImport: i0, template: "<div\n  class=\"cx-anonymous-consent-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-dialog-content\">\n    <div *ngIf=\"loading$ | async; else dialogBody\">\n      <cx-spinner></cx-spinner>\n    </div>\n    <ng-template #dialogBody>\n      <div\n        role=\"status\"\n        [attr.aria-label]=\"'common.loaded' | cxTranslate\"\n      ></div>\n      <div class=\"cx-dialog-header\">\n        <h3>\n          {{ 'anonymousConsents.dialog.title' | cxTranslate }}\n        </h3>\n        <button\n          type=\"button\"\n          class=\"close\"\n          [attr.aria-label]=\"'common.close' | cxTranslate\"\n          (click)=\"close('Cross click')\"\n        >\n          <span aria-hidden=\"true\">\n            <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n          </span>\n        </button>\n      </div>\n      <!-- Separator -->\n      <div class=\"cx-dialog-description\" *ngIf=\"showLegalDescription\">\n        {{ 'anonymousConsents.dialog.legalDescription' | cxTranslate }}\n        <div\n          class=\"cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none\"\n        ></div>\n      </div>\n      <!-- Actions -->\n      <div class=\"cx-dialog-buttons\">\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"rejectAll()\">{{\n          'anonymousConsents.dialog.clearAll' | cxTranslate\n        }}</a>\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"allowAll()\">{{\n          'anonymousConsents.dialog.selectAll' | cxTranslate\n        }}</a>\n      </div>\n      <!-- Modal Body -->\n      <div class=\"cx-dialog-body\" *ngIf=\"templates$ | async as templates\">\n        <ng-container *ngIf=\"consents$ | async as consents\">\n          <div\n            class=\"cx-dialog-row col-sm-12 col-md-6\"\n            *ngFor=\"let template of templates\"\n          >\n            <cx-consent-management-form\n              [consentTemplate]=\"template\"\n              [requiredConsents]=\"requiredConsents\"\n              [consent]=\"getCorrespondingConsent(template, consents)\"\n              (consentChanged)=\"onConsentChange($event)\"\n            ></cx-consent-management-form>\n          </div>\n        </ng-container>\n      </div>\n    </ng-template>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "component", type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: ["consentTemplate", "requiredConsents", "consent"], outputs: ["consentChanged"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-anonymous-consent-dialog', template: "<div\n  class=\"cx-anonymous-consent-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-dialog-content\">\n    <div *ngIf=\"loading$ | async; else dialogBody\">\n      <cx-spinner></cx-spinner>\n    </div>\n    <ng-template #dialogBody>\n      <div\n        role=\"status\"\n        [attr.aria-label]=\"'common.loaded' | cxTranslate\"\n      ></div>\n      <div class=\"cx-dialog-header\">\n        <h3>\n          {{ 'anonymousConsents.dialog.title' | cxTranslate }}\n        </h3>\n        <button\n          type=\"button\"\n          class=\"close\"\n          [attr.aria-label]=\"'common.close' | cxTranslate\"\n          (click)=\"close('Cross click')\"\n        >\n          <span aria-hidden=\"true\">\n            <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n          </span>\n        </button>\n      </div>\n      <!-- Separator -->\n      <div class=\"cx-dialog-description\" *ngIf=\"showLegalDescription\">\n        {{ 'anonymousConsents.dialog.legalDescription' | cxTranslate }}\n        <div\n          class=\"cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none\"\n        ></div>\n      </div>\n      <!-- Actions -->\n      <div class=\"cx-dialog-buttons\">\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"rejectAll()\">{{\n          'anonymousConsents.dialog.clearAll' | cxTranslate\n        }}</a>\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"allowAll()\">{{\n          'anonymousConsents.dialog.selectAll' | cxTranslate\n        }}</a>\n      </div>\n      <!-- Modal Body -->\n      <div class=\"cx-dialog-body\" *ngIf=\"templates$ | async as templates\">\n        <ng-container *ngIf=\"consents$ | async as consents\">\n          <div\n            class=\"cx-dialog-row col-sm-12 col-md-6\"\n            *ngFor=\"let template of templates\"\n          >\n            <cx-consent-management-form\n              [consentTemplate]=\"template\"\n              [requiredConsents]=\"requiredConsents\"\n              [consent]=\"getCorrespondingConsent(template, consents)\"\n              (consentChanged)=\"onConsentChange($event)\"\n            ></cx-consent-management-form>\n          </div>\n        </ng-container>\n      </div>\n    </ng-template>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.AnonymousConsentsConfig }, { type: i1.AnonymousConsentsService }, { type: i0.ElementRef }, { type: LaunchDialogService }]; }, propDecorators: { role: [{
                type: HostBinding,
                args: ['attr.role']
            }], modal: [{
                type: HostBinding,
                args: ['attr.aria-modal']
            }], handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultAnonymousConsentLayoutConfig = {
    launch: {
        ANONYMOUS_CONSENT: {
            inlineRoot: true,
            component: AnonymousConsentDialogComponent,
            dialogType: DIALOG_TYPE.DIALOG,
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AnonymousConsentOpenDialogComponent {
    constructor(vcr, launchDialogService) {
        this.vcr = vcr;
        this.launchDialogService = launchDialogService;
    }
    openDialog() {
        const dialog = this.launchDialogService.openDialog("ANONYMOUS_CONSENT" /* LAUNCH_CALLER.ANONYMOUS_CONSENT */, this.openElement, this.vcr);
        if (dialog) {
            dialog.pipe(take(1)).subscribe();
        }
    }
}
AnonymousConsentOpenDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentOpenDialogComponent, deps: [{ token: i0.ViewContainerRef }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
AnonymousConsentOpenDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: AnonymousConsentOpenDialogComponent, selector: "cx-anonymous-consent-open-dialog", viewQueries: [{ propertyName: "openElement", first: true, predicate: ["open"], descendants: true }], ngImport: i0, template: "<button #open class=\"btn btn-link\" (click)=\"openDialog()\">\n  {{ 'anonymousConsents.preferences' | cxTranslate }}\n</button>\n", dependencies: [{ kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentOpenDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-anonymous-consent-open-dialog', template: "<button #open class=\"btn btn-link\" (click)=\"openDialog()\">\n  {{ 'anonymousConsents.preferences' | cxTranslate }}\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: LaunchDialogService }]; }, propDecorators: { openElement: [{
                type: ViewChild,
                args: ['open']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AnonymousConsentManagementBannerModule {
}
AnonymousConsentManagementBannerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentManagementBannerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AnonymousConsentManagementBannerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentManagementBannerModule, declarations: [AnonymousConsentManagementBannerComponent,
        AnonymousConsentOpenDialogComponent], imports: [CommonModule,
        I18nModule,
        FeaturesConfigModule,
        KeyboardFocusModule], exports: [AnonymousConsentManagementBannerComponent,
        AnonymousConsentOpenDialogComponent] });
AnonymousConsentManagementBannerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentManagementBannerModule, providers: [
        provideDefaultConfig(defaultAnonymousConsentLayoutConfig),
        provideDefaultConfig({
            cmsComponents: {
                AnonymousConsentManagementBannerComponent: {
                    component: AnonymousConsentManagementBannerComponent,
                    deferLoading: DeferLoadingStrategy.INSTANT,
                },
                AnonymousConsentOpenDialogComponent: {
                    component: AnonymousConsentOpenDialogComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        I18nModule,
        FeaturesConfigModule,
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentManagementBannerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        FeaturesConfigModule,
                        KeyboardFocusModule,
                    ],
                    providers: [
                        provideDefaultConfig(defaultAnonymousConsentLayoutConfig),
                        provideDefaultConfig({
                            cmsComponents: {
                                AnonymousConsentManagementBannerComponent: {
                                    component: AnonymousConsentManagementBannerComponent,
                                    deferLoading: DeferLoadingStrategy.INSTANT,
                                },
                                AnonymousConsentOpenDialogComponent: {
                                    component: AnonymousConsentOpenDialogComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [
                        AnonymousConsentManagementBannerComponent,
                        AnonymousConsentOpenDialogComponent,
                    ],
                    exports: [
                        AnonymousConsentManagementBannerComponent,
                        AnonymousConsentOpenDialogComponent,
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const PAGE_LAYOUT_HANDLER = new InjectionToken('PageLayoutHandler');

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The `BreakpointService` resolves the various screen sizes that are used in
 * the storefront. The screen sizes are globally configurable based on your
 * layout requirements. You can adjust the screen sizes by setting the minimum
 * and/or maximum size for a breakpoint, as well as extending the configuration
 * with new screens.
 *
 * By default, the `BreakpointService` is based on the breakpoints from the
 * Bootstrap ui library:
 * - `xs`: < 576px
 * - `sm`: 576px - 767px
 * - `md`: 768px - 991px
 * - `lg`: 992px - 1199px
 * - `xl`: >= 1200px
 */
class BreakpointService {
    constructor(winRef, layoutConfig, platform) {
        this.winRef = winRef;
        this.layoutConfig = layoutConfig;
        this.platform = platform;
        this.breakpoint$ = isPlatformBrowser(this.platform)
            ? this.winRef.resize$.pipe(map((event) => this.getBreakpoint(event.target.innerWidth)), distinctUntilChanged())
            : of(this.fallbackBreakpoint);
    }
    /**
     * Returns the breakpoints for the storefront layout.
     *
     * The breakpoints are driven by the `LayoutConfig.breakpoints` and sorted based on
     * the given screen size.
     */
    get breakpoints() {
        if (!this._breakpoints) {
            this._breakpoints = this.resolveBreakpointsFromConfig();
        }
        return this._breakpoints;
    }
    /**
     * Returns the _maximum_ size for the breakpoint, given by the `LayoutConfig.breakpoints`
     * configuration.
     */
    getSize(breakpoint) {
        return (this.getMaxSize(breakpoint) ??
            // if there's no direct max value or explicit max value
            // we must derive the max value from the previous min
            this.getMinSize(this.breakpoints?.[this.breakpoints.indexOf(breakpoint) + 1]));
    }
    /**
     * Indicates whether the current screen size is smaller than the maximum size of the
     * given breakpoint.
     *
     * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
     * window innerWidth is smaller than the configured size of `BREAKPOINT.md`.
     */
    isDown(breakpoint) {
        return this.breakpoint$.pipe(map((br) => this.breakpoints
            .slice(0, this.breakpoints.indexOf(breakpoint) + 1)
            .includes(br)));
    }
    /**
     * Indicates whether the current screen size is larger than the minimum size of the
     * given breakpoint.
     *
     * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
     * window innerWidth is larger than the configured size of `BREAKPOINT.sm`.
     */
    isUp(breakpoint) {
        return this.breakpoint$.pipe(map((br) => this.breakpoints
            .slice(this.breakpoints.indexOf(breakpoint))
            .includes(br)));
    }
    /**
     * Indicates whether the given breakpoint fits in the current screen size.
     */
    isEqual(breakpoint) {
        return this.breakpoint$.pipe(map((br) => br === breakpoint));
    }
    /**
     * Returns the fallback breakpoint in case no breakpoint can be resolved. This is
     * typically the case when we're on SSR without an actual window.
     *
     * Returns the smallest screen size (mobile first).
     */
    get fallbackBreakpoint() {
        return this.breakpoints?.[0];
    }
    /**
     * Resolves the breakpoints and sorts them according to the configured size.
     *
     * The sort order is by small to large screens.
     */
    resolveBreakpointsFromConfig() {
        const sortByScreenSize = (next, prev) => {
            const nextMinSize = this.getMinSize(next);
            const maxNext = Math.max(nextMinSize ? nextMinSize + 1 : 0, this.getMaxSize(next) || 0);
            const preMinSize = this.getMinSize(prev);
            const maxPrev = Math.max(preMinSize ? preMinSize + 1 : 0, this.getMaxSize(prev) || 0);
            return maxNext < maxPrev ? -1 : 0;
        };
        return Object.keys(this.config).sort(sortByScreenSize);
    }
    /**
     * Returns the _maximum_ size for the breakpoint, given by the
     * `LayoutConfig.breakpoints` configuration. We will try to resolve the
     * max size form the current breakpoint, but if this is not available, we
     * resolve it form the next breakpoint
     */
    getMaxSize(breakpoint) {
        const breakpointConfig = this.config[breakpoint];
        if (!breakpointConfig) {
            return null;
        }
        // we treat numbers as the max number by default
        if (typeof breakpointConfig === 'number') {
            return breakpointConfig;
        }
        else if (breakpointConfig.max) {
            return breakpointConfig.max;
        }
        else {
            return null;
        }
    }
    getMinSize(breakpoint) {
        return this.config[breakpoint]?.min ?? null;
    }
    /**
     * Returns a `BREAKPOINT` for the given window size.
     *
     * This method tries to match the closest breakpoint for the given
     * window size. We'll fallback to the `largest` size in case the window
     * is greater than the largest configurable breakpoint.
     *
     * The windowWidth should be smaller than the maximum size of any of the
     * screen sizes defined in the `LayoutConfig.breakpoints`.
     */
    getBreakpoint(windowWidth) {
        return (this.breakpoints.find((br) => {
            const size = this.getSize(br);
            return size !== null && windowWidth < size;
        }) ?? this.breakpoints?.[this.breakpoints.length - 1]);
    }
    /**
     * Helper method to return the breakpoint configuration.
     */
    get config() {
        return this.layoutConfig?.breakpoints || {};
    }
}
BreakpointService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreakpointService, deps: [{ token: i1.WindowRef }, { token: LayoutConfig }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
BreakpointService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreakpointService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreakpointService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: LayoutConfig }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageLayoutService {
    constructor(cms, config, breakpointService, unifiedInjector) {
        this.cms = cms;
        this.config = config;
        this.breakpointService = breakpointService;
        this.unifiedInjector = unifiedInjector;
        this.subscription = new Subscription();
        // Prints warn messages for missing layout configs.
        // The warnings are only printed once per config
        // to not pollute the console log.
        this.warnLogMessages = {};
        this.logSlots = {};
        this.subscription.add(this.unifiedInjector
            .getMulti(PAGE_LAYOUT_HANDLER)
            .subscribe((handlers) => (this.handlers = handlers)));
    }
    getSlots(section) {
        return combineLatest([this.page$, this.breakpointService.breakpoint$]).pipe(map(([page, breakpoint]) => {
            const pageTemplate = page.template;
            const slots = this.resolveSlots(page, section, breakpoint);
            return { slots, pageTemplate, breakpoint };
        }), switchMap(({ slots, pageTemplate, breakpoint }) => {
            let result = of(slots);
            for (const handler of this.handlers || []) {
                result = handler.handle(result, pageTemplate, section, breakpoint);
            }
            return result;
        }), distinctUntilChanged((a, b) => {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }));
    }
    /**
     * Returns an observable with the last page slot above-the-fold
     * for the given pageTemplate / breakpoint.
     *
     * The page fold is configurable in the `LayoutConfig` for each page layout.
     */
    getPageFoldSlot(pageTemplate) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => {
            if (!this.config.layoutSlots) {
                // no layout config available
                return undefined;
            }
            const pageTemplateConfig = this.config.layoutSlots[pageTemplate];
            const config = this.getResponsiveSlotConfig(pageTemplateConfig, 'pageFold', breakpoint);
            return config ? config.pageFold : undefined;
        }));
    }
    resolveSlots(page, section, breakpoint) {
        const config = this.getSlotConfig(page.template ?? '', 'slots', section, breakpoint);
        if (config && config.slots) {
            const pageSlots = page.slots ? Object.keys(page.slots) : [];
            return config.slots.filter((slot) => pageSlots.includes(slot));
        }
        else if (!section) {
            this.logMissingLayoutConfig(page);
            return page.slots ? Object.keys(page.slots) : [];
        }
        else {
            this.logMissingLayoutConfig(page, section);
            return [];
        }
    }
    get page$() {
        return this.cms.getCurrentPage().pipe(filter((page) => !!page));
    }
    get templateName$() {
        return this.page$.pipe(map((page) => page.template), filter(isNotUndefined));
    }
    /**
     * load slots from the layout configuration. The breakpoint is used
     * to load a specific configuration for the given breakpoint. If there's
     * no configuration available for the given breakpoint the default slot
     * configuration is returned.
     */
    getSlotConfig(templateUid, configAttribute, section, breakpoint) {
        if (!this.config.layoutSlots) {
            return undefined;
        }
        const pageTemplateConfig = this.config.layoutSlots[templateUid];
        if (section) {
            return this.getSlotConfigForSection(templateUid, configAttribute, section, breakpoint);
        }
        if (pageTemplateConfig) {
            return this.getResponsiveSlotConfig(pageTemplateConfig, configAttribute, breakpoint);
        }
    }
    getSlotConfigForSection(templateUid, configAttribute, section, breakpoint) {
        const pageTemplateConfig = this.config.layoutSlots?.[templateUid];
        if (!pageTemplateConfig || !section) {
            return undefined;
        }
        // if there's no section config on the page layout
        // we fall back to the global section config
        const sectionConfig = pageTemplateConfig[section]
            ? pageTemplateConfig[section]
            : this.config.layoutSlots?.[section];
        if (!sectionConfig) {
            return undefined;
        }
        const responsiveConfig = this.getResponsiveSlotConfig(sectionConfig, configAttribute, breakpoint);
        if (responsiveConfig.hasOwnProperty(configAttribute)) {
            return responsiveConfig;
        }
        else if (pageTemplateConfig[section].hasOwnProperty(configAttribute)) {
            return pageTemplateConfig[section];
        }
        else if (this.config.layoutSlots?.[section]) {
            return this.config.layoutSlots[section];
        }
    }
    /**
     * Returns a list of slots for a breakpoint specific configuration
     * If there's no specific configuration for the breakpoint,
     * the closest available configuration will be returned.
     */
    getResponsiveSlotConfig(layoutSlotConfig, configAttribute, breakpoint) {
        let slotConfig = layoutSlotConfig;
        // fallback to default slot config
        if (!layoutSlotConfig || !breakpoint) {
            return slotConfig;
        }
        // we have a config for the specific breakpoint
        if (layoutSlotConfig[breakpoint] &&
            layoutSlotConfig[breakpoint].hasOwnProperty(configAttribute)) {
            return layoutSlotConfig[breakpoint];
        }
        // find closest config
        const all = this.breakpointService.breakpoints;
        for (const br of all.slice(0, all.indexOf(breakpoint))) {
            if (layoutSlotConfig[br] &&
                layoutSlotConfig[br].hasOwnProperty(configAttribute)) {
                slotConfig = layoutSlotConfig[br];
            }
        }
        return slotConfig;
    }
    /**
     * In order to help developers, we print some detailed log information in
     * case there's no layout configuration available for the given page template
     * or section. Additionally, the slot positions are printed in the console
     * in a format that can be copied / paste to the configuration.
     */
    logMissingLayoutConfig(page, section) {
        if (!isDevMode()) {
            return;
        }
        if (page.template && !this.logSlots[page.template]) {
            // the info log is not printed in production
            // eslint-disable-next-line no-console
            console.info(`Available CMS page slots: '${(page.slots
                ? Object.keys(page.slots)
                : []).join(`','`)}'`);
            this.logSlots[page.template] = true;
        }
        const cacheKey = section || page.template;
        if (cacheKey && !this.warnLogMessages[cacheKey]) {
            console.warn(`No layout config found for ${cacheKey}, you can configure a 'LayoutConfig' to control the rendering of page slots.`);
            this.warnLogMessages[cacheKey] = true;
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
PageLayoutService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutService, deps: [{ token: i1.CmsService }, { token: LayoutConfig }, { token: BreakpointService }, { token: i1.UnifiedInjector }], target: i0.ɵɵFactoryTarget.Injectable });
PageLayoutService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsService }, { type: LayoutConfig }, { type: BreakpointService }, { type: i1.UnifiedInjector }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Service responsible for resolving cms config based feature modules.
 */
class CmsFeaturesService {
    constructor(configInitializer, featureModules) {
        this.configInitializer = configInitializer;
        this.featureModules = featureModules;
        // maps componentType to feature
        this.componentFeatureMap = new Map();
        /*
         * Contains either FeatureInstance or FeatureInstance resolver for not yet
         * resolved feature modules
         */
        this.featureInstances = new Map();
        this.initFeatureMap();
    }
    initFeatureMap() {
        this.configInitializer
            .getStable('featureModules')
            .subscribe((config) => {
            this.featureModulesConfig = config.featureModules ?? {};
            for (const [featureName, featureConfig] of Object.entries(this.featureModulesConfig)) {
                if (typeof featureConfig !== 'string' &&
                    featureConfig?.module &&
                    featureConfig?.cmsComponents?.length) {
                    for (const component of featureConfig.cmsComponents) {
                        this.componentFeatureMap.set(component, featureName);
                    }
                }
            }
        });
    }
    /**
     * Check if there is feature module configuration that covers specified
     * component type
     */
    hasFeatureFor(componentType) {
        return this.componentFeatureMap.has(componentType);
    }
    /**
     * Return full CmsComponent mapping defined in feature module
     */
    getCmsMapping(componentType) {
        const feature = this.componentFeatureMap.get(componentType);
        if (!feature) {
            return of(undefined);
        }
        return this.resolveFeatureInstance(feature).pipe(map((featureInstance) => featureInstance.componentsMappings?.[componentType]));
    }
    /**
     * Resolves feature module for provided component type
     *
     * @param componentType
     */
    getModule(componentType) {
        const feature = this.componentFeatureMap.get(componentType);
        if (!feature) {
            return undefined;
        }
        let module;
        // we are returning injectors only for already resolved features
        this.featureInstances
            .get(feature)
            ?.subscribe((featureInstance) => {
            module = featureInstance.moduleRef;
        })
            .unsubscribe();
        return module;
    }
    /**
     * Resolve feature based on feature name, if feature was not yet resolved
     *
     * It will first resolve all module dependencies if defined
     */
    resolveFeatureInstance(featureName) {
        return defer(() => {
            if (!this.featureInstances.has(featureName)) {
                this.featureInstances.set(featureName, this.featureModules.resolveFeature(featureName).pipe(map((moduleRef) => this.createFeatureInstance(moduleRef, featureName)), shareReplay()));
            }
            return this.featureInstances.get(featureName);
        });
    }
    /**
     * Create feature instance from feature's moduleRef
     */
    createFeatureInstance(moduleRef, feature) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const featureConfig = this.featureModulesConfig[feature];
        const featureInstance = {
            moduleRef,
            componentsMappings: {},
        };
        // resolve configuration for feature module
        const resolvedConfiguration = this.resolveFeatureConfiguration(moduleRef.injector);
        // extract cms components configuration from feature config
        for (const componentType of featureConfig.cmsComponents ?? []) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            featureInstance.componentsMappings[componentType] =
                resolvedConfiguration.cmsComponents?.[componentType] ?? {};
        }
        return featureInstance;
    }
    /**
     * Returns configuration provided in feature module
     */
    resolveFeatureConfiguration(featureInjector) {
        // get config chunks from feature lib
        const featureConfigChunks = featureInjector.get(ConfigChunk, [], {
            self: true,
        });
        // get default config chunks from feature lib
        const featureDefaultConfigChunks = featureInjector.get(DefaultConfigChunk, [], { self: true });
        return deepMerge({}, ...(featureDefaultConfigChunks ?? []), ...(featureConfigChunks ?? []));
    }
}
CmsFeaturesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsFeaturesService, deps: [{ token: i1.ConfigInitializerService }, { token: i1.FeatureModulesService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsFeaturesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsFeaturesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsFeaturesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ConfigInitializerService }, { type: i1.FeatureModulesService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Service with logic related to resolving component from cms mapping
 */
class CmsComponentsService {
    constructor(config, platformId, featureModules, configInitializer) {
        this.config = config;
        this.platformId = platformId;
        this.featureModules = featureModules;
        this.configInitializer = configInitializer;
        // Component mappings that were identified as missing
        this.missingComponents = [];
        // Already resolved mappings
        this.mappings = {};
        // Contains already initialized resolvers for specified component typez
        this.mappingResolvers = new Map();
        this.configInitializer
            .getStable('cmsComponents')
            .subscribe((cmsConfig) => {
            // we want to grab cms configuration available at config initialization phase
            // as lazy-loaded modules can affect global configuration resulting in
            // non-deterministic state
            this.staticCmsConfig = { ...cmsConfig.cmsComponents };
        });
    }
    /**
     * Should be called to make sure all component mappings are determined,
     * especially lazy loaded ones.
     *
     * It's recommended way to make sure all other methods of CmsComponentService
     * will be able to work synchronously for asked component types and avoid risk
     * of potential errors that could be thrown otherwise.
     */
    determineMappings(componentTypes) {
        return defer(() => {
            // we use defer, to be sure the logic below used to compose final observable
            // will be executed at subscription time (with up to date state at the time,
            // when it will be needed)
            const featureResolvers = [];
            for (const componentType of componentTypes) {
                if (!this.mappings[componentType]) {
                    const staticConfig = (this.staticCmsConfig ??
                        this.config.cmsComponents)?.[componentType];
                    // check if this component type is managed by feature module
                    if (this.featureModules.hasFeatureFor(componentType)) {
                        featureResolvers.push(
                        // we delegate populating this.mappings to feature resolver
                        this.getFeatureMappingResolver(componentType, staticConfig));
                    }
                    else {
                        // simply use only static config
                        if (staticConfig) {
                            this.mappings[componentType] = staticConfig;
                        }
                    }
                }
            }
            if (featureResolvers.length) {
                return forkJoin(featureResolvers).pipe(mapTo(componentTypes));
            }
            else {
                return of(componentTypes);
            }
        });
    }
    getFeatureMappingResolver(componentType, staticConfig) {
        if (!this.mappingResolvers.has(componentType)) {
            const mappingResolver$ = this.featureModules
                .getCmsMapping(componentType)
                .pipe(filter(isNotUndefined), tap((featureComponentMapping) => {
                // We treat cms mapping configuration from a feature as a default,
                // that can be overridden by app/static configuration
                this.mappings[componentType] = deepMerge({}, featureComponentMapping, staticConfig);
                this.mappingResolvers.delete(componentType);
            }), share());
            this.mappingResolvers.set(componentType, mappingResolver$);
        }
        return this.mappingResolvers.get(componentType);
    }
    /**
     * Returns the feature module for a cms component.
     * It will only work for cms components provided by feature modules.
     *
     * @param componentType
     */
    getModule(componentType) {
        if (this.featureModules.hasFeatureFor(componentType)) {
            return this.featureModules.getModule(componentType);
        }
    }
    /**
     * Return collection of component mapping configuration for specified list of
     * component types.
     *
     * If component mapping can't be determined synchronously, for example, lazy
     * loaded one, it will throw an error.
     *
     * To make sure component mapping is available, determineMappings()
     * should be called and completed first.
     */
    getMapping(componentType) {
        const componentConfig = this.mappings[componentType] ??
            (this.staticCmsConfig ?? this.config.cmsComponents)?.[componentType];
        if (isDevMode() && !componentConfig) {
            if (!this.missingComponents.includes(componentType)) {
                this.missingComponents.push(componentType);
                console.warn(`No component implementation found for the CMS component type '${componentType}'.\n`, `Make sure you implement a component and register it in the mapper.`);
            }
        }
        return componentConfig;
    }
    /**
     * Checks, if component should be rendered as some components
     * could be disabled for server side renderings
     */
    shouldRender(componentType) {
        const isSSR = isPlatformServer(this.platformId);
        return !(isSSR && this.getMapping(componentType)?.disableSSR);
    }
    /**
     * Return DeferLoadingStrategy for component type.
     */
    getDeferLoadingStrategy(componentType) {
        return (this.staticCmsConfig ?? this.config.cmsComponents)?.[componentType]
            ?.deferLoading;
    }
    /**
     * Get cms driven child routes for components
     */
    getChildRoutes(componentTypes) {
        const configs = [];
        for (const componentType of componentTypes) {
            if (this.shouldRender(componentType)) {
                configs.push(this.getMapping(componentType)?.childRoutes ?? []);
            }
        }
        return this.standardizeChildRoutes(configs);
    }
    /**
     * Returns the static data for the component type.
     */
    getStaticData(componentType) {
        return this.getMapping(componentType)?.data;
    }
    /**
     * Standardizes the format of `childRoutes` config.
     *
     * Some `childRoutes` configs are simple arrays of Routes (without the notion of the parent route).
     * But some configs can be an object with children routes and their parent defined in separate property.
     */
    standardizeChildRoutes(childRoutesConfigs) {
        const result = { children: [] };
        (childRoutesConfigs || []).forEach((config) => {
            if (Array.isArray(config)) {
                result.children?.push(...config);
            }
            else {
                result.children?.push(...(config.children || []));
                if (config.parent) {
                    result.parent = config.parent;
                }
            }
        });
        return result;
    }
    /**
     * Get cms driven guards for components
     */
    getGuards(componentTypes) {
        const guards = new Set();
        for (const componentType of componentTypes) {
            this.getMapping(componentType)?.guards?.forEach((guard) => guards.add(guard));
        }
        return Array.from(guards);
    }
    /**
     * Get i18n keys associated with components
     */
    getI18nKeys(componentTypes) {
        const i18nKeys = new Set();
        for (const componentType of componentTypes) {
            if (this.shouldRender(componentType)) {
                this.getMapping(componentType)?.i18nKeys?.forEach((key) => i18nKeys.add(key));
            }
        }
        return Array.from(i18nKeys);
    }
}
CmsComponentsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsComponentsService, deps: [{ token: i1.CmsConfig }, { token: PLATFORM_ID }, { token: CmsFeaturesService }, { token: i1.ConfigInitializerService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsComponentsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsComponentsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsComponentsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsConfig }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: CmsFeaturesService }, { type: i1.ConfigInitializerService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageSlotService {
    constructor(cmsComponentsService, platformId, document) {
        this.cmsComponentsService = cmsComponentsService;
        this.platformId = platformId;
        this.document = document;
        this.resolvePrerenderedSlots();
    }
    /**
     * Finds all slots visible in the SSR pre-rendered DOM
     */
    resolvePrerenderedSlots() {
        if (isPlatformBrowser(this.platformId)) {
            this.prerenderedSlots = Array.from(this.document.querySelectorAll('cx-page-slot'))
                .filter((el) => el.getBoundingClientRect().top <
                this.document.documentElement.clientHeight)
                .map((el) => el.getAttribute('position'));
        }
    }
    /**
     * Indicates if certain slot should be rendered instantly.
     *
     * It's especially useful when transitioning from SSR to CSR application,
     * where we don't want to apply deferring logic to slots that are visible
     * to avoid unnecessary flickering.
     */
    shouldNotDefer(slot) {
        if (this.prerenderedSlots?.includes(slot)) {
            this.prerenderedSlots.splice(this.prerenderedSlots.indexOf(slot), 1);
            return true;
        }
        return false;
    }
    /**
     * Returns the defer options for the given component. If the wrapping
     * page slot is prerendered, we would ignore the defer options altogether.
     */
    getComponentDeferOptions(slot, componentType) {
        if (slot && this.shouldNotDefer(slot)) {
            return { deferLoading: DeferLoadingStrategy.INSTANT };
        }
        const deferLoading = this.cmsComponentsService.getDeferLoadingStrategy(componentType);
        return { deferLoading };
    }
}
PageSlotService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageSlotService, deps: [{ token: CmsComponentsService }, { token: PLATFORM_ID }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });
PageSlotService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageSlotService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageSlotService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Lifecycle events for the creation and removal of CMS components.
 *
 * Triggers when the component is added or removed from the DOM, using
 * sub event `ComponentCreateEvent` and `ComponentDestroyEvent`.
 */
class ComponentEvent extends CxEvent {
}
/**
 * Indicates that the component is added to the DOM.
 */
class ComponentCreateEvent extends ComponentEvent {
}
/**
 * Event's type
 */
ComponentCreateEvent.type = 'ComponentCreate';
/**
 * Indicates that the component is removed from the DOM.
 */
class ComponentDestroyEvent extends ComponentEvent {
}
/**
 * Event's type
 */
ComponentDestroyEvent.type = 'ComponentDestroy';

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * ComponentHandler implementations can be used for instantiating and launching
 * different types of CMS mapped components
 */
class ComponentHandler {
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Responsible for obtaining component handler for specified component mapping
 */
class ComponentHandlerService {
    constructor(handlers) {
        this.handlers = handlers;
        this.invalidMappings = new Set();
    }
    /**
     * Get best matching component handler
     *
     * @param componentMapping
     */
    resolve(componentMapping) {
        const handler = resolveApplicable(this.handlers, [componentMapping]);
        if (isDevMode() && !handler) {
            if (!this.invalidMappings.has(componentMapping)) {
                this.invalidMappings.add(componentMapping);
                console.warn("Can't resolve handler for component mapping: ", componentMapping);
            }
        }
        return handler;
    }
    /**
     * Get launcher for specified component mapping
     *
     * @param componentMapping
     * @param viewContainerRef
     * @param elementInjector
     */
    getLauncher(componentMapping, viewContainerRef, elementInjector, module) {
        return this.resolve(componentMapping)?.launcher(componentMapping, viewContainerRef, elementInjector, module);
    }
}
ComponentHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ComponentHandlerService, deps: [{ token: ComponentHandler, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
ComponentHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ComponentHandlerService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ComponentHandlerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ComponentHandler]
                }] }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CmsComponentData {
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Provides data for `CmsComponentData`. This is used while component is injected
 * dynamically, so that the component implementation can access the data.
 *
 * The data is resolved from dynamic data (CMS api) as well as static configured data.
 */
class ComponentDataProvider {
    constructor(componentsService, cmsService) {
        this.componentsService = componentsService;
        this.cmsService = cmsService;
    }
    /**
     * Return the component data for a component given by the `uid`.
     *
     * If the `type` is provided, static component data (if available) is
     * merged into the component data. The static data is complemented and
     * overridden with data retrieved from the cms service.
     */
    get(uid, type) {
        return defer(() => {
            let staticComponentData;
            if (type) {
                staticComponentData = this.componentsService.getStaticData(type);
            }
            if (uid) {
                if (staticComponentData) {
                    return this.cmsService.getComponentData(uid).pipe(map((data) => ({
                        ...staticComponentData,
                        ...data,
                    })), startWith(staticComponentData));
                }
                else {
                    return this.cmsService.getComponentData(uid);
                }
            }
            else {
                return staticComponentData ? of(staticComponentData) : EMPTY;
            }
        });
    }
}
ComponentDataProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ComponentDataProvider, deps: [{ token: CmsComponentsService }, { token: i1.CmsService }], target: i0.ɵɵFactoryTarget.Injectable });
ComponentDataProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ComponentDataProvider, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ComponentDataProvider, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i1.CmsService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Used to prepare injector for CMS components.
 *
 * Injector will take into account configured providers and provides CmsComponentData
 * for specified component's uid
 */
class CmsInjectorService {
    constructor(cmsComponentsService, injector) {
        this.cmsComponentsService = cmsComponentsService;
        this.injector = injector;
    }
    getInjector(type, uid, parentInjector) {
        const configProviders = this.cmsComponentsService.getMapping(type)?.providers ?? [];
        return Injector.create({
            providers: [
                {
                    provide: CmsComponentData,
                    useFactory: (dataProvider) => ({
                        uid,
                        data$: dataProvider.get(uid, type),
                    }),
                    deps: [ComponentDataProvider],
                },
                ...configProviders,
            ],
            parent: parentInjector ?? this.injector,
        });
    }
}
CmsInjectorService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsInjectorService, deps: [{ token: CmsComponentsService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
CmsInjectorService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsInjectorService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsInjectorService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i0.Injector }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive used to facilitate instantiation of CMS driven dynamic components
 */
class ComponentWrapperDirective {
    constructor(vcr, cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector, eventService) {
        this.vcr = vcr;
        this.cmsComponentsService = cmsComponentsService;
        this.injector = injector;
        this.dynamicAttributeService = dynamicAttributeService;
        this.renderer = renderer;
        this.componentHandler = componentHandler;
        this.cmsInjector = cmsInjector;
        this.eventService = eventService;
        this.cxComponentRef = new EventEmitter();
    }
    ngOnInit() {
        this.cmsComponentsService
            .determineMappings([this.cxComponentWrapper.flexType ?? ''])
            .subscribe(() => {
            if (this.cmsComponentsService.shouldRender(this.cxComponentWrapper.flexType ?? '')) {
                this.launchComponent();
            }
        });
    }
    launchComponent() {
        const componentMapping = this.cmsComponentsService.getMapping(this.cxComponentWrapper.flexType ?? '');
        if (!componentMapping) {
            return;
        }
        this.launcherResource = this.componentHandler
            .getLauncher(componentMapping, this.vcr, this.cmsInjector.getInjector(this.cxComponentWrapper.flexType ?? '', this.cxComponentWrapper.uid ?? '', this.injector), this.cmsComponentsService.getModule(this.cxComponentWrapper.flexType ?? ''))
            ?.pipe(filter(isNotUndefined), tap(({ elementRef, componentRef }) => {
            this.cmpRef = componentRef;
            this.cxComponentRef.emit(componentRef);
            this.dispatchEvent(ComponentCreateEvent, elementRef);
            this.decorate(elementRef);
            this.injector.get(ChangeDetectorRef).markForCheck();
        }), finalize(() => this.dispatchEvent(ComponentDestroyEvent)))
            .subscribe();
    }
    /**
     * Dispatch the component event.
     *
     * The event is dispatched during creation and removal of the component.
     */
    dispatchEvent(event, elementRef) {
        const payload = {
            typeCode: this.cxComponentWrapper.typeCode,
            id: this.cxComponentWrapper.uid,
        };
        if (event === ComponentCreateEvent) {
            payload.host = elementRef?.nativeElement;
        }
        this.eventService.dispatch(payload, event);
    }
    decorate(elementRef) {
        this.dynamicAttributeService.addAttributesToComponent(elementRef.nativeElement, this.renderer, this.cxComponentWrapper);
    }
    ngOnDestroy() {
        if (this.launcherResource) {
            this.launcherResource.unsubscribe();
        }
    }
}
ComponentWrapperDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ComponentWrapperDirective, deps: [{ token: i0.ViewContainerRef }, { token: CmsComponentsService }, { token: i0.Injector }, { token: i1.DynamicAttributeService }, { token: i0.Renderer2 }, { token: ComponentHandlerService }, { token: CmsInjectorService }, { token: i1.EventService }], target: i0.ɵɵFactoryTarget.Directive });
ComponentWrapperDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: { cxComponentWrapper: "cxComponentWrapper" }, outputs: { cxComponentRef: "cxComponentRef" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ComponentWrapperDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxComponentWrapper]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: CmsComponentsService }, { type: i0.Injector }, { type: i1.DynamicAttributeService }, { type: i0.Renderer2 }, { type: ComponentHandlerService }, { type: CmsInjectorService }, { type: i1.EventService }]; }, propDecorators: { cxComponentWrapper: [{
                type: Input
            }], cxComponentRef: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The `PageSlotComponent` is used to render the CMS page slot and it's components.
 *
 * The Page slot host element will be supplemented with css classes so that the layout
 * can be fully controlled by customers:
 * - The page slot _position_ is added as a css class by default.
 * - The `cx-pending` is added for as long as the slot hasn't start loading.
 * - The `page-fold` style class is added for the page slot which is configured as the page fold.
 */
class PageSlotComponent {
    /**
     * The position represents the unique key for a page slot on a single page, but can
     * be reused cross pages.
     *
     * The position is used to find the CMS components for the page slot. It is also
     * added as an additional CSS class so that layout can be applied.
     */
    set position(value) {
        this.position$.next(value);
    }
    get position() {
        return this.position$.value;
    }
    constructor(cmsService, dynamicAttributeService, renderer, elementRef, cd, pageSlotService) {
        this.cmsService = cmsService;
        this.dynamicAttributeService = dynamicAttributeService;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.cd = cd;
        this.pageSlotService = pageSlotService;
        /**
         * Indicates that the page slot is the last page slot above the fold.
         */
        this.isPageFold = false;
        /**
         * Indicates that the components of the page slot haven't been loaded as long
         * as the isPending state is true.
         */
        this.isPending = true;
        /**
         * Indicates that the page slot doesn't contain any components. This is no
         * longer used in spartacus, but kept for backwards compatibility.
         */
        this.hasComponents = false;
        this.position$ = new BehaviorSubject(undefined);
        this.slot$ = this.position$.pipe(filter(isNotUndefined), switchMap((position) => this.cmsService.getContentSlot(position)), distinctUntilChanged(this.isDistinct));
        /** Observes the components for the given page slot. */
        this.components$ = this.slot$.pipe(map((slot) => slot?.components ?? []));
        this.subscription = new Subscription();
        /** Keeps track of the pending components that must be loaded for the page slot */
        this.pendingComponentCount = 0;
    }
    ngOnInit() {
        this.subscription.add(this.slot$.pipe(tap((slot) => this.decorate(slot))).subscribe((value) => {
            this.components = value?.components || [];
            this.cd.markForCheck();
        }));
    }
    decorate(slot) {
        let cls = this.class || '';
        if (this.lastPosition && cls.indexOf(this.lastPosition) > -1) {
            cls = cls.replace(this.lastPosition, '');
        }
        if (this.position$.value) {
            cls += ` ${this.position$.value}`;
            this.lastPosition = this.position$.value;
        }
        // host bindings
        this.pending = slot?.components?.length || 0;
        this.hasComponents = slot?.components
            ? slot?.components?.length > 0
            : false;
        if (cls && cls !== this.class) {
            this.class = cls;
        }
        if (slot) {
            this.dynamicAttributeService.addAttributesToSlot(this.elementRef.nativeElement, this.renderer, slot);
        }
    }
    /**
     * Sets the pending count for the page slot components. Once all pending components are
     * loaded, the `isPending` flag is updated, so that the associated class can be updated
     */
    set pending(count) {
        this.pendingComponentCount = count;
        this.isPending = this.pendingComponentCount > 0;
    }
    get pending() {
        return this.pendingComponentCount;
    }
    /*
     * Is triggered when a component is added to the view. This is used to
     * update the pending count
     */
    isLoaded(loadState) {
        if (loadState) {
            this.pending--;
            this.cd.markForCheck();
        }
    }
    /**
     * The `DeferLoadingStrategy` indicates whether the component should be
     * rendered instantly or whether it should be deferred.
     */
    getComponentDeferOptions(componentType) {
        return this.pageSlotService.getComponentDeferOptions(this.position, componentType);
    }
    isDistinct(old, current) {
        return Boolean(current.components &&
            old.components &&
            old.components.length === current.components.length &&
            !old.components.find((el, index) => el.uid !== current.components?.[index].uid));
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
    }
}
PageSlotComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageSlotComponent, deps: [{ token: i1.CmsService }, { token: i1.DynamicAttributeService }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: PageSlotService }], target: i0.ɵɵFactoryTarget.Component });
PageSlotComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: { position: "position", class: "class", isPageFold: "isPageFold", hasComponents: "hasComponents" }, host: { properties: { "attr.position": "this.position", "class": "this.class", "class.page-fold": "this.isPageFold", "class.cx-pending": "this.isPending", "class.has-components": "this.hasComponents" } }, ngImport: i0, template: "<ng-template\n  *ngIf=\"position\"\n  [cxOutlet]=\"position\"\n  [cxOutletContext]=\"{ components$: components$ }\"\n>\n  <ng-container *ngFor=\"let component of components\">\n    <ng-template\n      *ngIf=\"component.flexType\"\n      [cxOutlet]=\"component.flexType\"\n      [cxOutletContext]=\"{ component: component }\"\n      [cxOutletDefer]=\"getComponentDeferOptions(component.flexType)\"\n      (loaded)=\"isLoaded($event)\"\n    >\n      <ng-container [cxComponentWrapper]=\"component\"></ng-container>\n    </ng-template>\n  </ng-container>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }, { kind: "directive", type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageSlotComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-page-slot,[cx-page-slot]', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-template\n  *ngIf=\"position\"\n  [cxOutlet]=\"position\"\n  [cxOutletContext]=\"{ components$: components$ }\"\n>\n  <ng-container *ngFor=\"let component of components\">\n    <ng-template\n      *ngIf=\"component.flexType\"\n      [cxOutlet]=\"component.flexType\"\n      [cxOutletContext]=\"{ component: component }\"\n      [cxOutletDefer]=\"getComponentDeferOptions(component.flexType)\"\n      (loaded)=\"isLoaded($event)\"\n    >\n      <ng-container [cxComponentWrapper]=\"component\"></ng-container>\n    </ng-template>\n  </ng-container>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1.CmsService }, { type: i1.DynamicAttributeService }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: PageSlotService }]; }, propDecorators: { position: [{
                type: HostBinding,
                args: ['attr.position']
            }, {
                type: Input
            }], class: [{
                type: Input
            }, {
                type: HostBinding
            }], isPageFold: [{
                type: HostBinding,
                args: ['class.page-fold']
            }, {
                type: Input
            }], isPending: [{
                type: HostBinding,
                args: ['class.cx-pending']
            }], hasComponents: [{
                type: HostBinding,
                args: ['class.has-components']
            }, {
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive that Adds a style class to the host element based on the cms page
 * template. The CMS page template is driven by the CMS structure, which is configurable
 * in the backend.
 *
 * The style class is added to the host element of the directive. The host element is resolved
 * from the `elementRef`, or, in case the directive is used in an `ng-template`, by the
 * `TemplateRef`.
 *
 * An example of the usage is given below:
 *
 * ```html
 * <cx-storefront class="LandingPageTemplate">
 *   <ng-template cxPageTemplateStyle>...</ng-template>
 * <cx-storefront>
 * ```
 *
 * The style class can also be provided by an input:
 *
 * ```html
 * <ng-template [cxPageTemplateStyle]="pageTemplateName">
 * ```
 *
 */
class PageTemplateDirective {
    /**
     * Adds a style class to the host element based on the cms page template, unless
     * the class is given as an input.
     *
     * The host element is either the actual host, or the parent element in case this
     * is used inside an `ng-template`.
     */
    set setTemplate(template) {
        if (template && template !== '') {
            this.useTemplateFromInput = true;
            this.addStyleClass(template);
        }
        else if (this.useTemplateFromInput) {
            // we only clear the template if it has been provided by the input before
            this.clear();
        }
    }
    constructor(pageLayoutService, elementRef, templateRef, cd) {
        this.pageLayoutService = pageLayoutService;
        this.elementRef = elementRef;
        this.templateRef = templateRef;
        this.cd = cd;
        // Maintains the page template subscription
        this.subscription = new Subscription();
    }
    ngOnInit() {
        if (!this.useTemplateFromInput) {
            this.subscription.add(this.pageLayoutService.templateName$.subscribe((template) => this.addStyleClass(template)));
        }
    }
    /**
     * Adds the page template as a style class to the given element. If any
     * page template was added before, we clean it up.
     *
     * We'll not use hostBinding for the style class, as it will potential drop
     * an existing class name on the host. This is why we need to work with
     * the lower level change detection api.
     */
    addStyleClass(template, el) {
        this.clear(el);
        if (template) {
            this.currentTemplate = template;
            (el ?? this.host).classList.add(this.currentTemplate);
            this.cd.markForCheck();
        }
    }
    /**
     * Cleans up the class host binding, if a template class was assigned before.
     */
    clear(el) {
        if (this.currentTemplate) {
            (el ?? this.host).classList?.remove(this.currentTemplate);
            this.cd.markForCheck();
        }
    }
    /**
     * Returns the host element (`HTMLElement`).
     *
     * If the directive is used on an `ng-template`, we take the parent element,
     * to ensure that we're not ending up with a comment.
     */
    get host() {
        return !!this.templateRef
            ? this.templateRef.elementRef.nativeElement.parentElement
            : this.elementRef.nativeElement;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
PageTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageTemplateDirective, deps: [{ token: PageLayoutService }, { token: i0.ElementRef }, { token: i0.TemplateRef, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
PageTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: { setTemplate: ["cxPageTemplateStyle", "setTemplate"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxPageTemplateStyle]',
                }]
        }], ctorParameters: function () { return [{ type: PageLayoutService }, { type: i0.ElementRef }, { type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { setTemplate: [{
                type: Input,
                args: ['cxPageTemplateStyle']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageLayoutComponent {
    set section(value) {
        this.section$.next(value);
    }
    constructor(pageLayoutService) {
        this.pageLayoutService = pageLayoutService;
        this.section$ = new BehaviorSubject(undefined);
        this.templateName$ = this.pageLayoutService.templateName$;
        this.layoutName$ = this.section$.pipe(switchMap((section) => (section ? of(section) : this.templateName$)));
        this.slots$ = this.section$.pipe(switchMap((section) => this.pageLayoutService.getSlots(section)));
        this.pageFoldSlot$ = this.templateName$.pipe(switchMap((templateName) => this.pageLayoutService.getPageFoldSlot(templateName)), distinctUntilChanged());
    }
}
PageLayoutComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutComponent, deps: [{ token: PageLayoutService }], target: i0.ɵɵFactoryTarget.Component });
PageLayoutComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PageLayoutComponent, selector: "cx-page-layout", inputs: { section: "section" }, ngImport: i0, template: "<ng-template\n  *ngIf=\"layoutName$ | async as layoutName\"\n  [cxPageTemplateStyle]=\"layoutName\"\n  [cxOutlet]=\"layoutName\"\n  [cxOutletContext]=\"{\n    templateName$: templateName$,\n    slots$: slots$,\n    section$: section$\n  }\"\n>\n  <ng-content></ng-content>\n\n  <cx-page-slot\n    *ngFor=\"let slot of slots$ | async\"\n    [position]=\"slot\"\n    [isPageFold]=\"slot === (pageFoldSlot$ | async)\"\n  ></cx-page-slot>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }, { kind: "component", type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: ["position", "class", "isPageFold", "hasComponents"] }, { kind: "directive", type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: ["cxPageTemplateStyle"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-page-layout', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-template\n  *ngIf=\"layoutName$ | async as layoutName\"\n  [cxPageTemplateStyle]=\"layoutName\"\n  [cxOutlet]=\"layoutName\"\n  [cxOutletContext]=\"{\n    templateName$: templateName$,\n    slots$: slots$,\n    section$: section$\n  }\"\n>\n  <ng-content></ng-content>\n\n  <cx-page-slot\n    *ngFor=\"let slot of slots$ | async\"\n    [position]=\"slot\"\n    [isPageFold]=\"slot === (pageFoldSlot$ | async)\"\n  ></cx-page-slot>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: PageLayoutService }]; }, propDecorators: { section: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CmsGuardsService {
    constructor(cmsComponentsService, 
    // TODO:#checkout - handle breaking changes in schematics
    unifiedInjector) {
        this.cmsComponentsService = cmsComponentsService;
        this.unifiedInjector = unifiedInjector;
    }
    cmsPageCanActivate(componentTypes, route, state) {
        const guards = this.cmsComponentsService.getGuards(componentTypes);
        if (guards.length) {
            const canActivateObservables = guards.map((guard) => this.canActivateGuard(guard, route, state));
            return concat(...canActivateObservables).pipe(skipWhile((canActivate) => canActivate === true), endWith(true), first());
        }
        else {
            return of(true);
        }
    }
    canActivateGuard(guardClass, route, state) {
        const guard = getLastValueSync(this.unifiedInjector.get(guardClass));
        if (isCanActivate(guard)) {
            return wrapIntoObservable(guard.canActivate(route, state)).pipe(first());
        }
        else {
            throw new Error('Invalid CanActivate guard in cmsMapping');
        }
    }
}
CmsGuardsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsGuardsService, deps: [{ token: CmsComponentsService }, { token: i1.UnifiedInjector }], target: i0.ɵɵFactoryTarget.Injectable });
CmsGuardsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsGuardsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsGuardsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i1.UnifiedInjector }]; } });
function wrapIntoObservable(value) {
    if (isObservable(value)) {
        return value;
    }
    if (isPromise(value)) {
        return from(Promise.resolve(value));
    }
    return of(value);
}
function isPromise(obj) {
    return !!obj && typeof obj.then === 'function';
}
function isCanActivate(guard) {
    return guard && isFunction(guard.canActivate);
}
function isFunction(v) {
    return typeof v === 'function';
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
// This service should be exposed in public API only after the refactor planned in https://github.com/SAP/spartacus/issues/7070
class CmsRoutesImplService {
    constructor(router, cmsComponentsService, cmsGuardsService) {
        this.router = router;
        this.cmsComponentsService = cmsComponentsService;
        this.cmsGuardsService = cmsGuardsService;
    }
    cmsRouteExists(url) {
        const isCmsDrivenRoute = url.startsWith('/');
        if (!isCmsDrivenRoute) {
            return false;
        }
        const routePath = url.substr(1);
        return (isCmsDrivenRoute &&
            !!this.router.config.find((route) => route.data && route.data.cxCmsRouteContext && route.path === routePath));
    }
    /**
     * Contains Cms driven routing logic intended for use use in guards, especially in canActivate method.
     *
     * Will return true, when logic wont have to modify routing (so canActivate could be easily resolved to true)
     * or will return false, when routing configuration was updated and redirection to newly generated route was initiated.
     *
     * @param pageContext
     * @param currentUrl
     */
    handleCmsRoutesInGuard(pageContext, componentTypes, currentUrl, currentPageLabel) {
        if (this.cmsRouteExists(currentPageLabel)) {
            return true;
        }
        const childRoutesConfig = this.cmsComponentsService.getChildRoutes(componentTypes);
        if (childRoutesConfig?.children?.length) {
            if (this.updateRouting(pageContext, currentPageLabel, childRoutesConfig)) {
                this.router.navigateByUrl(currentUrl);
                return false;
            }
        }
        return true;
    }
    updateRouting(pageContext, pageLabel, childRoutesConfig) {
        if (pageContext.type === PageType.CONTENT_PAGE &&
            pageLabel.startsWith('/') &&
            pageLabel.length > 1) {
            const children = this.wrapCmsGuardsRecursively(childRoutesConfig.children ?? []);
            const newRoute = {
                path: pageLabel.substr(1),
                component: PageLayoutComponent,
                children: children,
                data: deepMerge({}, childRoutesConfig?.parent?.data ?? {}, {
                    cxCmsRouteContext: {
                        type: pageContext.type,
                        id: pageLabel,
                    },
                }),
            };
            this.router.resetConfig([newRoute, ...this.router.config]);
            return true;
        }
        return false;
    }
    /**
     * Traverses recursively the given Routes and wraps each `canActivate`
     * guard of each Route with a special `CanActivateFn` function.
     *
     * This special wrapper function allows for resolving
     * those guards by the Angular Router using the `UnifiedInjector`
     * instead of only root injector.
     *
     * This allows Angular Router to inject the guards (and their dependencies)
     * even when they are provided only in a child injector of a lazy-loaded module.
     */
    wrapCmsGuardsRecursively(routes) {
        return routes.map((route) => {
            if (route.children) {
                route.children = this.wrapCmsGuardsRecursively(route.children);
            }
            if (route?.canActivate?.length) {
                route.canActivate = route.canActivate.map((guard) => this.wrapCmsGuard(guard));
            }
            return route;
        });
    }
    /**
     * Returns a wrapper function `CanActivateFn` (https://angular.io/api/router/CanActivateFn)
     * that injects the given guard instance and runs its method `.canActivate()`.
     *
     * It allows to inject the guard's instance (and it's dependencies)
     * even if it's 'provided only in a child injector of a lazy-loaded module.
     */
    wrapCmsGuard(guardClass) {
        return (route, state) => {
            return this.cmsGuardsService.canActivateGuard(guardClass, route, state);
        };
    }
}
CmsRoutesImplService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRoutesImplService, deps: [{ token: i1$2.Router }, { token: CmsComponentsService }, { token: CmsGuardsService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsRoutesImplService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRoutesImplService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRoutesImplService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1$2.Router }, { type: CmsComponentsService }, { type: CmsGuardsService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
// Public injection token for the private implementation of the service `CmsRoutesImplService`.
// After #7070, this class should be replaced with a real implementation.
class CmsRoutesService {
}
CmsRoutesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRoutesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CmsRoutesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRoutesService, providedIn: 'root', useExisting: CmsRoutesImplService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRoutesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: CmsRoutesImplService,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CmsI18nService {
    constructor(cmsComponentsService, translation, translationChunk) {
        this.cmsComponentsService = cmsComponentsService;
        this.translation = translation;
        this.translationChunk = translationChunk;
    }
    loadForComponents(componentTypes) {
        const i18nKeys = this.cmsComponentsService.getI18nKeys(componentTypes);
        const i18nChunks = new Set();
        for (const key of i18nKeys) {
            i18nChunks.add(this.translationChunk.getChunkNameForKey(key));
        }
        this.translation.loadChunks(Array.from(i18nChunks));
    }
}
CmsI18nService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsI18nService, deps: [{ token: CmsComponentsService }, { token: i1.TranslationService }, { token: i1.TranslationChunkService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsI18nService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsI18nService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsI18nService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentsService }, { type: i1.TranslationService }, { type: i1.TranslationChunkService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Helper service for `CmsPageGuard`
 */
class CmsPageGuardService {
    constructor(semanticPathService, cmsService, cmsRoutes, cmsI18n, cmsGuards, cmsComponentsService, routing) {
        this.semanticPathService = semanticPathService;
        this.cmsService = cmsService;
        this.cmsRoutes = cmsRoutes;
        this.cmsI18n = cmsI18n;
        this.cmsGuards = cmsGuards;
        this.cmsComponentsService = cmsComponentsService;
        this.routing = routing;
    }
    /**
     * Takes CMS components types in the current CMS page, triggers (configurable) side effects and returns a boolean - whether the route can be activated.
     *
     * Based on `cmsComponents` config for the components in the page:
     * - Evaluates components' guards; if one of them emits false or UrlTree - the route cannot be activated or redirects to the given UrlTree, respectively.
     * - If all components' guards emitted true, then the route can be activated
     * - Then we trigger loading of configured i18n chunks in parallel
     * - And we register the configured children routes of cms components
     *
     * @param pageContext current cms page context
     * @param pageData cms page data
     * @param route activated route snapshot
     * @param state router state snapshot
     *
     * @returns boolean observable - whether the route can be activated
     */
    canActivatePage(pageContext, pageData, route, state) {
        return this.cmsService.getPageComponentTypes(pageContext).pipe(map((componentTypes) => pageContext.id === SMART_EDIT_CONTEXT
            ? [SMART_EDIT_DUMMY_COMPONENT_TYPE, ...componentTypes]
            : componentTypes), take(1), switchMap((componentTypes) => this.cmsComponentsService.determineMappings(componentTypes)), switchMap((componentTypes) => this.cmsGuards
            .cmsPageCanActivate(componentTypes, route, state)
            .pipe(withLatestFrom(of(componentTypes)))), tap(([canActivate, componentTypes]) => {
            if (canActivate === true) {
                this.cmsI18n.loadForComponents(componentTypes);
            }
        }), map(([canActivate, componentTypes]) => {
            const pageLabel = pageData.label || pageContext.id; // for content pages the page label returned from backend can be different than ID initially assumed from route
            if (canActivate === true && !route?.data?.cxCmsRouteContext) {
                return this.cmsRoutes.handleCmsRoutesInGuard(pageContext, componentTypes, state.url, pageLabel);
            }
            return canActivate;
        }));
    }
    /**
     * Activates the "NOT FOUND" cms page.
     *
     * It loads cms page data for the "NOT FOUND" page and puts it in the state of the the requested page label.
     * Then it processes its CMS components with the method `canActivatePage()` of this service. For more, see its docs.
     */
    canActivateNotFoundPage(pageContext, route, state) {
        const notFoundLabel = this.semanticPathService.get('notFound');
        if (!notFoundLabel) {
            return of(false);
        }
        const notFoundCmsPageContext = {
            type: PageType.CONTENT_PAGE,
            id: notFoundLabel,
        };
        return this.cmsService.getPage(notFoundCmsPageContext).pipe(switchMap((notFoundPage) => {
            if (notFoundPage) {
                return this.cmsService.getPageIndex(notFoundCmsPageContext).pipe(tap((notFoundIndex) => {
                    this.cmsService.setPageFailIndex(pageContext, notFoundIndex);
                    this.routing.changeNextPageContext(notFoundCmsPageContext);
                }), switchMap((notFoundIndex) => this.cmsService.getPageIndex(pageContext).pipe(
                // we have to wait for page index update
                filter((index) => index === notFoundIndex))), switchMap(() => this.canActivatePage(pageContext, notFoundPage, route, state)));
            }
            return of(false);
        }));
    }
}
CmsPageGuardService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsPageGuardService, deps: [{ token: i1.SemanticPathService }, { token: i1.CmsService }, { token: CmsRoutesService }, { token: CmsI18nService }, { token: CmsGuardsService }, { token: CmsComponentsService }, { token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsPageGuardService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsPageGuardService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsPageGuardService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.SemanticPathService }, { type: i1.CmsService }, { type: CmsRoutesService }, { type: CmsI18nService }, { type: CmsGuardsService }, { type: CmsComponentsService }, { type: i1.RoutingService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CmsPageGuard {
    constructor(routingService, cmsService, protectedRoutesGuard, service, routingConfig) {
        this.routingService = routingService;
        this.cmsService = cmsService;
        this.protectedRoutesGuard = protectedRoutesGuard;
        this.service = service;
        this.routingConfig = routingConfig;
    }
    /**
     * Tries to load the CMS page data for the anticipated route and returns:
     * - `true` - if it can be activated
     * - `false` - if it cannot be activated
     * - `UrlTree` - if user should be redirected to a given `UrlTree`
     *
     * If the route can be activated, it fires additional calculations on the CMS components present on this CMS page,
     * based on their configuration (`cmsComponents` config).
     *
     * For more, see docs of the `CmsPageGuardService.canActivatePage`.
     */
    canActivate(route, state) {
        return this.protectedRoutesGuard.canActivate(route).pipe(switchMap((canActivate) => canActivate === true
            ? this.routingService.getNextPageContext().pipe(filter(isNotUndefined), take(1), switchMap((pageContext) => this.cmsService.getPage(pageContext, this.shouldReload()).pipe(first(), switchMap((pageData) => pageData
                ? this.service.canActivatePage(pageContext, pageData, route, state)
                : this.service.canActivateNotFoundPage(pageContext, route, state)))))
            : of(canActivate)));
    }
    /**
     * Returns whether we should reload the CMS page data, even when it was loaded before.
     */
    shouldReload() {
        return this.routingConfig.getLoadStrategy() !== "once" /* RouteLoadStrategy.ONCE */;
    }
}
CmsPageGuard.guardName = 'CmsPageGuard';
CmsPageGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsPageGuard, deps: [{ token: i1.RoutingService }, { token: i1.CmsService }, { token: i1.ProtectedRoutesGuard }, { token: CmsPageGuardService }, { token: i1.RoutingConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
CmsPageGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsPageGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsPageGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.CmsService }, { type: i1.ProtectedRoutesGuard }, { type: CmsPageGuardService }, { type: i1.RoutingConfigService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Default component handler used for dynamically launching cms components implemented
 * as native Angular components.
 */
class DefaultComponentHandler {
    hasMatch(componentMapping) {
        return typeof componentMapping.component === 'function';
    }
    getPriority() {
        return -50 /* Priority.FALLBACK */;
    }
    launcher(componentMapping, viewContainerRef, elementInjector, module) {
        return new Observable((subscriber) => {
            let componentRef;
            const injector = elementInjector ?? viewContainerRef.injector;
            const dispose = () => {
                if (componentRef) {
                    componentRef.destroy();
                }
            };
            const factory = this.getComponentFactory(injector, componentMapping.component);
            if (factory) {
                componentRef = viewContainerRef.createComponent(factory, undefined, injector, undefined, module);
                subscriber.next({ elementRef: componentRef.location, componentRef });
            }
            return dispose;
        });
    }
    getComponentFactory(injector, component) {
        if (!component) {
            return null;
        }
        const factory = injector
            .get(ComponentFactoryResolver)
            .resolveComponentFactory(component);
        return factory;
    }
}
DefaultComponentHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DefaultComponentHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DefaultComponentHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DefaultComponentHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DefaultComponentHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Lazy component handler used for launching lazy loaded cms components implemented
 * as native Angular components.
 */
class LazyComponentHandler {
    constructor(defaultHandler) {
        this.defaultHandler = defaultHandler;
    }
    /**
     * We want to mach dynamic import signature () => import('')
     */
    hasMatch(componentMapping) {
        return (typeof componentMapping.component === 'function' &&
            this.isNotClass(componentMapping.component));
    }
    isNotClass(symbol) {
        const signature = symbol.toString().substr(0, 20).replace(' ', '');
        return signature.startsWith('function()') || signature.startsWith('()=>');
    }
    getPriority() {
        return -10 /* Priority.LOW */;
    }
    launcher(componentMapping, viewContainerRef, elementInjector, module) {
        return from(componentMapping.component()).pipe(switchMap((component) => this.defaultHandler.launcher({ ...componentMapping, component }, viewContainerRef, elementInjector, module)));
    }
}
LazyComponentHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LazyComponentHandler, deps: [{ token: DefaultComponentHandler }], target: i0.ɵɵFactoryTarget.Injectable });
LazyComponentHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LazyComponentHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LazyComponentHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: DefaultComponentHandler }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class InnerComponentsHostDirective {
    constructor(data, vcr, 
    // dependencies required for ComponentWrapper directive
    cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector, eventService) {
        this.data = data;
        this.vcr = vcr;
        this.cmsComponentsService = cmsComponentsService;
        this.injector = injector;
        this.dynamicAttributeService = dynamicAttributeService;
        this.renderer = renderer;
        this.componentHandler = componentHandler;
        this.cmsInjector = cmsInjector;
        this.eventService = eventService;
        this.innerComponents$ = this.data.data$.pipe(map((data) => data?.composition?.inner ?? []), distinctUntilChanged());
        this.componentWrappers = [];
    }
    ngOnInit() {
        this.subscription = this.innerComponents$.subscribe((x) => {
            this.renderComponents(x);
        });
    }
    renderComponents(components) {
        this.clearComponents();
        components.forEach((component) => this.renderComponent(component));
    }
    renderComponent(component) {
        const componentWrapper = new ComponentWrapperDirective(this.vcr, this.cmsComponentsService, this.injector, this.dynamicAttributeService, this.renderer, this.componentHandler, this.cmsInjector, this.eventService);
        componentWrapper.cxComponentWrapper = { flexType: component, uid: '' };
        componentWrapper.ngOnInit();
        this.componentWrappers.push(componentWrapper);
    }
    clearComponents() {
        this.componentWrappers.forEach((wrapper) => wrapper.ngOnDestroy());
        this.componentWrappers = [];
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
        this.clearComponents();
    }
}
InnerComponentsHostDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: InnerComponentsHostDirective, deps: [{ token: CmsComponentData }, { token: i0.ViewContainerRef }, { token: CmsComponentsService }, { token: i0.Injector }, { token: i1.DynamicAttributeService }, { token: i0.Renderer2 }, { token: ComponentHandlerService }, { token: CmsInjectorService }, { token: i1.EventService }], target: i0.ɵɵFactoryTarget.Directive });
InnerComponentsHostDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: InnerComponentsHostDirective, selector: "[cxInnerComponentsHost]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: InnerComponentsHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxInnerComponentsHost]',
                }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i0.ViewContainerRef }, { type: CmsComponentsService }, { type: i0.Injector }, { type: i1.DynamicAttributeService }, { type: i0.Renderer2 }, { type: ComponentHandlerService }, { type: CmsInjectorService }, { type: i1.EventService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageComponentModule {
    static forRoot() {
        return {
            ngModule: PageComponentModule,
            providers: [
                {
                    provide: ComponentHandler,
                    useExisting: DefaultComponentHandler,
                    multi: true,
                },
                {
                    provide: ComponentHandler,
                    useExisting: LazyComponentHandler,
                    multi: true,
                },
            ],
        };
    }
}
PageComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PageComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PageComponentModule, declarations: [ComponentWrapperDirective, InnerComponentsHostDirective], imports: [CommonModule], exports: [ComponentWrapperDirective, InnerComponentsHostDirective] });
PageComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageComponentModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ComponentWrapperDirective, InnerComponentsHostDirective],
                    exports: [ComponentWrapperDirective, InnerComponentsHostDirective],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageSlotModule {
    // instantiate PageSlotService ASAP, so it can examine SSR pre-rendered DOM
    constructor(_pageSlot) {
        // Intentional empty constructor
    }
}
PageSlotModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageSlotModule, deps: [{ token: PageSlotService }], target: i0.ɵɵFactoryTarget.NgModule });
PageSlotModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PageSlotModule, declarations: [PageSlotComponent], imports: [CommonModule, OutletModule, PageComponentModule], exports: [PageSlotComponent] });
PageSlotModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageSlotModule, imports: [CommonModule, OutletModule, PageComponentModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageSlotModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OutletModule, PageComponentModule],
                    declarations: [PageSlotComponent],
                    exports: [PageSlotComponent],
                }]
        }], ctorParameters: function () { return [{ type: PageSlotService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageLayoutModule {
}
PageLayoutModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PageLayoutModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutModule, declarations: [PageLayoutComponent, PageTemplateDirective], imports: [CommonModule, OutletModule, PageSlotModule], exports: [PageLayoutComponent, PageTemplateDirective] });
PageLayoutModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutModule, imports: [CommonModule, OutletModule, PageSlotModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageLayoutModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OutletModule, PageSlotModule],
                    declarations: [PageLayoutComponent, PageTemplateDirective],
                    exports: [PageLayoutComponent, PageTemplateDirective],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PWAModuleConfig {
}
PWAModuleConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PWAModuleConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PWAModuleConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PWAModuleConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PWAModuleConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });
const defaultPWAModuleConfig = {
    pwa: {
        enabled: false,
        addToHomeScreen: false,
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AddToHomeScreenService {
    constructor(config, globalMessageService, winRef) {
        this.config = config;
        this.globalMessageService = globalMessageService;
        this.winRef = winRef;
        this.canPrompt = new BehaviorSubject(false);
        this.canPrompt$ = this.canPrompt.asObservable();
        if (this.config.pwa?.addToHomeScreen) {
            this.init();
        }
    }
    init() {
        if (this.winRef.nativeWindow) {
            this.winRef.nativeWindow.addEventListener('beforeinstallprompt', (event) => {
                event.preventDefault();
                this.deferredEvent = event;
                this.enableAddToHomeScreen();
            });
            this.winRef.nativeWindow.addEventListener('appinstalled', () => {
                this.globalMessageService.add({ key: 'pwa.addedToHomeScreen' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
                this.disableAddToHomeScreen();
                this.deferredEvent = null;
            });
        }
    }
    enableAddToHomeScreen() {
        this.canPrompt.next(true);
    }
    disableAddToHomeScreen() {
        this.canPrompt.next(false);
    }
    firePrompt() {
        if (this.deferredEvent) {
            this.deferredEvent.prompt();
        }
    }
}
AddToHomeScreenService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenService, deps: [{ token: PWAModuleConfig }, { token: i1.GlobalMessageService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
AddToHomeScreenService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: PWAModuleConfig }, { type: i1.GlobalMessageService }, { type: i1.WindowRef }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
// eslint-disable-next-line @angular-eslint/directive-class-suffix
class AddToHomeScreenComponent {
    constructor(addToHomeScreenService) {
        this.addToHomeScreenService = addToHomeScreenService;
    }
    ngOnInit() {
        this.canPrompt$ = this.addToHomeScreenService.canPrompt$;
    }
    prompt() {
        this.addToHomeScreenService.firePrompt();
    }
}
AddToHomeScreenComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenComponent, deps: [{ token: AddToHomeScreenService }], target: i0.ɵɵFactoryTarget.Directive });
AddToHomeScreenComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: AddToHomeScreenComponent, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AddToHomeScreenBannerComponent extends AddToHomeScreenComponent {
    constructor(addToHomeScreenService) {
        super(addToHomeScreenService);
        this.addToHomeScreenService = addToHomeScreenService;
    }
}
AddToHomeScreenBannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenBannerComponent, deps: [{ token: AddToHomeScreenService }], target: i0.ɵɵFactoryTarget.Component });
AddToHomeScreenBannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: AddToHomeScreenBannerComponent, selector: "cx-add-to-home-screen-banner", usesInheritance: true, ngImport: i0, template: "<div *ngIf=\"canPrompt$ | async\">\n  <div class=\"cx-add-to-home-screen-banner\">\n    <div class=\"cx-add-to-home-screen-banner-inner\">\n      <p>\n        {{ 'pwa.addToHomeScreenDescription' | cxTranslate }}\n      </p>\n      <ul>\n        <li>{{ 'pwa.noInstallationNeeded' | cxTranslate }}</li>\n        <li>{{ 'pwa.fastAccessToApplication' | cxTranslate }}</li>\n      </ul>\n      <button (click)=\"prompt()\" class=\"btn btn-primary\">\n        {{ 'pwa.addToHomeScreen' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenBannerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-add-to-home-screen-banner', template: "<div *ngIf=\"canPrompt$ | async\">\n  <div class=\"cx-add-to-home-screen-banner\">\n    <div class=\"cx-add-to-home-screen-banner-inner\">\n      <p>\n        {{ 'pwa.addToHomeScreenDescription' | cxTranslate }}\n      </p>\n      <ul>\n        <li>{{ 'pwa.noInstallationNeeded' | cxTranslate }}</li>\n        <li>{{ 'pwa.fastAccessToApplication' | cxTranslate }}</li>\n      </ul>\n      <button (click)=\"prompt()\" class=\"btn btn-primary\">\n        {{ 'pwa.addToHomeScreen' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AddToHomeScreenBtnComponent extends AddToHomeScreenComponent {
    constructor(addToHomeScreenService) {
        super(addToHomeScreenService);
        this.addToHomeScreenService = addToHomeScreenService;
    }
}
AddToHomeScreenBtnComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenBtnComponent, deps: [{ token: AddToHomeScreenService }], target: i0.ɵɵFactoryTarget.Component });
AddToHomeScreenBtnComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: AddToHomeScreenBtnComponent, selector: "cx-add-to-home-screen-btn", usesInheritance: true, ngImport: i0, template: "<span (click)=\"prompt()\">\n  <ng-content *ngIf=\"canPrompt$ | async\"></ng-content>\n</span>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddToHomeScreenBtnComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-add-to-home-screen-btn', template: "<span (click)=\"prompt()\">\n  <ng-content *ngIf=\"canPrompt$ | async\"></ng-content>\n</span>\n" }]
        }], ctorParameters: function () { return [{ type: AddToHomeScreenService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
function pwaConfigurationFactory(pwaConfig) {
    return { enabled: (!isDevMode() && pwaConfig.pwa?.enabled) || false };
}
function pwaFactory(addToHomeScreenService) {
    const result = () => addToHomeScreenService;
    return result;
}
class PwaModule {
}
PwaModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PwaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PwaModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PwaModule, declarations: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent], imports: [CommonModule, i1$3.ServiceWorkerModule, I18nModule], exports: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent] });
PwaModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PwaModule, providers: [
        provideDefaultConfig(defaultPWAModuleConfig),
        {
            provide: SwRegistrationOptions,
            useFactory: pwaConfigurationFactory,
            deps: [Config],
        },
        {
            provide: APP_INITIALIZER,
            useFactory: pwaFactory,
            deps: [AddToHomeScreenService],
            multi: true,
        },
    ], imports: [CommonModule,
        ServiceWorkerModule.register('ngsw-worker.js'),
        I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PwaModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ServiceWorkerModule.register('ngsw-worker.js'),
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig(defaultPWAModuleConfig),
                        {
                            provide: SwRegistrationOptions,
                            useFactory: pwaConfigurationFactory,
                            deps: [Config],
                        },
                        {
                            provide: APP_INITIALIZER,
                            useFactory: pwaFactory,
                            deps: [AddToHomeScreenService],
                            multi: true,
                        },
                    ],
                    declarations: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
                    exports: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const cmsRoute = {
    path: '**',
    canActivate: [CmsPageGuard],
    component: PageLayoutComponent,
};
function addCmsRoute(injector) {
    const result = () => {
        // Router could not be injected via `deps[]` due to a cyclic dependency with APP_INITIALIZER:
        const router = injector.get(Router);
        router.config.push(cmsRoute);
    };
    return result;
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CmsRouteModule {
}
CmsRouteModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRouteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CmsRouteModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: CmsRouteModule });
CmsRouteModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRouteModule, providers: [
        {
            provide: APP_INITIALIZER,
            multi: true,
            deps: [Injector],
            useFactory: addCmsRoute,
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsRouteModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: APP_INITIALIZER,
                            multi: true,
                            deps: [Injector],
                            useFactory: addCmsRoute,
                        },
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultStorefrontRoutesConfig = {
    home: { paths: [''] },
    notFound: { paths: ['not-found'] },
    // semantic links for login related pages
    login: {
        paths: ['login'],
        protected: false,
        authFlow: true,
    },
    register: {
        paths: ['login/register'],
        protected: false,
        authFlow: true,
    },
    forgotPassword: {
        paths: ['login/forgot-password'],
        protected: false,
        authFlow: true,
    },
    resetPassword: {
        paths: ['login/pw/change'],
        protected: false,
        authFlow: true,
    },
    logout: { paths: ['logout'], protected: false, authFlow: true },
    // plp routes
    search: { paths: ['search/:query'] },
    category: {
        paths: ['category/:categoryCode'],
        paramsMapping: { categoryCode: 'code' },
    },
    brand: { paths: ['Brands/:brandName/c/:brandCode'] },
    // pdp routes
    product: {
        paths: ['product/:productCode/:name'],
        paramsMapping: { productCode: 'code' },
    },
    termsAndConditions: { paths: ['terms-and-conditions'] },
    coupons: { paths: ['my-account/coupons'] },
    couponClaim: {
        paths: ['my-account/coupon/claim/:couponCode'],
        paramsMapping: { couponCode: 'code' },
    },
    myInterests: {
        paths: ['my-account/my-interests'],
    },
    notificationPreference: {
        paths: ['my-account/notification-preference'],
    },
};
const defaultRoutingConfig = {
    routing: {
        routes: defaultStorefrontRoutesConfig,
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class RoutingModule {
    static forRoot() {
        return {
            ngModule: RoutingModule,
            providers: [provideDefaultConfig(defaultRoutingConfig)],
        };
    }
}
RoutingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RoutingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: RoutingModule, imports: [i1.RoutingModule, CmsRouteModule] });
RoutingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingModule, imports: [RoutingModule$1.forRoot(), CmsRouteModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RoutingModule$1.forRoot(), CmsRouteModule],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Matches the pattern '[ ** / ] marker / :paramName'
 *
 * @param marker phrase that indicates the start of the match
 * @param paramName name of the parameter present after the marker
 * @param precedingParamName name of the parameter for every preceding url segment
 *        i.e. `param` will result in `param0`, `param1`, ...
 */
function getSuffixUrlMatcher({ marker, paramName, precedingParamName, }) {
    precedingParamName = precedingParamName || 'param';
    const matcher = function suffixUrlMatcher(segments) {
        const markerIndex = findLastIndex(segments, ({ path }) => path === marker);
        const isMarkerLastSegment = markerIndex === segments.length - 1;
        if (markerIndex === -1 || isMarkerLastSegment) {
            return null;
        }
        const paramIndex = markerIndex + 1;
        const posParams = {
            [paramName]: segments[paramIndex],
        };
        for (let i = 0; i < markerIndex; i++) {
            posParams[`${precedingParamName}${i}`] = segments[i];
        }
        return { consumed: segments.slice(0, paramIndex + 1), posParams };
    };
    if (isDevMode()) {
        matcher['_suffixRouteConfig'] = { marker, paramName, precedingParamName }; // property added for easier debugging of routes
    }
    return matcher;
}
function findLastIndex(elements, predicate) {
    for (let index = elements.length - 1; index >= 0; index--) {
        if (predicate(elements[index])) {
            return index;
        }
    }
    return -1;
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageMetaLinkService {
    constructor(winRef, rendererFactory) {
        this.winRef = winRef;
        this.rendererFactory = rendererFactory;
    }
    /**
     * Adds a canonical link element to the document head.
     *
     * If an id is provided, the link will be updated.
     * If no url is provided, the link element will be deleted.
     */
    setCanonicalLink(url) {
        let link = this.winRef.document.querySelector('link[rel="canonical"]');
        if (!url) {
            // Removing the link is an edge case, but useful if the canonical url
            // is created in CSR while developing/testing.
            link?.remove();
            return;
        }
        if (!link) {
            link = this.renderer.createElement('link');
            link.rel = 'canonical';
            link.href = url;
            this.renderer.appendChild(this.winRef.document.head, link);
        }
        else {
            link?.setAttribute('href', url);
        }
    }
    get renderer() {
        return this.rendererFactory.createRenderer(null, null);
    }
}
PageMetaLinkService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageMetaLinkService, deps: [{ token: i1.WindowRef }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });
PageMetaLinkService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageMetaLinkService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageMetaLinkService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: i0.RendererFactory2 }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SeoMetaService {
    constructor(ngTitle, ngMeta, pageMetaService, pageMetaLinkService) {
        this.ngTitle = ngTitle;
        this.ngMeta = ngMeta;
        this.pageMetaService = pageMetaService;
        this.pageMetaLinkService = pageMetaLinkService;
    }
    init() {
        this.subscription = this.pageMetaService
            .getMeta()
            .pipe(filter(isNotNullable))
            .subscribe((meta) => (this.meta = meta));
    }
    set meta(meta) {
        this.title = meta.title;
        this.description = meta.description;
        this.image = meta.image;
        this.robots = meta.robots;
        this.canonicalUrl = meta.canonicalUrl;
    }
    set title(title) {
        this.ngTitle.setTitle(title || '');
    }
    set description(value) {
        if (value) {
            this.addTag({ name: 'description', content: value || '' });
        }
        else {
            this.ngMeta.removeTag('name="description"');
        }
    }
    set image(imageUrl) {
        if (imageUrl) {
            this.addTag({ name: 'og:image', content: imageUrl });
        }
        else {
            this.ngMeta.removeTag('name="og:image"');
        }
    }
    set robots(value) {
        if (value && value.length > 0) {
            this.addTag({ name: 'robots', content: value.join(', ') });
        }
    }
    /**
     * Add the canonical Url to the head of the page.
     *
     * If the canonical url already exists the link is removed. This is quite
     * unlikely though, since canonical links are (typically) only added in SSR.
     */
    set canonicalUrl(url) {
        this.pageMetaLinkService?.setCanonicalLink(url);
    }
    addTag(meta) {
        if (meta.content) {
            this.ngMeta.updateTag(meta);
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
SeoMetaService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoMetaService, deps: [{ token: i1$1.Title }, { token: i1$1.Meta }, { token: i1.PageMetaService }, { token: PageMetaLinkService }], target: i0.ɵɵFactoryTarget.Injectable });
SeoMetaService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoMetaService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoMetaService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Title }, { type: i1$1.Meta }, { type: i1.PageMetaService }, { type: PageMetaLinkService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultSeoConfig = {
    seo: {
        structuredData: {
            disableInDevMode: true,
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SeoConfig {
}
SeoConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SeoConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const htmlLangProvider = {
    provide: APP_INITIALIZER,
    multi: true,
    useFactory: setHtmlLangAttribute,
    deps: [WindowRef, LanguageService],
};
/**
 * Sets active language in <html lang="">
 */
function setHtmlLangAttribute(winRef, languageService) {
    const result = () => {
        languageService.getActive().subscribe((lang) => {
            winRef.document.documentElement.lang = lang.replace(/_/g, '-');
        });
    };
    return result;
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class JsonLdScriptFactory {
    constructor(platformId, winRef, rendererFactory, config) {
        this.platformId = platformId;
        this.winRef = winRef;
        this.rendererFactory = rendererFactory;
        this.config = config;
        this.renderer = this.rendererFactory.createRenderer(null, null);
    }
    build(schema) {
        if (schema && this.isJsonLdRequired()) {
            this.getJsonLdScriptElement().textContent = this.escapeHtml(schema);
        }
    }
    /**
     * Indicates whether json ld data should be generated.
     *
     * This is only required on the server, but can be enabled in dev mode.
     */
    isJsonLdRequired() {
        return (!isPlatformBrowser(this.platformId) ||
            (isDevMode() && !this.config.seo?.structuredData?.disableInDevMode));
    }
    /**
     * Creates a json-ld script element. The element is created one, and appended
     * to the html body element.
     *
     * ```html
     * <script id="json-ld" type="application/ld+json">
     * </script>
     * ```
     */
    getJsonLdScriptElement() {
        const id = 'json-ld';
        let scriptElement = (this.winRef.document.getElementById(id));
        if (!scriptElement) {
            const script = this.renderer.createElement('script');
            script.id = id;
            script.type = 'application/ld+json';
            this.renderer.appendChild(this.winRef.document.body, script);
            scriptElement = script;
        }
        return scriptElement;
    }
    /**
     * Secure the given json-ld schema by encoding html characters (aka escaping), eg: <script> becomes &lt;script&gt;
     *
     * The given schema is not trusted, as malicious code could be injected (XSS)
     * into the json-ld script.
     */
    escapeHtml(schema) {
        const div = this.renderer.createElement('div');
        div.textContent = JSON.stringify(schema);
        return div.innerHTML;
    }
}
JsonLdScriptFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdScriptFactory, deps: [{ token: PLATFORM_ID }, { token: i1.WindowRef }, { token: i0.RendererFactory2 }, { token: SeoConfig }], target: i0.ɵɵFactoryTarget.Injectable });
JsonLdScriptFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdScriptFactory, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdScriptFactory, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i1.WindowRef }, { type: i0.RendererFactory2 }, { type: SeoConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Low level directive that adds a json-ld script tag to the component.
 * This code bypasses the strict XSS security, as otherwise we're not able
 * to append a script tag with JS inside.
 *
 * This helper directive is actually not used in Spartacus, as Spartacus
 * appends json-ld the data to the document body.
 *
 * This directive can however be used by merchants to write static schema data
 * to the DOM in a save way.
 */
class JsonLdDirective {
    /**
     * Writes the schema data to a json-ld script element.
     */
    set cxJsonLd(schema) {
        this.generateJsonLdScript(schema);
    }
    constructor(renderer, jsonLdScriptFactory, element) {
        this.renderer = renderer;
        this.jsonLdScriptFactory = jsonLdScriptFactory;
        this.element = element;
    }
    /**
     * attach the json-ld script tag to DOM with the schema data secured by encoding html tags (aka escaping)
     */
    generateJsonLdScript(schema) {
        if (schema && this.jsonLdScriptFactory.isJsonLdRequired()) {
            const script = this.renderer.createElement('script');
            script.type = 'application/ld+json';
            script.textContent = this.jsonLdScriptFactory.escapeHtml(schema);
            this.renderer.appendChild(this.element.nativeElement, script);
        }
    }
}
JsonLdDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdDirective, deps: [{ token: i0.Renderer2 }, { token: JsonLdScriptFactory }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
JsonLdDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: JsonLdDirective, selector: "[cxJsonLd]", inputs: { cxJsonLd: "cxJsonLd" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxJsonLd]',
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: JsonLdScriptFactory }, { type: i0.ElementRef }]; }, propDecorators: { cxJsonLd: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Injection token to extend schema builders for adding structural data (json-ld).
 *
 * Some builders (i.e. `JSONLD_PRODUCT_BUILDER`) might have additional
 * lower level builder to further extend the schema.
 */
const SCHEMA_BUILDER = new InjectionToken('SchemaBuilderToken');
/**
 * Injection token to add specific json-ld builders for product related schemas.
 * See see https://schema.org/product for more information.
 */
const JSONLD_PRODUCT_BUILDER = new InjectionToken('JsonLdProductBuilderToken');

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Factory service that is used to build the structured data for
 * all configured schema builders.
 */
class StructuredDataFactory {
    constructor(scriptBuilder, builders) {
        this.scriptBuilder = scriptBuilder;
        this.builders = builders;
        this.subscription = new Subscription();
    }
    /**
     * Initiates the build of structured data by collecting all schema
     * builders.
     */
    build() {
        if (this.scriptBuilder.isJsonLdRequired() && this.builders) {
            this.subscription.add(this.collectSchemas().subscribe((schema) => {
                this.scriptBuilder.build(schema);
            }));
        }
    }
    /**
     * Collects all schema builders and observe their structured data.
     */
    collectSchemas() {
        return combineLatest(this.builders.map((builder) => builder.build()));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
StructuredDataFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StructuredDataFactory, deps: [{ token: JsonLdScriptFactory }, { token: SCHEMA_BUILDER, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
StructuredDataFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StructuredDataFactory, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StructuredDataFactory, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: JsonLdScriptFactory }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SCHEMA_BUILDER]
                }] }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Factory to build the structure data
 * without any interaction with the UI.
 */
function getStructuredDataFactory(injector) {
    const result = () => {
        const factory = injector.get(StructuredDataFactory);
        factory.build();
    };
    return result;
}
class StructuredDataModule {
}
StructuredDataModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StructuredDataModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StructuredDataModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: StructuredDataModule, declarations: [JsonLdDirective], imports: [CommonModule], exports: [JsonLdDirective] });
StructuredDataModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StructuredDataModule, providers: [
        {
            provide: APP_INITIALIZER,
            useFactory: getStructuredDataFactory,
            deps: [Injector],
            multi: true,
        },
    ], imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StructuredDataModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [JsonLdDirective],
                    exports: [JsonLdDirective],
                    providers: [
                        {
                            provide: APP_INITIALIZER,
                            useFactory: getStructuredDataFactory,
                            deps: [Injector],
                            multi: true,
                        },
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
function initSeoService(injector) {
    const result = () => {
        const service = injector.get(SeoMetaService);
        service.init();
    };
    return result;
}
class SeoModule {
}
SeoModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SeoModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SeoModule, imports: [StructuredDataModule] });
SeoModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoModule, providers: [
        provideDefaultConfig(defaultSeoConfig),
        {
            provide: APP_INITIALIZER,
            useFactory: initSeoService,
            deps: [Injector],
            multi: true,
        },
        htmlLangProvider,
    ], imports: [StructuredDataModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SeoModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [StructuredDataModule],
                    providers: [
                        provideDefaultConfig(defaultSeoConfig),
                        {
                            provide: APP_INITIALIZER,
                            useFactory: initSeoService,
                            deps: [Injector],
                            multi: true,
                        },
                        htmlLangProvider,
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class BreadcrumbSchemaBuilder {
    constructor(pageMetaService) {
        this.pageMetaService = pageMetaService;
    }
    build() {
        return this.pageMetaService
            .getMeta()
            .pipe(map((pageMeta) => this.collect(pageMeta)));
    }
    collect(pageMeta) {
        if (!pageMeta?.breadcrumbs) {
            return;
        }
        const crumbs = pageMeta.breadcrumbs.map((crumb, index) => {
            return {
                '@type': 'ListItem',
                position: index + 1,
                item: {
                    '@id': crumb.link,
                    name: crumb.label,
                },
            };
        });
        if (pageMeta.title) {
            crumbs.push({
                '@type': 'ListItem',
                position: crumbs.length + 1,
                item: {
                    '@id': pageMeta.title,
                    name: pageMeta.title,
                },
            });
        }
        return {
            '@context': 'http://schema.org',
            '@type': 'BreadcrumbList',
            itemListElement: crumbs,
        };
    }
}
BreadcrumbSchemaBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbSchemaBuilder, deps: [{ token: i1.PageMetaService }], target: i0.ɵɵFactoryTarget.Injectable });
BreadcrumbSchemaBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbSchemaBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbSchemaBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.PageMetaService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Builds the basic structured data for the product, see https://schema.org/product.
 * This builder includes data for sku number, name, description, brand and main image.
 */
class JsonLdBaseProductBuilder {
    build(product) {
        return of({
            ...this.getProductBase(product),
            ...this.getProductBrand(product),
            ...this.getProductImage(product),
        });
    }
    /**
     * Returns the product sku, name and description.
     */
    getProductBase(product) {
        const result = { sku: product.code };
        if (product.name) {
            result.name = product.name;
        }
        if (product.summary) {
            result.description = product.summary;
        }
        return result;
    }
    /**
     * Returns the image object with the main product image url.
     *
     * If the image is not available, an empty object is returned.
     */
    getProductImage(product) {
        const image = product.images?.PRIMARY?.zoom?.url;
        return image ? { image } : {};
    }
    /**
     * Returns the brand object with the product manufacturer.
     *
     * If the brand is not available, an empty object is returned.
     */
    getProductBrand(product) {
        const brand = product.manufacturer;
        return brand ? { brand } : {};
    }
}
JsonLdBaseProductBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdBaseProductBuilder, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
JsonLdBaseProductBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdBaseProductBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdBaseProductBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Builds the structured data for the product offer, see https://schema.org/offers.
 * The data includes the price, currency and availability level.
 */
class JsonLdProductOfferBuilder {
    build(product) {
        const schema = { '@type': 'Offer' };
        if (product.price?.value) {
            schema.price = product.price.value;
            if (product.price.currencyIso) {
                schema.priceCurrency = product.price.currencyIso;
            }
        }
        if (product.stock && product.stock.stockLevelStatus) {
            schema.availability =
                product.stock.stockLevelStatus === 'inStock' ? 'InStock' : 'OutOfStock';
        }
        return of({ offers: schema });
    }
}
JsonLdProductOfferBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdProductOfferBuilder, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
JsonLdProductOfferBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdProductOfferBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdProductOfferBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Builds the structured data for the product reviews, see https://schema.org/Review.
 * The data includes the aggregated product rating and the individual reviews.
 */
class JsonLdProductReviewBuilder {
    constructor(reviewService, config) {
        this.reviewService = reviewService;
        this.config = config;
    }
    build(product) {
        return this.reviewService.getByProductCode(product.code ?? '').pipe(map((reviews) => reviews?.length > 0
            ? {
                aggregateRating: this.buildAggregatedReviews(product, reviews),
                review: reviews.map((review) => this.buildReviews(review)),
            }
            : {}));
    }
    buildAggregatedReviews(product, reviews) {
        const aggregated = {
            '@type': 'AggregateRating',
        };
        if (product.averageRating) {
            aggregated.ratingValue = product.averageRating;
        }
        if (reviews) {
            aggregated.ratingCount = reviews.filter((rev) => !!rev.rating).length;
            aggregated.reviewCount = reviews.filter((rev) => !!rev.comment).length;
        }
        return aggregated;
    }
    buildReviews(review) {
        const reviewSchema = {
            '@type': 'review',
        };
        if (review.principal && review.principal.name) {
            reviewSchema.author = review.principal.name;
        }
        if (review.date) {
            const date = new Date(review.date);
            reviewSchema.datePublished = `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
        }
        if (review.headline) {
            reviewSchema.name = review.headline;
        }
        if (review.comment) {
            reviewSchema.description = review.comment;
        }
        if (review.rating) {
            reviewSchema.reviewRating = {
                '@type': 'Rating',
                ratingValue: review.rating.toString(),
            };
        }
        return reviewSchema;
    }
}
JsonLdProductReviewBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdProductReviewBuilder, deps: [{ token: i1.ProductReviewService }, { token: SeoConfig }], target: i0.ɵɵFactoryTarget.Injectable });
JsonLdProductReviewBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdProductReviewBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdProductReviewBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ProductReviewService }, { type: SeoConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CurrentProductService {
    constructor(routingService, productService) {
        this.routingService = routingService;
        this.productService = productService;
        this.DEFAULT_PRODUCT_SCOPE = "details" /* ProductScope.DETAILS */;
    }
    /**
     * Returns an observable for the current product
     * @returns Product
     * @returns null if product can't be found
     *
     * @param scopes
     */
    getProduct(scopes) {
        return this.getCode().pipe(distinctUntilChanged(), switchMap((productCode) => {
            return productCode
                ? this.productService.get(productCode, scopes || this.DEFAULT_PRODUCT_SCOPE)
                : of(null);
        }), filter(isNotUndefined));
    }
    getCode() {
        return this.routingService
            .getRouterState()
            .pipe(map((state) => state.state.params['productCode']));
    }
}
CurrentProductService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CurrentProductService, deps: [{ token: i1.RoutingService }, { token: i1.ProductService }], target: i0.ɵɵFactoryTarget.Injectable });
CurrentProductService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CurrentProductService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CurrentProductService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.ProductService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Adds the minimal structured data for the product, see https://schema.org/product.
 * The actual data collection is delegated to `JsonLdBuilder`s, which can be injected
 * using the `JSONLD_PRODUCT_BUILDER` token.
 */
class ProductSchemaBuilder {
    constructor(currentProduct, builders) {
        this.currentProduct = currentProduct;
        this.builders = builders;
    }
    build() {
        return this.currentProduct.getProduct().pipe(switchMap((product) => {
            if (product) {
                return combineLatest(this.collect(product)).pipe(map((res) => Object.assign({}, ...res)));
            }
            return of({});
        }));
    }
    collect(product) {
        if (!product || !product.code) {
            return [];
        }
        const builders = this.builders
            ? this.builders.map((builder) => builder.build(product))
            : [];
        return [
            of({
                '@context': 'http://schema.org',
                '@type': 'Product',
            }),
            ...builders,
        ];
    }
}
ProductSchemaBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductSchemaBuilder, deps: [{ token: CurrentProductService }, { token: JSONLD_PRODUCT_BUILDER, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
ProductSchemaBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductSchemaBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductSchemaBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [JSONLD_PRODUCT_BUILDER]
                }] }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Provides several standard json-ld builders that contribute
 * to collecting and building json-ld data.
 */
class JsonLdBuilderModule {
}
JsonLdBuilderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdBuilderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
JsonLdBuilderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: JsonLdBuilderModule });
JsonLdBuilderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdBuilderModule, providers: [
        {
            provide: SCHEMA_BUILDER,
            useExisting: ProductSchemaBuilder,
            multi: true,
        },
        {
            provide: SCHEMA_BUILDER,
            useExisting: BreadcrumbSchemaBuilder,
            multi: true,
        },
        // lower level json-ld builder classes offering fine-grained control
        // for product related schemas
        {
            provide: JSONLD_PRODUCT_BUILDER,
            useExisting: JsonLdBaseProductBuilder,
            multi: true,
        },
        {
            provide: JSONLD_PRODUCT_BUILDER,
            useExisting: JsonLdProductOfferBuilder,
            multi: true,
        },
        {
            provide: JSONLD_PRODUCT_BUILDER,
            useExisting: JsonLdProductReviewBuilder,
            multi: true,
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: JsonLdBuilderModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: SCHEMA_BUILDER,
                            useExisting: ProductSchemaBuilder,
                            multi: true,
                        },
                        {
                            provide: SCHEMA_BUILDER,
                            useExisting: BreadcrumbSchemaBuilder,
                            multi: true,
                        },
                        // lower level json-ld builder classes offering fine-grained control
                        // for product related schemas
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdBaseProductBuilder,
                            multi: true,
                        },
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdProductOfferBuilder,
                            multi: true,
                        },
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdProductReviewBuilder,
                            multi: true,
                        },
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var PageSection;
(function (PageSection) {
    PageSection["HEADER"] = "header";
    PageSection["FOOTER"] = "footer";
    PageSection["NAVIGATION"] = "navigation";
})(PageSection || (PageSection = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Helper function to simplify the creation of static CMS structure (`CmsStructureConfig`).
 * The helper function leverage the `provideConfig`, and is only providing an easy way to
 * generate the cms structure. The function creates a configuration structure for components,
 * page slot and page template. The following example adds a component to a page slot:
 *
 * ```ts
 * provideCmsStructure({
 *   componentId: 'LoginComponent',
 *   pageSlotPosition: 'SiteLogin'
 * })
 * ```
 *
 * @param options.componentId component identifier is used to provide component structure
 * @param options.pageSlotPosition page slot position is used to provide the slot configuration
 * @param options.pageTemplate the page template is used to provide the page slot to the given page template
 * @param options.section the section is used to provide the page slot to the given section
 * @param options.breakpoint the breakpoint is used to provide the page slot for a specific breakpoint
 */
function provideCmsStructure(options) {
    return provideConfig({
        ...buildCmsStructure(options),
        ...buildLayoutConfig(options),
    });
}
/**
 * @private
 */
function buildCmsStructure({ componentId, pageSlotPosition, } = {}) {
    const config = { cmsStructure: {} };
    if (componentId) {
        config.cmsStructure = {
            components: {
                [componentId]: {
                    typeCode: componentId,
                    flexType: componentId,
                },
            },
        };
    }
    if (componentId && pageSlotPosition && config.cmsStructure) {
        config.cmsStructure.slots = {
            [pageSlotPosition]: { componentIds: [componentId] },
        };
    }
    return config;
}
/**
 * @private
 */
function buildLayoutConfig({ pageTemplate, pageSlotPosition, breakpoint, section, } = {}) {
    const layoutConfig = {};
    if (pageTemplate && pageSlotPosition) {
        const pageTemplateSlots = {};
        if (breakpoint) {
            pageTemplateSlots[breakpoint] = {
                slots: [pageSlotPosition],
            };
        }
        else {
            pageTemplateSlots.slots = [pageSlotPosition];
        }
        layoutConfig.layoutSlots = {
            [pageTemplate]: pageTemplateSlots,
        };
    }
    if (section && pageSlotPosition) {
        const sectionSlots = {};
        if (breakpoint) {
            sectionSlots[breakpoint] = { slots: [pageSlotPosition] };
        }
        else {
            sectionSlots.slots = [pageSlotPosition];
        }
        if (layoutConfig.layoutSlots) {
            layoutConfig.layoutSlots[section] = sectionSlots;
        }
        else {
            layoutConfig.layoutSlots = {
                [section]: sectionSlots,
            };
        }
    }
    return layoutConfig;
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CarouselService {
    constructor(winRef) {
        this.winRef = winRef;
    }
    /**
     * The number of items per slide is calculated by the help of
     * the item width and the available width of the host element.
     * This appoach makes it possible to place the carousel in different
     * layouts. Instead of using the page breakpoints, the host size is
     * taken into account.
     *
     * Since there's no element resize API available, we use the
     * window `resize` event, so that we can adjust the number of items
     * whenever the window got resized.
     */
    getItemsPerSlide(nativeElement, itemWidth) {
        return this.winRef.resize$.pipe(map(() => nativeElement.clientWidth), map((totalWidth) => this.calculateItems(totalWidth, itemWidth)));
    }
    /**
     * Calculates the number of items per given hostSize.  calculated based on the given
     * intended size in pixels or percentages. The
     *
     * @param availableWidth The available width in pixels for the carousel items.
     * @param itemWidth The width per carousel item, in px or percentage.
     */
    calculateItems(availableWidth, itemWidth) {
        let calculatedItems = 0;
        if (itemWidth.endsWith('px')) {
            const num = itemWidth.substring(0, itemWidth.length - 2);
            calculatedItems = availableWidth / num;
        }
        if (itemWidth.endsWith('%')) {
            const perc = itemWidth.substring(0, itemWidth.length - 1);
            calculatedItems =
                availableWidth / (availableWidth * (perc / 100));
        }
        return Math.floor(calculatedItems) || 1;
    }
}
CarouselService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CarouselService, deps: [{ token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
CarouselService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CarouselService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CarouselService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Generic carousel component that can be used to render any carousel items,
 * such as products, images, banners, or any component. Carousel items are
 * rendered in so-called carousel slides, and the previous/next buttons as well as
 * the indicator-buttons can used to navigate the slides.
 *
 * The component uses an array of Observables (`items$`) as an input, to allow
 * for lazy loading of items.
 *
 * The number of items per slide is calculated with the `itemWidth`, which can given
 * in pixels or percentage.
 *
 * To allow for flexible rendering of items, the rendering is delegated to the
 * given `template`. This allows for maximum flexibility.
 */
class CarouselComponent {
    set setItems(inputItems) {
        this.items = inputItems;
        //Reset slider when changing products
        this.activeSlide = 0;
    }
    constructor(el, service) {
        this.el = el;
        this.service = service;
        /**
         * Specifies the minimum size of the carousel item, either in px or %.
         * This value is used for the calculation of numbers per carousel, so that
         * the number of carousel items is dynamic. The calculation uses the `itemWidth`
         * and the host element `clientWidth`, so that the carousel is reusable in
         * different layouts (for example in a 50% grid).
         */
        this.itemWidth = '300px';
        /**
         * Indicates whether the visual indicators are used.
         */
        this.hideIndicators = false;
        this.indicatorIcon = ICON_TYPE.CIRCLE;
        this.previousIcon = ICON_TYPE.CARET_LEFT;
        this.nextIcon = ICON_TYPE.CARET_RIGHT;
    }
    ngOnInit() {
        if (!this.template && isDevMode()) {
            console.error('No template reference provided to render the carousel items for the `cx-carousel`');
            return;
        }
        this.size$ = this.service
            .getItemsPerSlide(this.el.nativeElement, this.itemWidth)
            .pipe(tap(() => (this.activeSlide = 0)));
    }
    getSlideNumber(size, currentIndex) {
        const normalizedCurrentIndex = currentIndex + 1;
        return Math.ceil(normalizedCurrentIndex / size);
    }
}
CarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CarouselComponent, deps: [{ token: i0.ElementRef }, { token: CarouselService }], target: i0.ɵɵFactoryTarget.Component });
CarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: CarouselComponent, selector: "cx-carousel", inputs: { title: "title", setItems: ["items", "setItems"], template: "template", itemWidth: "itemWidth", hideIndicators: "hideIndicators", indicatorIcon: "indicatorIcon", previousIcon: "previousIcon", nextIcon: "nextIcon" }, ngImport: i0, template: "<ng-container *ngIf=\"items && items.length > 0 && (size$ | async) as size\">\n  <h2 *ngIf=\"title\">{{ title }}</h2>\n\n  <div class=\"carousel-panel\" [ngClass]=\"'size-' + size\">\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"previous\"\n      (click)=\"activeSlide = activeSlide - size\"\n      [disabled]=\"activeSlide === 0\"\n      [attr.aria-label]=\"'carousel.previousSlide' | cxTranslate\"\n    >\n      <cx-icon [type]=\"previousIcon\"></cx-icon>\n    </button>\n\n    <div class=\"slides\">\n      <ng-container *ngFor=\"let _ of items; let i = index\">\n        <div\n          class=\"slide\"\n          *ngIf=\"i % size === 0\"\n          [class.active]=\"i === activeSlide\"\n        >\n          <ng-container\n            *ngFor=\"let item of items | slice: i:i + size; let j = index\"\n          >\n            <div\n              *ngIf=\"item | async as data\"\n              class=\"item\"\n              [class.active]=\"i === activeSlide\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"template; context: { item: data }\"\n              ></ng-container>\n            </div>\n          </ng-container>\n        </div>\n      </ng-container>\n    </div>\n\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"next\"\n      (click)=\"activeSlide = activeSlide + size\"\n      tabindex=\"-1\"\n      [disabled]=\"activeSlide > items.length - size - 1\"\n      [attr.aria-label]=\"'carousel.nextSlide' | cxTranslate\"\n    >\n      <cx-icon [type]=\"nextIcon\"></cx-icon>\n    </button>\n  </div>\n\n  <div *ngIf=\"!hideIndicators && size < items.length\" class=\"indicators\">\n    <ng-container *ngFor=\"let _ of items; let i = index\">\n      <button\n        *ngIf=\"i % size === 0\"\n        (click)=\"activeSlide = i\"\n        [disabled]=\"i === activeSlide\"\n        [attr.aria-label]=\"\n          'carousel.slideNumber'\n            | cxTranslate: { currentSlideNumber: getSlideNumber(size, i) }\n        \"\n        tabindex=\"-1\"\n      >\n        <cx-icon [type]=\"indicatorIcon\" aria-hidden=\"true\"></cx-icon>\n      </button>\n    </ng-container>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i3.SlicePipe, name: "slice" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-carousel', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"items && items.length > 0 && (size$ | async) as size\">\n  <h2 *ngIf=\"title\">{{ title }}</h2>\n\n  <div class=\"carousel-panel\" [ngClass]=\"'size-' + size\">\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"previous\"\n      (click)=\"activeSlide = activeSlide - size\"\n      [disabled]=\"activeSlide === 0\"\n      [attr.aria-label]=\"'carousel.previousSlide' | cxTranslate\"\n    >\n      <cx-icon [type]=\"previousIcon\"></cx-icon>\n    </button>\n\n    <div class=\"slides\">\n      <ng-container *ngFor=\"let _ of items; let i = index\">\n        <div\n          class=\"slide\"\n          *ngIf=\"i % size === 0\"\n          [class.active]=\"i === activeSlide\"\n        >\n          <ng-container\n            *ngFor=\"let item of items | slice: i:i + size; let j = index\"\n          >\n            <div\n              *ngIf=\"item | async as data\"\n              class=\"item\"\n              [class.active]=\"i === activeSlide\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"template; context: { item: data }\"\n              ></ng-container>\n            </div>\n          </ng-container>\n        </div>\n      </ng-container>\n    </div>\n\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"next\"\n      (click)=\"activeSlide = activeSlide + size\"\n      tabindex=\"-1\"\n      [disabled]=\"activeSlide > items.length - size - 1\"\n      [attr.aria-label]=\"'carousel.nextSlide' | cxTranslate\"\n    >\n      <cx-icon [type]=\"nextIcon\"></cx-icon>\n    </button>\n  </div>\n\n  <div *ngIf=\"!hideIndicators && size < items.length\" class=\"indicators\">\n    <ng-container *ngFor=\"let _ of items; let i = index\">\n      <button\n        *ngIf=\"i % size === 0\"\n        (click)=\"activeSlide = i\"\n        [disabled]=\"i === activeSlide\"\n        [attr.aria-label]=\"\n          'carousel.slideNumber'\n            | cxTranslate: { currentSlideNumber: getSlideNumber(size, i) }\n        \"\n        tabindex=\"-1\"\n      >\n        <cx-icon [type]=\"indicatorIcon\" aria-hidden=\"true\"></cx-icon>\n      </button>\n    </ng-container>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: CarouselService }]; }, propDecorators: { title: [{
                type: Input
            }], setItems: [{
                type: Input,
                args: ['items']
            }], template: [{
                type: Input
            }], itemWidth: [{
                type: Input
            }], hideIndicators: [{
                type: Input
            }], indicatorIcon: [{
                type: Input
            }], previousIcon: [{
                type: Input
            }], nextIcon: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Generic carousel that renders CMS Components.
 */
class BannerCarouselComponent {
    constructor(componentData, cmsService) {
        this.componentData = componentData;
        this.cmsService = cmsService;
        this.componentData$ = this.componentData.data$.pipe(filter((data) => Boolean(data)), tap((d) => (this.theme = `${d.effect}-theme`)));
        this.items$ = this.componentData$.pipe(map((data) => data.banners?.trim().split(' ') ?? []), map((codes) => codes.map((code) => this.cmsService.getComponentData(code))));
        /**
         * Adds a specific theme for the carousel. The effect can be
         * used in CSS customisations.
         */
        this.theme = '';
    }
    /**
     * Returns an Obervable with an Array of Observables. This is done, so that
     * the component UI could consider to lazy load the UI components when they're
     * in the viewpoint.
     */
    getItems() {
        return this.items$;
    }
}
BannerCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerCarouselComponent, deps: [{ token: CmsComponentData }, { token: i1.CmsService }], target: i0.ɵɵFactoryTarget.Component });
BannerCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: BannerCarouselComponent, selector: "cx-banner-carousel", host: { properties: { "class": "this.theme" } }, ngImport: i0, template: "<cx-carousel\n  *ngIf=\"getItems() | async as items\"\n  [items]=\"items\"\n  [template]=\"template\"\n  itemWidth=\"100%\"\n  class=\"inline-navigation\"\n></cx-carousel>\n\n<ng-template #template let-item=\"item\">\n  <ng-container\n    [cxComponentWrapper]=\"{\n      flexType: item.typeCode,\n      typeCode: item.typeCode,\n      uid: item?.uid\n    }\"\n  >\n  </ng-container>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }, { kind: "component", type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerCarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-banner-carousel', changeDetection: ChangeDetectionStrategy.OnPush, template: "<cx-carousel\n  *ngIf=\"getItems() | async as items\"\n  [items]=\"items\"\n  [template]=\"template\"\n  itemWidth=\"100%\"\n  class=\"inline-navigation\"\n></cx-carousel>\n\n<ng-template #template let-item=\"item\">\n  <ng-container\n    [cxComponentWrapper]=\"{\n      flexType: item.typeCode,\n      typeCode: item.typeCode,\n      uid: item?.uid\n    }\"\n  >\n  </ng-container>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.CmsService }]; }, propDecorators: { theme: [{
                type: HostBinding,
                args: ['class']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SpinnerModule {
}
SpinnerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SpinnerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SpinnerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SpinnerModule, declarations: [SpinnerComponent], imports: [CommonModule, I18nModule], exports: [SpinnerComponent] });
SpinnerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SpinnerModule, imports: [CommonModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SpinnerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    declarations: [SpinnerComponent],
                    exports: [SpinnerComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ConsentManagementComponent {
    constructor(userConsentService, globalMessageService, anonymousConsentsConfig, anonymousConsentsService, authService) {
        this.userConsentService = userConsentService;
        this.globalMessageService = globalMessageService;
        this.anonymousConsentsConfig = anonymousConsentsConfig;
        this.anonymousConsentsService = anonymousConsentsService;
        this.authService = authService;
        this.subscriptions = new Subscription();
        this.allConsentsLoading = new BehaviorSubject(false);
        this.requiredConsents = [];
    }
    ngOnInit() {
        this.loading$ = combineLatest([
            this.userConsentService.getConsentsResultLoading(),
            this.userConsentService.getGiveConsentResultLoading(),
            this.userConsentService.getWithdrawConsentResultLoading(),
            this.authService.isUserLoggedIn(),
            this.allConsentsLoading,
        ]).pipe(map(([consentLoading, giveConsentLoading, withdrawConsentLoading, isUserLoggedIn, allConsentsLoading,]) => consentLoading ||
            giveConsentLoading ||
            withdrawConsentLoading ||
            !isUserLoggedIn ||
            allConsentsLoading));
        this.consentListInit();
        this.giveConsentInit();
        this.withdrawConsentInit();
    }
    consentListInit() {
        this.templateList$ = this.userConsentService.getConsents().pipe(withLatestFrom(this.anonymousConsentsService.getTemplates(), this.authService.isUserLoggedIn()), filter(([_templateList, _anonymousTemplates, isUserLoggedIn]) => isUserLoggedIn), tap(([templateList, _anonymousTemplates]) => {
            if (!this.consentsExists(templateList)) {
                this.userConsentService.loadConsents();
            }
        }), map(([templateList, anonymousTemplates]) => {
            if (this.anonymousConsentsConfig.anonymousConsents) {
                if (this.anonymousConsentsConfig.anonymousConsents.requiredConsents) {
                    this.requiredConsents =
                        this.anonymousConsentsConfig.anonymousConsents.requiredConsents;
                }
                if (this.anonymousConsentsConfig.anonymousConsents.consentManagementPage) {
                    return this.hideAnonymousConsents(templateList, anonymousTemplates);
                }
            }
            return templateList;
        }));
    }
    hideAnonymousConsents(templateList, anonymousTemplates = []) {
        let hideTemplateIds = [];
        if (!this.anonymousConsentsConfig.anonymousConsents?.consentManagementPage
            ?.showAnonymousConsents) {
            hideTemplateIds = anonymousTemplates.map((template) => template.id ?? '');
            return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
        }
        if (this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
            .hideConsents &&
            this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                .hideConsents.length > 0) {
            hideTemplateIds =
                this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                    .hideConsents;
        }
        return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
    }
    giveConsentInit() {
        this.userConsentService.resetGiveConsentProcessState();
        this.subscriptions.add(this.userConsentService
            .getGiveConsentResultSuccess()
            .subscribe((success) => this.onConsentGivenSuccess(success)));
    }
    withdrawConsentInit() {
        this.userConsentService.resetWithdrawConsentProcessState();
        this.subscriptions.add(this.userConsentService
            .getWithdrawConsentResultLoading()
            .pipe(skipWhile(Boolean), withLatestFrom(this.userConsentService.getWithdrawConsentResultSuccess()), map(([, withdrawalSuccess]) => withdrawalSuccess), tap((withdrawalSuccess) => {
            if (withdrawalSuccess) {
                this.userConsentService.loadConsents();
            }
        }))
            .subscribe((withdrawalSuccess) => this.onConsentWithdrawnSuccess(withdrawalSuccess)));
    }
    consentsExists(templateList) {
        return Boolean(templateList) && templateList.length > 0;
    }
    onConsentChange({ given, template, }) {
        if (given && template.id && template.version !== undefined) {
            this.userConsentService.giveConsent(template.id, template.version);
        }
        else if (template.currentConsent?.code) {
            this.userConsentService.withdrawConsent(template.currentConsent.code);
        }
    }
    onConsentGivenSuccess(success) {
        if (success) {
            this.userConsentService.resetGiveConsentProcessState();
            this.globalMessageService.add({ key: 'consentManagementForm.message.success.given' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        }
    }
    onConsentWithdrawnSuccess(success) {
        if (success) {
            this.userConsentService.resetWithdrawConsentProcessState();
            this.globalMessageService.add({ key: 'consentManagementForm.message.success.withdrawn' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        }
    }
    rejectAll(templates = []) {
        const consentsToWithdraw = [];
        templates.forEach((template) => {
            if (template.currentConsent &&
                this.userConsentService.isConsentGiven(template.currentConsent)) {
                if (this.isRequiredConsent(template)) {
                    return;
                }
                consentsToWithdraw.push(template);
            }
        });
        this.allConsentsLoading.next(true);
        this.subscriptions.add(this.setupWithdrawalStream(consentsToWithdraw)
            .pipe(tap((_timesLoaded) => this.allConsentsLoading.next(false)))
            .subscribe());
    }
    setupWithdrawalStream(consentsToWithdraw = []) {
        const loading$ = concat(this.userConsentService.getWithdrawConsentResultLoading()).pipe(distinctUntilChanged(), filter((loading) => !loading));
        const count$ = loading$.pipe(scan((acc, _value) => acc + 1, -1));
        const withdraw$ = count$.pipe(tap((i) => {
            if (i < consentsToWithdraw.length) {
                const code = consentsToWithdraw[i].currentConsent?.code;
                if (code) {
                    this.userConsentService.withdrawConsent(code);
                }
            }
        }));
        const checkTimesLoaded$ = withdraw$.pipe(filter((timesLoaded) => timesLoaded === consentsToWithdraw.length));
        return checkTimesLoaded$;
    }
    allowAll(templates = []) {
        const consentsToGive = [];
        templates.forEach((template) => {
            if (template.currentConsent &&
                this.userConsentService.isConsentWithdrawn(template.currentConsent)) {
                if (this.isRequiredConsent(template)) {
                    return;
                }
            }
            consentsToGive.push(template);
        });
        this.allConsentsLoading.next(true);
        this.subscriptions.add(this.setupGiveStream(consentsToGive)
            .pipe(tap((_timesLoaded) => this.allConsentsLoading.next(false)))
            .subscribe());
    }
    setupGiveStream(consentsToGive = []) {
        const loading$ = concat(this.userConsentService.getGiveConsentResultLoading()).pipe(distinctUntilChanged(), filter((loading) => !loading));
        const count$ = loading$.pipe(scan((acc, _value) => acc + 1, -1));
        const giveConsent$ = count$.pipe(tap((i) => {
            if (i < consentsToGive.length) {
                const consent = consentsToGive[i];
                if (consent.id && consent.version !== undefined) {
                    this.userConsentService.giveConsent(consent.id, consent.version);
                }
            }
        }));
        const checkTimesLoaded$ = giveConsent$.pipe(filter((timesLoaded) => timesLoaded === consentsToGive.length));
        return checkTimesLoaded$;
    }
    isRequiredConsent(template) {
        return Boolean(template.id &&
            this.anonymousConsentsConfig.anonymousConsents &&
            this.anonymousConsentsConfig.anonymousConsents?.requiredConsents &&
            this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id));
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.allConsentsLoading.unsubscribe();
        this.userConsentService.resetGiveConsentProcessState();
        this.userConsentService.resetWithdrawConsentProcessState();
    }
}
ConsentManagementComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ConsentManagementComponent, deps: [{ token: i1.UserConsentService }, { token: i1.GlobalMessageService }, { token: i1.AnonymousConsentsConfig }, { token: i1.AnonymousConsentsService }, { token: i1.AuthService }], target: i0.ɵɵFactoryTarget.Component });
ConsentManagementComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ConsentManagementComponent, selector: "cx-consent-management", ngImport: i0, template: "<div *ngIf=\"loading$ | async; else consentManagementForm\">\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</div>\n\n<ng-template #consentManagementForm>\n  <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n  <ng-container *ngIf=\"templateList$ | async as templateList\">\n    <div class=\"cx-consent-action-links\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"rejectAll(templateList)\"\n        >\n          {{ 'consentManagementForm.clearAll' | cxTranslate }}\n        </button>\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"allowAll(templateList)\"\n        >\n          {{ 'consentManagementForm.selectAll' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div class=\"cx-consent-toggles\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <cx-consent-management-form\n          *ngFor=\"let consentTemplate of templateList\"\n          [consentTemplate]=\"consentTemplate\"\n          [requiredConsents]=\"requiredConsents\"\n          (consentChanged)=\"onConsentChange($event)\"\n        ></cx-consent-management-form>\n      </div>\n    </div>\n  </ng-container>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "component", type: ConsentManagementFormComponent, selector: "cx-consent-management-form", inputs: ["consentTemplate", "requiredConsents", "consent"], outputs: ["consentChanged"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ConsentManagementComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-consent-management', template: "<div *ngIf=\"loading$ | async; else consentManagementForm\">\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</div>\n\n<ng-template #consentManagementForm>\n  <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n  <ng-container *ngIf=\"templateList$ | async as templateList\">\n    <div class=\"cx-consent-action-links\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"rejectAll(templateList)\"\n        >\n          {{ 'consentManagementForm.clearAll' | cxTranslate }}\n        </button>\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"allowAll(templateList)\"\n        >\n          {{ 'consentManagementForm.selectAll' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div class=\"cx-consent-toggles\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <cx-consent-management-form\n          *ngFor=\"let consentTemplate of templateList\"\n          [consentTemplate]=\"consentTemplate\"\n          [requiredConsents]=\"requiredConsents\"\n          (consentChanged)=\"onConsentChange($event)\"\n        ></cx-consent-management-form>\n      </div>\n    </div>\n  </ng-container>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1.UserConsentService }, { type: i1.GlobalMessageService }, { type: i1.AnonymousConsentsConfig }, { type: i1.AnonymousConsentsService }, { type: i1.AuthService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ConsentManagementModule {
}
ConsentManagementModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ConsentManagementModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ConsentManagementModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ConsentManagementModule, declarations: [ConsentManagementComponent, ConsentManagementFormComponent], imports: [CommonModule,
        FormsModule,
        ReactiveFormsModule,
        SpinnerModule,
        I18nModule,
        IconModule], exports: [ConsentManagementComponent, ConsentManagementFormComponent] });
ConsentManagementModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ConsentManagementModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ConsentManagementComponent: {
                    component: ConsentManagementComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [CommonModule,
        FormsModule,
        ReactiveFormsModule,
        SpinnerModule,
        I18nModule,
        IconModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ConsentManagementModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        SpinnerModule,
                        I18nModule,
                        IconModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ConsentManagementComponent: {
                                    component: ConsentManagementComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ConsentManagementComponent, ConsentManagementFormComponent],
                    exports: [ConsentManagementComponent, ConsentManagementFormComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AnonymousConsentsDialogModule {
}
AnonymousConsentsDialogModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentsDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AnonymousConsentsDialogModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentsDialogModule, declarations: [AnonymousConsentDialogComponent], imports: [CommonModule,
        I18nModule,
        IconModule,
        SpinnerModule,
        ConsentManagementModule,
        KeyboardFocusModule], exports: [AnonymousConsentDialogComponent] });
AnonymousConsentsDialogModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentsDialogModule, imports: [CommonModule,
        I18nModule,
        IconModule,
        SpinnerModule,
        ConsentManagementModule,
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AnonymousConsentsDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        IconModule,
                        SpinnerModule,
                        ConsentManagementModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [AnonymousConsentDialogComponent],
                    exports: [AnonymousConsentDialogComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AtMessageDirective {
    constructor(elementRef, templateRef, globalMessageService) {
        this.elementRef = elementRef;
        this.templateRef = templateRef;
        this.globalMessageService = globalMessageService;
    }
    get host() {
        return !!this.templateRef
            ? this.templateRef.elementRef.nativeElement.parentElement
            : this.elementRef.nativeElement;
    }
    /**
     * Emit assistive global meesage to improve screen reader vocalization.
     * @param event
     */
    handleClick(event) {
        event?.preventDefault();
        if (event?.target === this.host && this.cxAtMessage) {
            const message = Array.isArray(this.cxAtMessage)
                ? this.cxAtMessage.join('\n')
                : this.cxAtMessage;
            this.globalMessageService
                .get()
                .pipe(take(1))
                .subscribe((globalMessageEntities) => {
                // Override current assitive message.
                if (globalMessageEntities[GlobalMessageType.MSG_TYPE_ASSISTIVE]) {
                    this.globalMessageService.remove(GlobalMessageType.MSG_TYPE_ASSISTIVE);
                }
                this.globalMessageService.add(message, GlobalMessageType.MSG_TYPE_ASSISTIVE);
            });
        }
    }
}
AtMessageDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AtMessageDirective, deps: [{ token: i0.ElementRef }, { token: i0.TemplateRef, optional: true }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Directive });
AtMessageDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: AtMessageDirective, selector: "[cxAtMessage]", inputs: { cxAtMessage: "cxAtMessage" }, host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AtMessageDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxAtMessage]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }, { type: i1.GlobalMessageService }]; }, propDecorators: { cxAtMessage: [{
                type: Input
            }], handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var PopoverEvent;
(function (PopoverEvent) {
    PopoverEvent["INSIDE_CLICK"] = "insideClick";
    PopoverEvent["OUTSIDE_CLICK"] = "outsideClick";
    PopoverEvent["ESCAPE_KEYDOWN"] = "escapeKeydown";
    PopoverEvent["CLOSE_BUTTON_CLICK"] = "closeButtonClick";
    PopoverEvent["CLOSE_BUTTON_KEYDOWN"] = "closeButtonKeydown";
    PopoverEvent["ROUTE_CHANGE"] = "routeChange";
    PopoverEvent["OPEN"] = "open";
    PopoverEvent["OPEN_BY_KEYBOARD"] = "openByKeyboard";
})(PopoverEvent || (PopoverEvent = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PositioningService {
    constructor(winRef) {
        this.winRef = winRef;
    }
    get allowedPlacements() {
        return [
            'top',
            'bottom',
            'left',
            'right',
            'top-left',
            'top-right',
            'bottom-left',
            'bottom-right',
            'left-top',
            'left-bottom',
            'right-top',
            'right-bottom',
        ];
    }
    get placementSeparator() {
        return /\s+/;
    }
    get window() {
        return this.winRef.nativeWindow;
    }
    get document() {
        return this.winRef.document;
    }
    getAllStyles(element) {
        return this.window?.getComputedStyle(element);
    }
    getPositionStyleProperty(element) {
        const styles = this.getAllStyles(element);
        if (styles) {
            return styles['position'] || undefined;
        }
    }
    isStaticPositioned(element) {
        return (this.getPositionStyleProperty(element) || 'static') === 'static';
    }
    offsetParent(element) {
        let offsetParentEl = element.offsetParent || this.document.documentElement;
        while (offsetParentEl &&
            offsetParentEl !== this.document.documentElement &&
            this.isStaticPositioned(offsetParentEl)) {
            offsetParentEl = offsetParentEl.offsetParent;
        }
        return offsetParentEl || this.document.documentElement;
    }
    position(element, round = true) {
        let elPosition;
        let parentOffset = {
            width: 0,
            height: 0,
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
        };
        if (this.getPositionStyleProperty(element) === 'fixed') {
            elPosition = element.getBoundingClientRect();
            elPosition = {
                top: elPosition.top,
                bottom: elPosition.bottom,
                left: elPosition.left,
                right: elPosition.right,
                height: elPosition.height,
                width: elPosition.width,
            };
        }
        else {
            const offsetParentEl = this.offsetParent(element);
            elPosition = this.offset(element, false);
            if (offsetParentEl !== this.document.documentElement) {
                parentOffset = this.offset(offsetParentEl, false);
            }
            parentOffset.top += offsetParentEl.clientTop;
            parentOffset.left += offsetParentEl.clientLeft;
        }
        elPosition.top -= parentOffset.top;
        elPosition.bottom -= parentOffset.top;
        elPosition.left -= parentOffset.left;
        elPosition.right -= parentOffset.left;
        if (round) {
            elPosition.top = Math.round(elPosition.top);
            elPosition.bottom = Math.round(elPosition.bottom);
            elPosition.left = Math.round(elPosition.left);
            elPosition.right = Math.round(elPosition.right);
        }
        return elPosition;
    }
    offset(element, round = true) {
        const elBcr = element.getBoundingClientRect();
        const viewportOffset = {
            top: (this.window &&
                this.window.pageYOffset - this.document.documentElement.clientTop) ||
                0,
            left: (this.window &&
                this.window.pageXOffset - this.document.documentElement.clientLeft) ||
                0,
        };
        const elOffset = {
            height: elBcr.height || element.offsetHeight,
            width: elBcr.width || element.offsetWidth,
            top: elBcr.top + viewportOffset.top,
            bottom: elBcr.bottom + viewportOffset.top,
            left: elBcr.left + viewportOffset.left,
            right: elBcr.right + viewportOffset.left,
        };
        if (round) {
            elOffset.height = Math.round(elOffset.height);
            elOffset.width = Math.round(elOffset.width);
            elOffset.top = Math.round(elOffset.top);
            elOffset.bottom = Math.round(elOffset.bottom);
            elOffset.left = Math.round(elOffset.left);
            elOffset.right = Math.round(elOffset.right);
        }
        return elOffset;
    }
    /*
      Return false if the element to position is outside the viewport.
    */
    _positionElements(hostElement, targetElement, placement, appendToBody) {
        const [placementPrimary = 'top', placementSecondary = 'center'] = placement.split('-');
        const hostElPosition = appendToBody
            ? this.offset(hostElement, false)
            : this.position(hostElement, false);
        const targetElStyles = this.getAllStyles(targetElement);
        if (targetElStyles) {
            const marginTop = parseFloat(targetElStyles.marginTop);
            const marginBottom = parseFloat(targetElStyles.marginBottom);
            const marginLeft = parseFloat(targetElStyles.marginLeft);
            const marginRight = parseFloat(targetElStyles.marginRight);
            let topPosition = 0;
            let leftPosition = 0;
            switch (placementPrimary) {
                case 'top':
                    topPosition =
                        hostElPosition.top -
                            (targetElement.offsetHeight + marginTop + marginBottom);
                    break;
                case 'bottom':
                    topPosition = hostElPosition.top + hostElPosition.height;
                    break;
                case 'left':
                    leftPosition =
                        hostElPosition.left -
                            (targetElement.offsetWidth + marginLeft + marginRight);
                    break;
                case 'right':
                    leftPosition = hostElPosition.left + hostElPosition.width;
                    break;
            }
            switch (placementSecondary) {
                case 'top':
                    topPosition = hostElPosition.top;
                    break;
                case 'bottom':
                    topPosition =
                        hostElPosition.top +
                            hostElPosition.height -
                            targetElement.offsetHeight;
                    break;
                case 'left':
                    leftPosition = hostElPosition.left;
                    break;
                case 'right':
                    leftPosition =
                        hostElPosition.left +
                            hostElPosition.width -
                            targetElement.offsetWidth;
                    break;
                case 'center':
                    if (placementPrimary === 'top' || placementPrimary === 'bottom') {
                        leftPosition =
                            hostElPosition.left +
                                hostElPosition.width / 2 -
                                targetElement.offsetWidth / 2;
                    }
                    else {
                        topPosition =
                            hostElPosition.top +
                                hostElPosition.height / 2 -
                                targetElement.offsetHeight / 2;
                    }
                    break;
            }
            targetElement.style.transform = `translate(${Math.round(leftPosition)}px, ${Math.round(topPosition)}px)`;
            // Check if the targetElement is inside the viewport
            const targetElBCR = targetElement.getBoundingClientRect();
            const html = this.document.documentElement;
            const windowHeight = this.window?.innerHeight || html.clientHeight;
            const windowWidth = this.window?.innerWidth || html.clientWidth;
            return (targetElBCR.left >= 0 &&
                targetElBCR.top >= 0 &&
                targetElBCR.right <= windowWidth &&
                targetElBCR.bottom <= windowHeight);
        }
        return false;
    }
    /*
     * Accept the placement array and applies the appropriate placement dependent on the viewport.
     * Returns the applied placement.
     * In case of auto placement, placements are selected in order
     *   'top', 'bottom', 'left', 'right',
     *   'top-left', 'top-right',
     *   'bottom-left', 'bottom-right',
     *   'left-top', 'left-bottom',
     *   'right-top', 'right-bottom'.
     * */
    positionElements(hostElement, targetElement, placement, appendToBody) {
        const placementVals = Array.isArray(placement)
            ? placement
            : placement.split(this.placementSeparator);
        let hasAuto = placementVals.findIndex((val) => val === 'auto');
        if (hasAuto >= 0) {
            this.allowedPlacements.forEach((obj) => {
                if (placementVals.find((val) => val.search('^' + obj) !== -1) == null) {
                    placementVals.splice(hasAuto++, 1, obj);
                }
            });
        }
        const style = targetElement.style;
        style.position = 'absolute';
        style.top = '0';
        style.left = '0';
        let testPlacement = 'auto';
        let isInViewport = false;
        for (testPlacement of placementVals) {
            if (this._positionElements(hostElement, targetElement, testPlacement, appendToBody)) {
                isInViewport = true;
                break;
            }
        }
        if (!isInViewport) {
            this._positionElements(hostElement, targetElement, testPlacement, appendToBody);
        }
        return testPlacement;
    }
    getPositioningClass(position, autoPositioning) {
        let positionClass = `${position || 'top'}`;
        if (autoPositioning && positionClass !== 'auto') {
            positionClass = `${positionClass} auto`;
        }
        return positionClass;
    }
}
PositioningService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PositioningService, deps: [{ token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
PositioningService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PositioningService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PositioningService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PopoverComponent {
    /**
     * Listens for click inside popover component wrapper.
     */
    insideClick() {
        this.eventSubject.next(PopoverEvent.INSIDE_CLICK);
    }
    /**
     * Listens for every document click and ignores clicks
     * inside component.
     */
    outsideClick(event) {
        if (!this.isClickedOnPopover(event) && !this.isClickedOnDirective(event)) {
            this.eventSubject.next(PopoverEvent.OUTSIDE_CLICK);
        }
    }
    /**
     * Listens for `escape` keydown event.
     */
    escapeKeydown() {
        this.eventSubject.next(PopoverEvent.ESCAPE_KEYDOWN);
    }
    isClickedOnPopover(event) {
        return this.popoverInstance.location.nativeElement.contains(event.target);
    }
    isClickedOnDirective(event) {
        return this.triggerElement.nativeElement.contains(event.target);
    }
    /**
     * Emits close event trigger.
     */
    close(event) {
        event.preventDefault();
        if (event instanceof MouseEvent) {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_CLICK);
        }
        else {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
        }
    }
    /**
     * Method uses `Renderer2` service to listen window scroll event.
     *
     * Registered only if property `positionOnScroll` is set to `true`.
     */
    triggerScrollEvent() {
        this.scrollEventUnlistener = this.renderer.listen(this.winRef.nativeWindow, 'scroll', () => this.positionPopover());
    }
    /**
     * Method uses positioning service calculation and based on that
     * updates class name for popover component instance.
     */
    positionPopover() {
        this.popoverClass = this.positioningService.positionElements(this.triggerElement.nativeElement, this.popoverInstance.location.nativeElement, this.positioningService.getPositioningClass(this.position, this.autoPositioning), this.appendToBody);
        this.changeDetectionRef.markForCheck();
        this.baseClass = `${this.customClass} ${this.popoverClass} opened`;
    }
    ngOnInit() {
        if (!this.customClass) {
            this.customClass = 'cx-popover';
        }
        if (!this.position) {
            this.position = 'top';
        }
        if (this.autoPositioning === undefined) {
            this.autoPositioning = true;
        }
        this.baseClass = `${this.customClass}`;
        this.resizeSub = this.winRef.resize$.subscribe(() => {
            this.positionPopover();
        });
        this.routeChangeSub = this.router.events
            .pipe(filter((event) => event instanceof NavigationStart))
            .subscribe(() => {
            this.eventSubject.next(PopoverEvent.ROUTE_CHANGE);
        });
        if (this.positionOnScroll) {
            this.triggerScrollEvent();
        }
    }
    /**
     * indicates if passed content is a TemplateRef or string.
     */
    isTemplate(content) {
        return content instanceof TemplateRef;
    }
    isString(content) {
        return !(content instanceof TemplateRef);
    }
    ngAfterViewChecked() {
        this.positionPopover();
    }
    ngOnDestroy() {
        if (this.resizeSub) {
            this.resizeSub.unsubscribe();
        }
        if (this.routeChangeSub) {
            this.routeChangeSub.unsubscribe();
        }
        if (this.scrollEventUnlistener) {
            this.scrollEventUnlistener();
        }
    }
    constructor(positioningService, winRef, changeDetectionRef, renderer, router) {
        this.positioningService = positioningService;
        this.winRef = winRef;
        this.changeDetectionRef = changeDetectionRef;
        this.renderer = renderer;
        this.router = router;
        /**
         * Icon types for close button icon.
         */
        this.iconTypes = ICON_TYPE;
    }
}
PopoverComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverComponent, deps: [{ token: PositioningService }, { token: i1.WindowRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }, { token: i1$2.Router }], target: i0.ɵɵFactoryTarget.Component });
PopoverComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PopoverComponent, selector: "cx-popover", host: { listeners: { "click": "insideClick()", "document:click": "outsideClick($event)", "keydown.escape": "escapeKeydown()" }, properties: { "className": "this.baseClass" } }, ngImport: i0, template: "<div class=\"arrow\"></div>\n<div class=\"popover-body\" [cxFocus]=\"focusConfig\">\n  <div class=\"cx-close-row\">\n    <button\n      *ngIf=\"displayCloseButton\"\n      type=\"button\"\n      class=\"close\"\n      (keydown.enter)=\"close($event)\"\n      (keydown.space)=\"close($event)\"\n      (click)=\"close($event)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <ng-container *ngIf=\"isTemplate(content)\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </ng-container>\n  <span *ngIf=\"isString(content)\">{{ content }}</span>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-popover', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"arrow\"></div>\n<div class=\"popover-body\" [cxFocus]=\"focusConfig\">\n  <div class=\"cx-close-row\">\n    <button\n      *ngIf=\"displayCloseButton\"\n      type=\"button\"\n      class=\"close\"\n      (keydown.enter)=\"close($event)\"\n      (keydown.space)=\"close($event)\"\n      (click)=\"close($event)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <ng-container *ngIf=\"isTemplate(content)\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </ng-container>\n  <span *ngIf=\"isString(content)\">{{ content }}</span>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: PositioningService }, { type: i1.WindowRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: i1$2.Router }]; }, propDecorators: { baseClass: [{
                type: HostBinding,
                args: ['className']
            }], insideClick: [{
                type: HostListener,
                args: ['click']
            }], outsideClick: [{
                type: HostListener,
                args: ['document:click', ['$event']]
            }], escapeKeydown: [{
                type: HostListener,
                args: ['keydown.escape']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PopoverService {
    /**
     * For a11y improvements method returns different `FocusConfig`
     * based on which event popover was triggered.
     */
    getFocusConfig(event, appendToBody) {
        let config = {};
        if (event === PopoverEvent.OPEN_BY_KEYBOARD && appendToBody) {
            config = {
                trap: true,
                block: true,
                focusOnEscape: false,
                autofocus: true,
            };
        }
        return config;
    }
    setFocusOnElement(element, focusConfig, appendToBody) {
        if (focusConfig && appendToBody) {
            element.nativeElement.focus();
        }
    }
}
PopoverService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PopoverService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive to bind popover with any DOM element.
 */
class PopoverDirective {
    /**
     * Listen events fired on element binded to popover directive.
     *
     * Based on event type some a11y improvements can be made.
     * For example if popover was opened by `space` or `enter` key
     * dedicated `FocusConfig` can be set to autofocus first
     * focusable element in popover container.
     */
    handlePress(event) {
        event?.preventDefault();
        if (event?.target === this.element.nativeElement && !this.isOpen) {
            this.eventSubject.next(PopoverEvent.OPEN_BY_KEYBOARD);
        }
        else if (this.isOpen) {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
        }
    }
    handleTab() {
        if (!this.focusConfig?.trap && this.isOpen) {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_KEYDOWN);
        }
    }
    handleEscape() {
        this.eventSubject.next(PopoverEvent.ESCAPE_KEYDOWN);
    }
    handleClick(event) {
        event?.preventDefault();
        if (event?.target === this.element.nativeElement && !this.isOpen) {
            this.eventSubject.next(PopoverEvent.OPEN);
        }
        else if (this.isOpen) {
            this.eventSubject.next(PopoverEvent.CLOSE_BUTTON_CLICK);
        }
    }
    /**
     * Method performs open action for popover component.
     */
    open(event) {
        if (!this.cxPopoverOptions?.disable) {
            this.isOpen = true;
            this.focusConfig = this.popoverService.getFocusConfig(event, this.cxPopoverOptions?.appendToBody || false);
            this.renderPopover();
            this.openPopover.emit();
        }
    }
    /**
     * Method performs close action for popover component.
     */
    close() {
        this.isOpen = false;
        this.viewContainer.clear();
        this.closePopover.emit();
    }
    /**
     * Method subscribes for events emitted by popover component
     * and based on event performs specific action.
     */
    handlePopoverEvents() {
        this.eventSubject.subscribe((event) => {
            if (this.openTriggerEvents.includes(event)) {
                this.open(event);
            }
            if (this.focusPopoverTriggerEvents.includes(event)) {
                this.popoverContainer.location.nativeElement.focus();
            }
            if (this.closeTriggerEvents.includes(event)) {
                this.close();
            }
            if (this.focusDirectiveTriggerEvents.includes(event)) {
                this.popoverService.setFocusOnElement(this.element, this.focusConfig, this.cxPopoverOptions?.appendToBody);
            }
        });
    }
    /**
     * Method creates instance and pass parameters to popover component.
     */
    renderPopover() {
        const containerFactory = this.componentFactoryResolver.resolveComponentFactory(PopoverComponent);
        this.popoverContainer =
            this.viewContainer.createComponent(containerFactory);
        const componentInstance = this.popoverContainer.instance;
        if (componentInstance) {
            componentInstance.content = this.cxPopover;
            componentInstance.triggerElement = this.element;
            componentInstance.popoverInstance = this.popoverContainer;
            componentInstance.focusConfig = this.focusConfig;
            componentInstance.eventSubject = this.eventSubject;
            componentInstance.position = this.cxPopoverOptions?.placement;
            componentInstance.customClass = this.cxPopoverOptions?.class;
            componentInstance.appendToBody = this.cxPopoverOptions?.appendToBody;
            componentInstance.positionOnScroll =
                this.cxPopoverOptions?.positionOnScroll;
            componentInstance.displayCloseButton =
                this.cxPopoverOptions?.displayCloseButton;
            componentInstance.autoPositioning =
                this.cxPopoverOptions?.autoPositioning;
            if (this.cxPopoverOptions?.appendToBody) {
                this.renderer.appendChild(this.winRef.document.body, this.popoverContainer.location.nativeElement);
            }
            this.popoverContainer.changeDetectorRef.detectChanges();
        }
    }
    ngOnInit() {
        this.handlePopoverEvents();
    }
    constructor(element, viewContainer, componentFactoryResolver, renderer, changeDetectorRef, popoverService, winRef) {
        this.element = element;
        this.viewContainer = viewContainer;
        this.componentFactoryResolver = componentFactoryResolver;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        this.popoverService = popoverService;
        this.winRef = winRef;
        /**
         * An event emitted when the popover is opened.
         */
        this.openPopover = new EventEmitter();
        /**
         * An event emitted when the popover is closed.
         */
        this.closePopover = new EventEmitter();
        /**
         * Subject which emits specific type of `PopoverEvent`.
         */
        this.eventSubject = new Subject();
        this.openTriggerEvents = [
            PopoverEvent.OPEN,
            PopoverEvent.OPEN_BY_KEYBOARD,
        ];
        this.focusPopoverTriggerEvents = [
            PopoverEvent.OPEN_BY_KEYBOARD,
        ];
        this.closeTriggerEvents = [
            PopoverEvent.ROUTE_CHANGE,
            PopoverEvent.ESCAPE_KEYDOWN,
            PopoverEvent.OUTSIDE_CLICK,
            PopoverEvent.CLOSE_BUTTON_KEYDOWN,
            PopoverEvent.CLOSE_BUTTON_CLICK,
        ];
        this.focusDirectiveTriggerEvents = [
            PopoverEvent.ESCAPE_KEYDOWN,
            PopoverEvent.CLOSE_BUTTON_KEYDOWN,
        ];
    }
}
PopoverDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverDirective, deps: [{ token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: PopoverService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Directive });
PopoverDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: PopoverDirective, selector: "[cxPopover]", inputs: { cxPopover: "cxPopover", cxPopoverOptions: "cxPopoverOptions" }, outputs: { openPopover: "openPopover", closePopover: "closePopover" }, host: { listeners: { "keydown.enter": "handlePress($event)", "keydown.space": "handlePress($event)", "keydown.tab": "handleTab()", "keydown.shift.tab": "handleTab()", "keydown.escape": "handleEscape()", "click": "handleClick($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxPopover]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: PopoverService }, { type: i1.WindowRef }]; }, propDecorators: { cxPopover: [{
                type: Input
            }], cxPopoverOptions: [{
                type: Input
            }], openPopover: [{
                type: Output
            }], closePopover: [{
                type: Output
            }], handlePress: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }], handleTab: [{
                type: HostListener,
                args: ['keydown.tab']
            }, {
                type: HostListener,
                args: ['keydown.shift.tab']
            }], handleEscape: [{
                type: HostListener,
                args: ['keydown.escape']
            }], handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultLimit = 20;
class TruncatePipe {
    /**
     * example usage {{ exampleString | cxTruncate: [1, ''] }}
     */
    transform(value, args) {
        if (!args) {
            return value;
        }
        let trail = '...';
        const limit = args.length > 0 && args[0] && Number.isInteger(+args[0])
            ? args[0]
            : defaultLimit;
        if (args.length > 1 && args[1] !== undefined) {
            trail = args[1];
        }
        return value.length > limit ? value.substring(0, limit) + trail : value;
    }
}
TruncatePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TruncatePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
TruncatePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: TruncatePipe, name: "cxTruncate" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TruncatePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cxTruncate',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TruncateTextPopoverComponent {
    constructor() {
        /**
         * The maximum length of the characters after which the text will be truncated
         */
        this.charactersLimit = 100;
    }
    get isTruncated() {
        return this.content.length > +this.charactersLimit;
    }
}
TruncateTextPopoverComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TruncateTextPopoverComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TruncateTextPopoverComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: TruncateTextPopoverComponent, selector: "cx-truncate-text-popover", inputs: { content: "content", charactersLimit: "charactersLimit", customClass: "customClass" }, ngImport: i0, template: "<ng-container>\n  <ng-container>\n    <span class=\"truncated-text\" [ngClass]=\"customClass\">\n      {{ content | cxTruncate: [charactersLimit] }}\n    </span>\n  </ng-container>\n\n  <ng-template #fullText>\n    {{ content }}\n  </ng-template>\n\n  <button\n    *ngIf=\"isTruncated\"\n    [cxPopover]=\"fullText\"\n    [cxPopoverOptions]=\"{\n      placement: 'auto',\n      appendToBody: true,\n      displayCloseButton: true\n    }\"\n    class=\"ml-1 link cx-action-link\"\n  >\n    {{ 'common.more' | cxTranslate }}\n  </button>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: PopoverDirective, selector: "[cxPopover]", inputs: ["cxPopover", "cxPopoverOptions"], outputs: ["openPopover", "closePopover"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: TruncatePipe, name: "cxTruncate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TruncateTextPopoverComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-truncate-text-popover', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container>\n  <ng-container>\n    <span class=\"truncated-text\" [ngClass]=\"customClass\">\n      {{ content | cxTruncate: [charactersLimit] }}\n    </span>\n  </ng-container>\n\n  <ng-template #fullText>\n    {{ content }}\n  </ng-template>\n\n  <button\n    *ngIf=\"isTruncated\"\n    [cxPopover]=\"fullText\"\n    [cxPopoverOptions]=\"{\n      placement: 'auto',\n      appendToBody: true,\n      displayCloseButton: true\n    }\"\n    class=\"ml-1 link cx-action-link\"\n  >\n    {{ 'common.more' | cxTranslate }}\n  </button>\n</ng-container>\n" }]
        }], propDecorators: { content: [{
                type: Input
            }], charactersLimit: [{
                type: Input
            }], customClass: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CardComponent {
    // ACTIONS
    setEditMode() {
        this.editMode = true;
    }
    cancelEdit() {
        this.editMode = false;
        this.cancelCard.emit(5);
    }
    delete() {
        this.deleteCard.emit(1);
    }
    setDefault() {
        this.isDefault = true;
        this.setDefaultCard.emit(2);
    }
    send() {
        this.sendCard.emit(3);
    }
    edit() {
        this.editCard.emit(4);
    }
    isCardAction(action) {
        return action.event !== undefined;
    }
    isCardLinkAction(action) {
        return action.link !== undefined;
    }
    constructor() {
        this.iconTypes = ICON_TYPE;
        this.deleteCard = new EventEmitter();
        this.setDefaultCard = new EventEmitter();
        this.sendCard = new EventEmitter();
        this.editCard = new EventEmitter();
        this.cancelCard = new EventEmitter();
        this.border = false;
        this.editMode = false;
        this.isDefault = false;
        this.fitToContainer = false;
        this.truncateText = false;
        this.charactersLimit = 100;
        // Intentional empty constructor
    }
    ngOnInit() {
        // Intentional empty method
    }
}
CardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
CardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: CardComponent, selector: "cx-card", inputs: { border: "border", editMode: "editMode", isDefault: "isDefault", content: "content", fitToContainer: "fitToContainer", truncateText: "truncateText", charactersLimit: "charactersLimit", index: "index" }, outputs: { deleteCard: "deleteCard", setDefaultCard: "setDefaultCard", sendCard: "sendCard", editCard: "editCard", cancelCard: "cancelCard" }, ngImport: i0, template: "<div\n  *ngIf=\"content\"\n  class=\"cx-card\"\n  [tabindex]=\"border ? 0 : -1\"\n  [attr.role]=\"content.role ?? null\"\n  [attr.aria-label]=\"\n    content.label ? (content.label | cxTranslate: { number: this.index }) : null\n  \"\n  [class.cx-card-border]=\"border\"\n  [class.cx-card-fit-to-container]=\"fitToContainer\"\n>\n  <!-- Card Header -->\n  <div\n    *ngIf=\"content.header && !editMode\"\n    class=\"card-header\"\n    [id]=\"'content-header' + (index >= 0 ? '-' + index : '')\"\n  >\n    {{ content.header }}\n  </div>\n  <!-- Card Body -->\n  <div class=\"card-body cx-card-body\" [class.cx-card-delete]=\"editMode\">\n    <!-- Edit message -->\n    <div *ngIf=\"editMode\" role=\"alert\" class=\"cx-card-delete-msg\">\n      {{ content.deleteMsg }}\n    </div>\n    <!-- Card title -->\n    <span *ngIf=\"content.title\" class=\"cx-card-title\">\n      {{ content.title }}\n    </span>\n    <!-- Card Content -->\n    <div class=\"cx-card-container\">\n      <!-- Card Label -->\n      <div class=\"cx-card-label-container\">\n        <div *ngIf=\"content.textBold\" class=\"cx-card-label-bold\">\n          {{ content.textBold }}\n        </div>\n        <div *ngFor=\"let line of content.text\">\n          <div\n            *ngIf=\"!truncateText; else truncate\"\n            class=\"cx-card-label\"\n            [ngClass]=\"content.customClass\"\n          >\n            {{ line }}\n          </div>\n\n          <ng-template #truncate>\n            <cx-truncate-text-popover\n              [charactersLimit]=\"charactersLimit\"\n              [content]=\"line\"\n              [customClass]=\"content.customClass\"\n            ></cx-truncate-text-popover>\n          </ng-template>\n        </div>\n        <div class=\"cx-card-paragraph\" *ngFor=\"let item of content.paragraphs\">\n          <div class=\"cx-card-paragraph-title\">{{ item.title }}</div>\n          <div *ngFor=\"let text of item.text\">\n            <div class=\"cx-card-paragraph-text\">\n              {{ text }}\n            </div>\n          </div>\n        </div>\n        <ng-content select=\"[label_container_bottom]\"></ng-content>\n      </div>\n      <!-- Image -->\n      <div *ngIf=\"content.img\" class=\"cx-card-img-container\">\n        <cx-icon [type]=\"content.img\"></cx-icon>\n      </div>\n    </div>\n    <!-- Edit Mode Actions -->\n    <div *ngIf=\"editMode\" class=\"row cx-card-body-delete\">\n      <div class=\"col-md-6\">\n        <button\n          [cxAtMessage]=\"'assistiveMessage.actionCancelled' | cxTranslate\"\n          class=\"btn btn-block btn-secondary\"\n          (click)=\"cancelEdit()\"\n        >\n          {{ 'common.cancel' | cxTranslate }}\n        </button>\n      </div>\n      <div class=\"col-md-6\" [cxFocus]=\"{ autofocus: true }\">\n        <button class=\"btn btn-block btn-primary\" (click)=\"delete()\">\n          {{ 'common.delete' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n    <!-- Actions -->\n    <div *ngIf=\"content.actions && !editMode\" class=\"cx-card-actions\">\n      <div *ngFor=\"let action of content.actions\">\n        <div>\n          <ng-container *ngIf=\"isCardAction(action)\" [ngSwitch]=\"action.event\">\n            <button\n              type=\"button\"\n              *ngSwitchCase=\"'delete'\"\n              class=\"link cx-action-link\"\n              (click)=\"delete()\"\n            >\n              {{ action.name }}\n            </button>\n            <button\n              type=\"button\"\n              *ngSwitchCase=\"'default'\"\n              class=\"link cx-action-link\"\n              (click)=\"setDefault()\"\n            >\n              {{ action.name }}\n            </button>\n            <button\n              type=\"button\"\n              *ngSwitchCase=\"'send'\"\n              class=\"link cx-action-link\"\n              (click)=\"send()\"\n              [attr.aria-describedby]=\"\n                index >= 0 && content.header && !editMode\n                  ? 'content-header-' + index\n                  : null\n              \"\n            >\n              {{ action.name }}\n            </button>\n            <button\n              type=\"button\"\n              *ngSwitchCase=\"'edit'\"\n              class=\"link cx-action-link\"\n              (click)=\"edit()\"\n            >\n              {{ action.name }}\n            </button>\n          </ng-container>\n          <a\n            *ngIf=\"isCardLinkAction(action)\"\n            href=\"{{ action.link }}\"\n            class=\"link cx-action-link\"\n          >\n            {{ action.name }}\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i3.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: AtMessageDirective, selector: "[cxAtMessage]", inputs: ["cxAtMessage"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "component", type: TruncateTextPopoverComponent, selector: "cx-truncate-text-popover", inputs: ["content", "charactersLimit", "customClass"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CardComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-card', template: "<div\n  *ngIf=\"content\"\n  class=\"cx-card\"\n  [tabindex]=\"border ? 0 : -1\"\n  [attr.role]=\"content.role ?? null\"\n  [attr.aria-label]=\"\n    content.label ? (content.label | cxTranslate: { number: this.index }) : null\n  \"\n  [class.cx-card-border]=\"border\"\n  [class.cx-card-fit-to-container]=\"fitToContainer\"\n>\n  <!-- Card Header -->\n  <div\n    *ngIf=\"content.header && !editMode\"\n    class=\"card-header\"\n    [id]=\"'content-header' + (index >= 0 ? '-' + index : '')\"\n  >\n    {{ content.header }}\n  </div>\n  <!-- Card Body -->\n  <div class=\"card-body cx-card-body\" [class.cx-card-delete]=\"editMode\">\n    <!-- Edit message -->\n    <div *ngIf=\"editMode\" role=\"alert\" class=\"cx-card-delete-msg\">\n      {{ content.deleteMsg }}\n    </div>\n    <!-- Card title -->\n    <span *ngIf=\"content.title\" class=\"cx-card-title\">\n      {{ content.title }}\n    </span>\n    <!-- Card Content -->\n    <div class=\"cx-card-container\">\n      <!-- Card Label -->\n      <div class=\"cx-card-label-container\">\n        <div *ngIf=\"content.textBold\" class=\"cx-card-label-bold\">\n          {{ content.textBold }}\n        </div>\n        <div *ngFor=\"let line of content.text\">\n          <div\n            *ngIf=\"!truncateText; else truncate\"\n            class=\"cx-card-label\"\n            [ngClass]=\"content.customClass\"\n          >\n            {{ line }}\n          </div>\n\n          <ng-template #truncate>\n            <cx-truncate-text-popover\n              [charactersLimit]=\"charactersLimit\"\n              [content]=\"line\"\n              [customClass]=\"content.customClass\"\n            ></cx-truncate-text-popover>\n          </ng-template>\n        </div>\n        <div class=\"cx-card-paragraph\" *ngFor=\"let item of content.paragraphs\">\n          <div class=\"cx-card-paragraph-title\">{{ item.title }}</div>\n          <div *ngFor=\"let text of item.text\">\n            <div class=\"cx-card-paragraph-text\">\n              {{ text }}\n            </div>\n          </div>\n        </div>\n        <ng-content select=\"[label_container_bottom]\"></ng-content>\n      </div>\n      <!-- Image -->\n      <div *ngIf=\"content.img\" class=\"cx-card-img-container\">\n        <cx-icon [type]=\"content.img\"></cx-icon>\n      </div>\n    </div>\n    <!-- Edit Mode Actions -->\n    <div *ngIf=\"editMode\" class=\"row cx-card-body-delete\">\n      <div class=\"col-md-6\">\n        <button\n          [cxAtMessage]=\"'assistiveMessage.actionCancelled' | cxTranslate\"\n          class=\"btn btn-block btn-secondary\"\n          (click)=\"cancelEdit()\"\n        >\n          {{ 'common.cancel' | cxTranslate }}\n        </button>\n      </div>\n      <div class=\"col-md-6\" [cxFocus]=\"{ autofocus: true }\">\n        <button class=\"btn btn-block btn-primary\" (click)=\"delete()\">\n          {{ 'common.delete' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n    <!-- Actions -->\n    <div *ngIf=\"content.actions && !editMode\" class=\"cx-card-actions\">\n      <div *ngFor=\"let action of content.actions\">\n        <div>\n          <ng-container *ngIf=\"isCardAction(action)\" [ngSwitch]=\"action.event\">\n            <button\n              type=\"button\"\n              *ngSwitchCase=\"'delete'\"\n              class=\"link cx-action-link\"\n              (click)=\"delete()\"\n            >\n              {{ action.name }}\n            </button>\n            <button\n              type=\"button\"\n              *ngSwitchCase=\"'default'\"\n              class=\"link cx-action-link\"\n              (click)=\"setDefault()\"\n            >\n              {{ action.name }}\n            </button>\n            <button\n              type=\"button\"\n              *ngSwitchCase=\"'send'\"\n              class=\"link cx-action-link\"\n              (click)=\"send()\"\n              [attr.aria-describedby]=\"\n                index >= 0 && content.header && !editMode\n                  ? 'content-header-' + index\n                  : null\n              \"\n            >\n              {{ action.name }}\n            </button>\n            <button\n              type=\"button\"\n              *ngSwitchCase=\"'edit'\"\n              class=\"link cx-action-link\"\n              (click)=\"edit()\"\n            >\n              {{ action.name }}\n            </button>\n          </ng-container>\n          <a\n            *ngIf=\"isCardLinkAction(action)\"\n            href=\"{{ action.link }}\"\n            class=\"link cx-action-link\"\n          >\n            {{ action.name }}\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { deleteCard: [{
                type: Output
            }], setDefaultCard: [{
                type: Output
            }], sendCard: [{
                type: Output
            }], editCard: [{
                type: Output
            }], cancelCard: [{
                type: Output
            }], border: [{
                type: Input
            }], editMode: [{
                type: Input
            }], isDefault: [{
                type: Input
            }], content: [{
                type: Input
            }], fitToContainer: [{
                type: Input
            }], truncateText: [{
                type: Input
            }], charactersLimit: [{
                type: Input
            }], index: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PopoverModule {
}
PopoverModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PopoverModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PopoverModule, declarations: [PopoverDirective, PopoverComponent], imports: [CommonModule, RouterModule, KeyboardFocusModule, IconModule], exports: [PopoverDirective, PopoverComponent] });
PopoverModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverModule, imports: [CommonModule, RouterModule, KeyboardFocusModule, IconModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PopoverModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, KeyboardFocusModule, IconModule],
                    declarations: [PopoverDirective, PopoverComponent],
                    exports: [PopoverDirective, PopoverComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TruncateTextPopoverModule {
}
TruncateTextPopoverModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TruncateTextPopoverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TruncateTextPopoverModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: TruncateTextPopoverModule, declarations: [TruncateTextPopoverComponent, TruncatePipe], imports: [CommonModule, I18nModule, PopoverModule], exports: [TruncateTextPopoverComponent, TruncatePipe] });
TruncateTextPopoverModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TruncateTextPopoverModule, imports: [CommonModule, I18nModule, PopoverModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TruncateTextPopoverModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, PopoverModule],
                    declarations: [TruncateTextPopoverComponent, TruncatePipe],
                    exports: [TruncateTextPopoverComponent, TruncatePipe],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AtMessageModule {
}
AtMessageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AtMessageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AtMessageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: AtMessageModule, declarations: [AtMessageDirective], exports: [AtMessageDirective] });
AtMessageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AtMessageModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AtMessageModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [AtMessageDirective],
                    exports: [AtMessageDirective],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CardModule {
}
CardModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CardModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: CardModule, declarations: [CardComponent], imports: [CommonModule,
        AtMessageModule,
        I18nModule,
        IconModule,
        TruncateTextPopoverModule,
        KeyboardFocusModule], exports: [CardComponent] });
CardModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CardModule, imports: [CommonModule,
        AtMessageModule,
        I18nModule,
        IconModule,
        TruncateTextPopoverModule,
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CardModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        AtMessageModule,
                        I18nModule,
                        IconModule,
                        TruncateTextPopoverModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [CardComponent],
                    exports: [CardComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Indicates how the browser should load the image.
 *
 * While this might not add too much value in some scenarios, as we have other
 * optimizations to defer loading of larger pieces of the DOM, there might be
 * components who haven't implemented other lazy loading techniques. Moreover,
 * a server sides rendered page that lands directly in the browser could benefit
 * enormously from the lazy loading of images.
 */
var ImageLoadingStrategy;
(function (ImageLoadingStrategy) {
    /**
     * Loads the image immediately, regardless of whether or not the image
     * is currently within the visible viewport (this is the default value).
     */
    ImageLoadingStrategy["EAGER"] = "eager";
    /**
     * Defers loading the image until it reaches a calculated distance from the viewport,
     * as defined by the browser. The intent is to avoid the network and storage bandwidth
     * needed to handle the image until it's reasonably certain that it will be needed.
     * This generally improves the performance of the content in most typical use cases.
     */
    ImageLoadingStrategy["LAZY"] = "lazy";
})(ImageLoadingStrategy || (ImageLoadingStrategy = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Service which generates media URLs. It leverage the MediaContainer and MediaFormats so
 * that URLs and sizes are generated for the same media. This helps to improve performance
 * across difference devices and layouts.
 *
 * Media formats are optional, but highly recommended. The format will help the browser to
 * identify the right media for the right experience.
 *
 * The MediaService will generate absolute URLs in case relative URLs are provided for the Media.
 * The baseUrl is read from the `occConfig.backend.media.baseUrl` or
 * `occConfig.backend.occ.baseUrl`.
 */
class MediaService {
    constructor(config) {
        this.config = config;
    }
    /**
     * Returns a `Media` object with the main media (`src`) and various media (`src`)
     * for specific formats.
     */
    getMedia(mediaContainer, format, alt, role) {
        if (!mediaContainer) {
            return;
        }
        const mainMedia = mediaContainer.url
            ? mediaContainer
            : this.resolveMedia(mediaContainer, format);
        return {
            src: this.resolveAbsoluteUrl(mainMedia?.url ?? ''),
            alt: alt ?? mainMedia?.altText,
            role: role ?? mainMedia?.role,
            srcset: this.resolveSrcSet(mediaContainer, format),
        };
    }
    /**
     * Reads the loading strategy from the `MediaConfig`.
     *
     * Defaults to `ImageLoadingStrategy.EAGER`.
     */
    get loadingStrategy() {
        return (this.config?.imageLoadingStrategy ??
            ImageLoadingStrategy.EAGER);
    }
    /**
     * Creates the media formats in a logical sorted order. The map contains the
     * format key and the format size information. We do this only once for performance
     * benefits.
     */
    get sortedFormats() {
        const mediaFormats = this.config?.mediaFormats;
        if (!this._sortedFormats && mediaFormats) {
            this._sortedFormats = Object.keys(mediaFormats)
                .map((key) => ({
                code: key,
                size: mediaFormats[key],
            }))
                .sort((a, b) => a.size.width && b.size.width && a.size.width > b.size.width ? 1 : -1);
        }
        return this._sortedFormats ?? [];
    }
    /**
     * Creates the media formats in a reversed sorted order.
     */
    get reversedFormats() {
        if (!this._reversedFormats) {
            this._reversedFormats = this.sortedFormats.slice().reverse();
        }
        return this._reversedFormats;
    }
    /**
     * Resolves the right media for the given format. The fo
     */
    resolveMedia(media, format) {
        return media[this.resolveFormat(media, format)];
    }
    /**
     * Validates the format against the given mediaContainer. If there is no format available,
     * or if the mediaContainer doesn't contain a media for the given media, the most optimal
     * format is resolved. If even that is not possible, the first format is returned.
     */
    resolveFormat(mediaContainer, format) {
        if (format && mediaContainer[format]) {
            return format;
        }
        return (this.resolveBestFormat(mediaContainer) || Object.keys(mediaContainer)[0]);
    }
    /**
     * Returns the media format code with the best size.
     */
    resolveBestFormat(media) {
        return this.reversedFormats.find((format) => media.hasOwnProperty(format.code))?.code;
    }
    /**
     * Returns a set of media for the available media formats. Additionally, the configured media
     * format width is added to the srcset, so that browsers can select the appropriate media.
     *
     * The optional maxFormat indicates that only sources till a certain format should be added
     * to the srcset.
     */
    resolveSrcSet(media, maxFormat) {
        if (!media) {
            return undefined;
        }
        // Only create srcset images that are smaller than the given `maxFormat` (if any)
        let formats = this.sortedFormats;
        const max = formats.findIndex((f) => f.code === maxFormat);
        if (max > -1) {
            formats = formats.slice(0, max + 1);
        }
        const srcset = formats.reduce((set, format) => {
            const image = media[format.code];
            if (!!image) {
                if (set) {
                    set += ', ';
                }
                set += `${this.resolveAbsoluteUrl(image.url ?? '')} ${format.size.width}w`;
            }
            return set;
        }, '');
        return srcset === '' ? undefined : srcset;
    }
    /**
     * Resolves the absolute URL for the given url. In most cases, this URL represents
     * the relative URL on the backend. In that case, we prefix the url with the baseUrl.
     *
     * When we have receive an absolute URL, we return the URL as-is. An absolute URL might also
     * start with double slash, which is used to resolve media cross from http and https.
     */
    resolveAbsoluteUrl(url) {
        return !url || url.startsWith('http') || url.startsWith('//')
            ? url
            : this.getBaseUrl() + url;
    }
    /**
     * The base URL is either driven by a specific `backend.media.baseUrl`, or by the
     * `backend.occ.baseUrl`.
     *
     * The `backend.media.baseUrl` can be used to load media from a different location.
     *
     * In Commerce Cloud, a different location could mean a different "aspect".
     *
     * Defaults to empty string in case no config is provided.
     */
    getBaseUrl() {
        return (this.config.backend?.media?.baseUrl ??
            this.config.backend?.occ?.baseUrl ??
            '');
    }
}
MediaService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaService, deps: [{ token: i1.Config }], target: i0.ɵɵFactoryTarget.Injectable });
MediaService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.Config }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MediaComponent {
    constructor(mediaService) {
        this.mediaService = mediaService;
        /**
         * Set the loading strategy of the media. Defaults to global loading strategy.
         * Use 'lazy' or 'eager' strategies.
         */
        this.loading = this.loadingStrategy;
        /**
         * Once the media is loaded, we emit an event.
         */
        this.loaded = new EventEmitter();
        /**
         * The `cx-media` component has an `is-initialized` class as long as the
         * media is being initialized.
         */
        this.isInitialized = false;
        /**
         * The `cx-media` component has a `is-loading` class as long as the
         * media is loaded. Wehn the media is loaded, the `is-initialized` class
         * is added.
         */
        this.isLoading = true;
        /**
         * When there's no media provided for the content, or in case an error
         * happened during loading, we add the `is-missing` class. Visual effects
         * can be controlled by CSS.
         */
        this.isMissing = false;
    }
    ngOnChanges() {
        this.create();
    }
    /**
     * Creates the `Media` object
     */
    create() {
        this.media = this.mediaService.getMedia(this.container instanceof Array ? this.container[0] : this.container, this.format, this.alt, this.role);
        if (!this.media?.src) {
            this.handleMissing();
        }
    }
    /**
     * This handler is called from the UI when the image is loaded.
     */
    loadHandler() {
        this.isLoading = false;
        this.isInitialized = true;
        this.isMissing = false;
        this.loaded.emit(true);
    }
    /**
     * Indicates whether the browser should lazy load the image.
     */
    get loadingStrategy() {
        return this.mediaService.loadingStrategy === ImageLoadingStrategy.LAZY
            ? ImageLoadingStrategy.LAZY
            : null;
    }
    /**
     * Whenever an error happens during load, we mark the component
     * with css classes to have a missing media.
     */
    errorHandler() {
        this.handleMissing();
    }
    handleMissing() {
        this.isLoading = false;
        this.isInitialized = true;
        this.isMissing = true;
        this.loaded.emit(false);
    }
}
MediaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaComponent, deps: [{ token: MediaService }], target: i0.ɵɵFactoryTarget.Component });
MediaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: MediaComponent, selector: "cx-media", inputs: { container: "container", format: "format", alt: "alt", role: "role", loading: "loading" }, outputs: { loaded: "loaded" }, host: { properties: { "class.is-initialized": "this.isInitialized", "class.is-loading": "this.isLoading", "class.is-missing": "this.isMissing" } }, usesOnChanges: true, ngImport: i0, template: "<img\n  *ngIf=\"media && media.src\"\n  [attr.src]=\"media.src\"\n  [attr.srcset]=\"media.srcset\"\n  [attr.alt]=\"media.alt\"\n  [attr.role]=\"media.role\"\n  [attr.loading]=\"loading\"\n  (load)=\"loadHandler()\"\n  (error)=\"errorHandler()\"\n/>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-media', changeDetection: ChangeDetectionStrategy.OnPush, template: "<img\n  *ngIf=\"media && media.src\"\n  [attr.src]=\"media.src\"\n  [attr.srcset]=\"media.srcset\"\n  [attr.alt]=\"media.alt\"\n  [attr.role]=\"media.role\"\n  [attr.loading]=\"loading\"\n  (load)=\"loadHandler()\"\n  (error)=\"errorHandler()\"\n/>\n" }]
        }], ctorParameters: function () { return [{ type: MediaService }]; }, propDecorators: { container: [{
                type: Input
            }], format: [{
                type: Input
            }], alt: [{
                type: Input
            }], role: [{
                type: Input
            }], loading: [{
                type: Input
            }], loaded: [{
                type: Output
            }], isInitialized: [{
                type: HostBinding,
                args: ['class.is-initialized']
            }], isLoading: [{
                type: HostBinding,
                args: ['class.is-loading']
            }], isMissing: [{
                type: HostBinding,
                args: ['class.is-missing']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MediaModule {
    static forRoot() {
        return {
            ngModule: MediaModule,
        };
    }
}
MediaModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MediaModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: MediaModule, declarations: [MediaComponent], imports: [CommonModule], exports: [MediaComponent] });
MediaModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [MediaComponent],
                    exports: [MediaComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CarouselModule {
}
CarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: CarouselModule, declarations: [CarouselComponent], imports: [CommonModule,
        RouterModule,
        IconModule,
        MediaModule,
        UrlModule,
        I18nModule], exports: [CarouselComponent] });
CarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CarouselModule, imports: [CommonModule,
        RouterModule,
        IconModule,
        MediaModule,
        UrlModule,
        I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        IconModule,
                        MediaModule,
                        UrlModule,
                        I18nModule,
                    ],
                    declarations: [CarouselComponent],
                    exports: [CarouselComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Service that provides the placeholder and input pattern for date pickers. This is
 * used in Spartacus to support browser that won't support the native html5 date picker
 * using `<input type="date">`.
 *
 * While the placeholder is configurable, you should be aware that the placeholder format
 * defaults to `yyyy-mm-dd` to align with Safaris limited support of ISO 8601.
 * Another consideration is the support of date formats in the backend. In case you change
 * this format, you might need to serialize the date to the supported date format in the
 * backend.
 *
 */
class DatePickerService {
    get placeholder() {
        return 'yyyy-mm-dd';
    }
    /**
     * The default date pattern is based on the placeholder string;
     */
    get pattern() {
        return this.placeholder
            .replace('yyyy', '\\d{4}')
            .replace('mm', '\\d{1,2}')
            .replace('dd', '\\d{1,2}');
    }
    /**
     * Validates if the string based date value is a valid date.
     */
    isValidFormat(date, pattern) {
        const patternRegex = new RegExp(`^${pattern ?? this.pattern}$`);
        return patternRegex.test(date);
    }
    /**
     * Since Safari doesn't support proper date formats (ISO 8601), we need to do this
     * ourselves. We cannot rely on `new Date('2020-1-1')`. This will fail, only
     * `new Date('2020-01-01')` works.
     */
    getDate(value) {
        if (!value) {
            return;
        }
        const delimiter = this.placeholder
            .replace('yyyy', '')
            .replace('mm', '')
            .replace('dd', '')
            .substr(0, 1);
        const dateParts = value.split(delimiter);
        const placeholderParts = this.placeholder.split(delimiter);
        const y = placeholderParts.indexOf('yyyy');
        const m = placeholderParts.indexOf('mm');
        const d = placeholderParts.indexOf('dd');
        return new Date(Number(dateParts[y]), Number(dateParts[m]) - 1, Number(dateParts[d]));
    }
}
DatePickerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DatePickerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DatePickerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DatePickerService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DatePickerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Renders translated form errors for a given form control, based on its `errors` property.
 *
 * The translation key consists of the optional input `prefix`
 * concatenated with the error key.
 *
 * And the translation params object consist of the error details
 * (if only it's an object) merged with the optional input object `translationParams`.
 */
class FormErrorsComponent {
    constructor(ChangeDetectionRef, keyValueDiffers) {
        this.ChangeDetectionRef = ChangeDetectionRef;
        this.keyValueDiffers = keyValueDiffers;
        /**
         * Prefix prepended to the translation key.
         */
        this.prefix = 'formErrors';
        this.role = 'alert';
    }
    set control(control) {
        if (!control) {
            return;
        }
        this._control = control;
        this.differ = this.keyValueDiffers.find(this.control).create();
        this.errorsDetails$ = control?.statusChanges.pipe(startWith({}), map(() => control.errors || {}), map((errors) => Object.entries(errors).filter(([_key, details]) => details)));
    }
    get control() {
        return this._control;
    }
    ngDoCheck() {
        const changes = this.differ?.diff(this.control);
        if (changes) {
            changes.forEachChangedItem((r) => {
                if (r?.key === 'touched') {
                    this.ChangeDetectionRef.markForCheck();
                }
            });
        }
    }
    /**
     * Returns translation params composed of
     * the argument `errorDetails` (if only is an object) merged with
     * the component input object `translationParams`.
     *
     * In case of a conflicting object key, the value from
     * `translationParams` takes precedence.
     */
    getTranslationParams(errorDetails) {
        errorDetails = isObject(errorDetails) ? errorDetails : {};
        return { ...errorDetails, ...this.translationParams };
    }
    get invalid() {
        return this.control?.invalid;
    }
    get dirty() {
        return this.control?.dirty;
    }
    get touched() {
        return this.control?.touched;
    }
    get hidden() {
        return !(this.invalid && (this.touched || this.dirty));
    }
}
FormErrorsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FormErrorsComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.KeyValueDiffers }], target: i0.ɵɵFactoryTarget.Component });
FormErrorsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: FormErrorsComponent, selector: "cx-form-errors", inputs: { prefix: "prefix", translationParams: "translationParams", control: "control" }, host: { properties: { "class.control-invalid": "this.invalid", "class.control-dirty": "this.dirty", "class.control-touched": "this.touched", "class.cx-visually-hidden": "this.hidden", "attr.role": "this.role" } }, ngImport: i0, template: "<ng-container *ngIf=\"errorsDetails$ | async as errorDetails\">\n  <ng-container *ngIf=\"!hidden\">\n    <p *ngFor=\"let error of errorDetails\">\n      {{\n        prefix + '.' + error[0] | cxTranslate: getTranslationParams(error[1])\n      }}\n    </p>\n  </ng-container>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FormErrorsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-form-errors', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"errorsDetails$ | async as errorDetails\">\n  <ng-container *ngIf=\"!hidden\">\n    <p *ngFor=\"let error of errorDetails\">\n      {{\n        prefix + '.' + error[0] | cxTranslate: getTranslationParams(error[1])\n      }}\n    </p>\n  </ng-container>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.KeyValueDiffers }]; }, propDecorators: { prefix: [{
                type: Input
            }], translationParams: [{
                type: Input
            }], control: [{
                type: Input
            }], invalid: [{
                type: HostBinding,
                args: ['class.control-invalid']
            }], dirty: [{
                type: HostBinding,
                args: ['class.control-dirty']
            }], touched: [{
                type: HostBinding,
                args: ['class.control-touched']
            }], hidden: [{
                type: HostBinding,
                args: ['class.cx-visually-hidden']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Component that adds a date control. While the native date picker works in most
 * modern browsers, some browsers need more guidance (placeholder), validation and
 * date conversion.
 *
 * The data picker supports (optional) min and max form controls, so that you can
 * limit the start and/or end date.
 *
 * Most of the implementation is done in the `DatePickerFallbackDirective`.
 */
class DatePickerComponent {
    constructor(service) {
        this.service = service;
        this.update = new EventEmitter();
    }
    change() {
        this.update.emit();
    }
    get placeholder() {
        return this.service.placeholder;
    }
    get pattern() {
        return this.service.pattern;
    }
    /**
     * Only returns the date if we have a valid format. We do this to avoid
     * loads of console errors coming from the datePipe while the user is typing
     * (in those browsers where the date picker isn't supported).
     */
    getDate(date) {
        return date && this.service.isValidFormat(date) ? date : undefined;
    }
}
DatePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DatePickerComponent, deps: [{ token: DatePickerService }], target: i0.ɵɵFactoryTarget.Component });
DatePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: DatePickerComponent, selector: "cx-date-picker", inputs: { control: "control", min: "min", max: "max", required: "required" }, outputs: { update: "update" }, ngImport: i0, template: "<input\n  class=\"form-control\"\n  type=\"date\"\n  [formControl]=\"control\"\n  [attr.min]=\"min\"\n  [attr.max]=\"max\"\n  [attr.required]=\"required === false ? undefined : required\"\n  (change)=\"change()\"\n  [placeholder]=\"placeholder\"\n  [pattern]=\"pattern\"\n/>\n<cx-form-errors\n  [control]=\"control\"\n  prefix=\"formErrors.date\"\n  [translationParams]=\"{\n    max: getDate(max) | cxDate,\n    min: getDate(min) | cxDate\n  }\"\n></cx-form-errors>\n", dependencies: [{ kind: "directive", type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3$1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i3$1.PatternValidator, selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]", inputs: ["pattern"] }, { kind: "directive", type: i3$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { kind: "pipe", type: i1.CxDatePipe, name: "cxDate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DatePickerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-date-picker', template: "<input\n  class=\"form-control\"\n  type=\"date\"\n  [formControl]=\"control\"\n  [attr.min]=\"min\"\n  [attr.max]=\"max\"\n  [attr.required]=\"required === false ? undefined : required\"\n  (change)=\"change()\"\n  [placeholder]=\"placeholder\"\n  [pattern]=\"pattern\"\n/>\n<cx-form-errors\n  [control]=\"control\"\n  prefix=\"formErrors.date\"\n  [translationParams]=\"{\n    max: getDate(max) | cxDate,\n    min: getDate(min) | cxDate\n  }\"\n></cx-form-errors>\n" }]
        }], ctorParameters: function () { return [{ type: DatePickerService }]; }, propDecorators: { control: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], required: [{
                type: Input
            }], update: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FormErrorsModule {
}
FormErrorsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FormErrorsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FormErrorsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: FormErrorsModule, declarations: [FormErrorsComponent], imports: [CommonModule, I18nModule], exports: [FormErrorsComponent] });
FormErrorsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FormErrorsModule, imports: [CommonModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FormErrorsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    declarations: [FormErrorsComponent],
                    exports: [FormErrorsComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class DatePickerModule {
}
DatePickerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DatePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DatePickerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: DatePickerModule, declarations: [DatePickerComponent], imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule], exports: [DatePickerComponent] });
DatePickerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DatePickerModule, imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DatePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule],
                    declarations: [DatePickerComponent],
                    exports: [DatePickerComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Component that adds a file upload control.
 */
class FileUploadComponent {
    constructor() {
        /**
         * Allowed file types. It's setting attribute used for OS window for choosing files.
         */
        this.accept = '*';
        /**
         * Allows selecting multiple files.
         */
        this.multiple = false;
        // TODO: remove this event. Now it's used only to trigger some logic in the parent component.
        // Prerequisites (changes in the parent component):
        // - use an async validator that "opens file" using the value of the form control
        // - "open file" on form submit, but not on the form control change
        this.update = new EventEmitter();
        // ControlValueAccessor START
        this.onChangeCallback = () => {
            // Intentional empty arrow function
        };
        this.onTouchedCallback = () => {
            // Intentional empty arrow function
        };
    }
    selectFile($event) {
        const files = $event.target?.files;
        this.onChangeCallback(files);
        this.update.emit(files);
    }
    removeFile() {
        this.fileInput.nativeElement.value = '';
    }
    get selectedFiles() {
        if (this.fileInput.nativeElement.files) {
            return Array.from(this.fileInput.nativeElement.files);
        }
        return undefined;
    }
    registerOnChange(callback) {
        this.onChangeCallback = callback;
    }
    registerOnTouched(callback) {
        this.onTouchedCallback = callback;
    }
    setDisabledState(disabled) {
        this.fileInput.nativeElement.disabled = disabled;
    }
    writeValue(value) {
        if (value instanceof FileList) {
            this.fileInput.nativeElement.files = value;
        }
    }
}
FileUploadComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileUploadComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FileUploadComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: FileUploadComponent, selector: "cx-file-upload", inputs: { accept: "accept", multiple: "multiple" }, outputs: { update: "update" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FileUploadComponent),
            multi: true,
        },
    ], queries: [{ propertyName: "customButton", first: true, predicate: TemplateRef, descendants: true }], viewQueries: [{ propertyName: "fileInput", first: true, predicate: ["fileInput"], descendants: true, static: true }], ngImport: i0, template: "<input\n  type=\"file\"\n  aria-hidden=\"true\"\n  [accept]=\"accept\"\n  [multiple]=\"multiple\"\n  (change)=\"selectFile($event)\"\n  #fileInput\n/>\n<button\n  *ngIf=\"!customButton\"\n  [attr.aria-label]=\"'common.selectFile' | cxTranslate\"\n  class=\"btn btn-secondary\"\n  type=\"button\"\n  (click)=\"fileInput.click()\"\n>\n  <ng-content></ng-content>\n</button>\n<!-- TODO(Brian-Parth): CXEC-17196 -->\n<button\n  class=\"link cx-action-link\"\n  *ngIf=\"customButton\"\n  (click)=\"fileInput.click()\"\n>\n  <ng-container *ngTemplateOutlet=\"customButton\"> </ng-container>\n</button>\n<p *ngFor=\"let file of selectedFiles\">\n  {{ file?.name }}\n</p>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileUploadComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-file-upload', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FileUploadComponent),
                            multi: true,
                        },
                    ], template: "<input\n  type=\"file\"\n  aria-hidden=\"true\"\n  [accept]=\"accept\"\n  [multiple]=\"multiple\"\n  (change)=\"selectFile($event)\"\n  #fileInput\n/>\n<button\n  *ngIf=\"!customButton\"\n  [attr.aria-label]=\"'common.selectFile' | cxTranslate\"\n  class=\"btn btn-secondary\"\n  type=\"button\"\n  (click)=\"fileInput.click()\"\n>\n  <ng-content></ng-content>\n</button>\n<!-- TODO(Brian-Parth): CXEC-17196 -->\n<button\n  class=\"link cx-action-link\"\n  *ngIf=\"customButton\"\n  (click)=\"fileInput.click()\"\n>\n  <ng-container *ngTemplateOutlet=\"customButton\"> </ng-container>\n</button>\n<p *ngFor=\"let file of selectedFiles\">\n  {{ file?.name }}\n</p>\n" }]
        }], propDecorators: { accept: [{
                type: Input
            }], multiple: [{
                type: Input
            }], customButton: [{
                type: ContentChild,
                args: [TemplateRef]
            }], update: [{
                type: Output
            }], fileInput: [{
                type: ViewChild,
                args: ['fileInput', { static: true }]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FileUploadModule {
}
FileUploadModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileUploadModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FileUploadModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: FileUploadModule, declarations: [FileUploadComponent], imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule], exports: [FileUploadComponent] });
FileUploadModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileUploadModule, imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileUploadModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ReactiveFormsModule, FormErrorsModule, I18nModule],
                    declarations: [FileUploadComponent],
                    exports: [FileUploadComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PasswordVisibilityToggleComponent {
    constructor() {
        this.showState = {
            icon: ICON_TYPE.EYE_SLASH,
            inputType: 'text',
            ariaLabel: 'passwordVisibility.hidePassword',
        };
        this.hideState = {
            icon: ICON_TYPE.EYE,
            inputType: 'password',
            ariaLabel: 'passwordVisibility.showPassword',
        };
        this.state = this.hideState;
    }
    /**
     * Toggle the visibility of the text of the input field.
     */
    toggle() {
        this.state =
            this.state === this.hideState ? this.showState : this.hideState;
        this.inputElement.setAttribute('type', this.state.inputType);
    }
}
PasswordVisibilityToggleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PasswordVisibilityToggleComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
PasswordVisibilityToggleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PasswordVisibilityToggleComponent, selector: "cx-password-visibility-toggle", inputs: { inputElement: "inputElement" }, ngImport: i0, template: "<button\n  type=\"button\"\n  (click)=\"toggle()\"\n  [attr.aria-label]=\"state.ariaLabel | cxTranslate\"\n>\n  <span aria-hidden=\"true\">\n    <cx-icon [type]=\"state.icon\"></cx-icon>\n  </span>\n</button>\n", dependencies: [{ kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PasswordVisibilityToggleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-password-visibility-toggle', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  type=\"button\"\n  (click)=\"toggle()\"\n  [attr.aria-label]=\"state.ariaLabel | cxTranslate\"\n>\n  <span aria-hidden=\"true\">\n    <cx-icon [type]=\"state.icon\"></cx-icon>\n  </span>\n</button>\n" }]
        }], propDecorators: { inputElement: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FormConfig {
}
FormConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FormConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FormConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FormConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FormConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Directive to bind a PasswordVisibilityToggleDirective to a password input field. This
 * toggle while alternate the appearance of the input between dots and plain text.
 */
class PasswordVisibilityToggleDirective {
    constructor(winRef, config, elementRef, viewContainerRef, changeDetectorRef) {
        this.winRef = winRef;
        this.config = config;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.changeDetectorRef = changeDetectorRef;
    }
    ngAfterViewInit() {
        if (this.config.form?.passwordVisibilityToggle) {
            this.wrapInput();
            this.insertComponent();
            this.changeDetectorRef.detectChanges();
        }
    }
    insertComponent() {
        const component = this.viewContainerRef.createComponent(PasswordVisibilityToggleComponent);
        component.instance.inputElement = this.elementRef.nativeElement;
        this.inputWrapper?.appendChild(component.location.nativeElement);
    }
    /**
     * We need to wrap the input element in a div to be able to position the toggle button in the right place.
     */
    wrapInput() {
        const input = this.elementRef.nativeElement;
        const parent = input.parentNode;
        this.inputWrapper = this.winRef.document.createElement('div');
        this.inputWrapper.setAttribute('class', 'cx-password-input-wrapper');
        // set the wrapper as child (instead of the element)
        parent.replaceChild(this.inputWrapper, input);
        this.inputWrapper.appendChild(input);
    }
}
PasswordVisibilityToggleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PasswordVisibilityToggleDirective, deps: [{ token: i1.WindowRef }, { token: FormConfig }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
PasswordVisibilityToggleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: PasswordVisibilityToggleDirective, selector: "[cxPasswordVisibilitySwitch][type=\"password\"]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PasswordVisibilityToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxPasswordVisibilitySwitch][type="password"]',
                }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: FormConfig }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultFormConfig = {
    form: {
        passwordVisibilityToggle: true,
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PasswordVisibilityToggleModule {
}
PasswordVisibilityToggleModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PasswordVisibilityToggleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PasswordVisibilityToggleModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PasswordVisibilityToggleModule, declarations: [PasswordVisibilityToggleDirective,
        PasswordVisibilityToggleComponent], imports: [CommonModule, IconModule, I18nModule], exports: [PasswordVisibilityToggleDirective,
        PasswordVisibilityToggleComponent] });
PasswordVisibilityToggleModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PasswordVisibilityToggleModule, providers: [provideDefaultConfig(defaultFormConfig)], imports: [CommonModule, IconModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PasswordVisibilityToggleModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IconModule, I18nModule],
                    providers: [provideDefaultConfig(defaultFormConfig)],
                    declarations: [
                        PasswordVisibilityToggleDirective,
                        PasswordVisibilityToggleComponent,
                    ],
                    exports: [
                        PasswordVisibilityToggleDirective,
                        PasswordVisibilityToggleComponent,
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class GenericLinkComponentService {
    constructor() {
        /**
         * Pattern matching string starting with `http://` or `https://`.
         */
        this.HTTP_PROTOCOL_REGEX = /^https?:\/\//i;
        /**
         * Pattern matching string starting with `mailto:`.
         */
        this.MAILTO_PROTOCOL_REGEX = /^mailto:/i;
        /**
         * Pattern matching string starting with `tel:`.
         */
        this.TEL_PROTOCOL_REGEX = /^tel:/i;
    }
    /**
     * Returns true when the @Input `url` is a string starting with `http://`, `https://`, `mailto:`, `tel:`.
     */
    isExternalUrl(url) {
        return (typeof url === 'string' &&
            (this.HTTP_PROTOCOL_REGEX.test(url) ||
                this.MAILTO_PROTOCOL_REGEX.test(url) ||
                this.TEL_PROTOCOL_REGEX.test(url)));
    }
}
GenericLinkComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkComponentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
GenericLinkComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * This component navigates using [routerLink] attribute when input 'url' is a relative url. Otherwise (when it's absolute), [href] is used.
 */
class GenericLinkComponent {
    constructor(router, service) {
        this.router = router;
        this.service = service;
        /**
         * Used to split url into 2 parts:
         * 1. the path
         * 2. query params + hash fragment
         */
        this.URL_SPLIT = /(^[^#?]*)(.*)/;
        /**
         * Parsed parts of the @Input `url`, when it's a local URL.
         * It should not be used when the `url` is external.
         * @see `url`
         */
        this.routeParts = {};
    }
    isExternalUrl() {
        return this.service.isExternalUrl(this.url);
    }
    get rel() {
        return this.target === '_blank' ? 'noopener' : null;
    }
    ngOnChanges(changes) {
        if (changes['url']) {
            this.setUrlParts(changes['url'].currentValue);
        }
    }
    /**
     * The part with the path of the local url.
     */
    get routerUrl() {
        return this.routeParts.path;
    }
    /**
     * The part with the query params of the local url.
     */
    get queryParams() {
        return this.routeParts.queryParams;
    }
    /**
     * The part with the hash fragment of the local url.
     */
    get fragment() {
        return this.routeParts.fragment ?? undefined;
    }
    /**
     * Parses the given url and sets the property `urlParts` accordingly.
     */
    setUrlParts(url) {
        if (typeof url === 'string') {
            url = this.getAbsoluteUrl(url); // string links in CMS sometimes don't have the leading slash, so fix it here
            this.routeParts = this.splitUrl(url);
        }
        else {
            this.routeParts = { path: url };
        }
    }
    /**
     * Parses the given string into 3 parts:
     * - string path (wrapped in an array to be compatible with Angular syntax for the `routerLink`)
     * - query params (as an object)
     * - hash fragment (string)
     */
    splitUrl(url = '') {
        const { queryParams, fragment } = this.router.parseUrl(url);
        const [, path] = url.match(this.URL_SPLIT) ?? [, ''];
        // wrap path in an array, to have the Angular-like path format
        return { path: [path ?? ''], queryParams, fragment };
    }
    /**
     * Prepends a leading slash to the given URL string, in case it doesn't have it.
     */
    getAbsoluteUrl(url) {
        return url.startsWith('/') ? url : '/' + url;
    }
}
GenericLinkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkComponent, deps: [{ token: i1$2.Router }, { token: GenericLinkComponentService }], target: i0.ɵɵFactoryTarget.Component });
GenericLinkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: GenericLinkComponent, selector: "cx-generic-link", inputs: { url: "url", target: "target", id: "id", class: "class", style: "style", title: "title" }, usesOnChanges: true, ngImport: i0, template: "<!-- https://github.com/angular/angular/issues/24567 -->\n\n<ng-container *ngIf=\"isExternalUrl(); else isLocalUrl\">\n  <a\n    [href]=\"url\"\n    [attr.target]=\"target\"\n    [attr.rel]=\"rel\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-container>\n\n<ng-template #isLocalUrl>\n  <a\n    [routerLink]=\"routerUrl\"\n    [queryParams]=\"queryParams\"\n    [fragment]=\"fragment\"\n    [attr.target]=\"target\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-generic-link', template: "<!-- https://github.com/angular/angular/issues/24567 -->\n\n<ng-container *ngIf=\"isExternalUrl(); else isLocalUrl\">\n  <a\n    [href]=\"url\"\n    [attr.target]=\"target\"\n    [attr.rel]=\"rel\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-container>\n\n<ng-template #isLocalUrl>\n  <a\n    [routerLink]=\"routerUrl\"\n    [queryParams]=\"queryParams\"\n    [fragment]=\"fragment\"\n    [attr.target]=\"target\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1$2.Router }, { type: GenericLinkComponentService }]; }, propDecorators: { url: [{
                type: Input
            }], target: [{
                type: Input
            }], id: [{
                type: Input
            }], class: [{
                type: Input
            }], style: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class GenericLinkModule {
}
GenericLinkModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
GenericLinkModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkModule, declarations: [GenericLinkComponent], imports: [CommonModule, RouterModule], exports: [GenericLinkComponent] });
GenericLinkModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkModule, imports: [CommonModule, RouterModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GenericLinkModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule],
                    declarations: [GenericLinkComponent],
                    exports: [GenericLinkComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Provides a UI to manage the count of the quantity, typically by using
 * increase and decrease functionality. The item counter expects an input `FormControl`
 * so that the state of the control can be managed outside of this component.
 */
class ItemCounterComponent {
    constructor() {
        /**
         * This can be used in case an item has a minmum order quantity.
         * @default 1
         */
        this.min = 1;
        /**
         * The step is used to increment the count. It is supposed to be a
         * positive integer or float.
         * @default 1
         */
        this.step = 1;
        /**
         * Indicates that the input can be manually set to zero,
         * despite the fact that the input controls will be limited to
         * the minimum. The zero value can be used to remove an item.
         */
        this.allowZero = false;
        /**
         * In readonly mode the item counter will only be shown as a label,
         * the form controls are not rendered.
         * Please not that readonly is different from the `disabled` form state.
         * @default false
         */
        this.readonly = false;
    }
    handleClick() {
        this.input.nativeElement.focus();
    }
    ngOnInit() {
        this.sub = this.control.valueChanges
            .pipe(startWith(this.control.value))
            .subscribe((value) => this.control.setValue(this.getValidCount(value), { emitEvent: false }));
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
    increment() {
        // it's too early to use the `stepUp` and `stepDown` API...
        // let's wait for FF: https://caniuse.com/#search=stepUp
        this.control.setValue(this.control.value + this.step);
        this.control.markAsDirty();
    }
    decrement() {
        this.control.setValue(this.control.value - this.step);
        this.control.markAsDirty();
    }
    /**
     * Validate that the given value is in between
     * the `min` and `max` value. If the value is out
     * of  the min/max range, it will be altered.
     * If `allowZero` is set to true, the 0 value is ignored.
     *
     */
    getValidCount(value) {
        if (value < this.min && !(value === 0 && this.allowZero)) {
            value = this.min;
        }
        if (this.max && value > this.max) {
            value = this.max;
        }
        return value;
    }
}
ItemCounterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ItemCounterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ItemCounterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ItemCounterComponent, selector: "cx-item-counter", inputs: { control: "control", min: "min", max: "max", step: "step", allowZero: "allowZero", readonly: "readonly" }, host: { listeners: { "click": "handleClick()" }, properties: { "class.readonly": "this.readonly" } }, viewQueries: [{ propertyName: "input", first: true, predicate: ["qty"], descendants: true }], ngImport: i0, template: "<button\n  type=\"button\"\n  (click)=\"decrement()\"\n  [disabled]=\"control.disabled || control.value <= min\"\n  [tabindex]=\"control.disabled || control.value <= min ? -1 : 0\"\n  attr.aria-label=\"{{ 'itemCounter.removeOne' | cxTranslate }}\"\n>\n  -\n</button>\n<input\n  #qty\n  type=\"number\"\n  [min]=\"min\"\n  [max]=\"max\"\n  [step]=\"step\"\n  [readonly]=\"readonly\"\n  [tabindex]=\"readonly ? -1 : 0\"\n  [formControl]=\"control\"\n  attr.aria-label=\"{{ 'itemCounter.quantity' | cxTranslate }}\"\n/>\n<button\n  type=\"button\"\n  (click)=\"increment()\"\n  [disabled]=\"control.disabled || control.value >= max\"\n  tabindex=\"0\"\n  attr.aria-label=\"{{ 'itemCounter.addOneMore' | cxTranslate }}\"\n>\n  +\n</button>\n", dependencies: [{ kind: "directive", type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3$1.MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: ["min"] }, { kind: "directive", type: i3$1.MaxValidator, selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]", inputs: ["max"] }, { kind: "directive", type: i3$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ItemCounterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-item-counter', template: "<button\n  type=\"button\"\n  (click)=\"decrement()\"\n  [disabled]=\"control.disabled || control.value <= min\"\n  [tabindex]=\"control.disabled || control.value <= min ? -1 : 0\"\n  attr.aria-label=\"{{ 'itemCounter.removeOne' | cxTranslate }}\"\n>\n  -\n</button>\n<input\n  #qty\n  type=\"number\"\n  [min]=\"min\"\n  [max]=\"max\"\n  [step]=\"step\"\n  [readonly]=\"readonly\"\n  [tabindex]=\"readonly ? -1 : 0\"\n  [formControl]=\"control\"\n  attr.aria-label=\"{{ 'itemCounter.quantity' | cxTranslate }}\"\n/>\n<button\n  type=\"button\"\n  (click)=\"increment()\"\n  [disabled]=\"control.disabled || control.value >= max\"\n  tabindex=\"0\"\n  attr.aria-label=\"{{ 'itemCounter.addOneMore' | cxTranslate }}\"\n>\n  +\n</button>\n" }]
        }], propDecorators: { control: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], step: [{
                type: Input
            }], allowZero: [{
                type: Input
            }], readonly: [{
                type: HostBinding,
                args: ['class.readonly']
            }, {
                type: Input
            }], input: [{
                type: ViewChild,
                args: ['qty']
            }], handleClick: [{
                type: HostListener,
                args: ['click']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ItemCounterModule {
}
ItemCounterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ItemCounterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ItemCounterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ItemCounterModule, declarations: [ItemCounterComponent], imports: [CommonModule, ReactiveFormsModule, I18nModule], exports: [ItemCounterComponent] });
ItemCounterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ItemCounterModule, imports: [CommonModule, ReactiveFormsModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ItemCounterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ReactiveFormsModule, I18nModule],
                    declarations: [ItemCounterComponent],
                    exports: [ItemCounterComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NgSelectA11yDirective {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
    }
    ngAfterViewInit() {
        const divCombobox = this.elementRef.nativeElement.querySelector('[role="combobox"]');
        const ariaLabel = this.cxNgSelectA11y.ariaLabel;
        const elementId = this.elementRef.nativeElement.id;
        const ariaControls = this.cxNgSelectA11y.ariaControls ?? elementId;
        if (ariaLabel) {
            this.renderer.setAttribute(divCombobox, 'aria-label', ariaLabel);
        }
        if (ariaControls) {
            this.renderer.setAttribute(divCombobox, 'aria-controls', ariaControls);
        }
    }
}
NgSelectA11yDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NgSelectA11yDirective, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NgSelectA11yDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: NgSelectA11yDirective, selector: "[cxNgSelectA11y]", inputs: { cxNgSelectA11y: "cxNgSelectA11y" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NgSelectA11yDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxNgSelectA11y]',
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }]; }, propDecorators: { cxNgSelectA11y: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SortingComponent {
    constructor() {
        this.sortListEvent = new EventEmitter();
    }
    sortList(sortCode) {
        this.sortListEvent.emit(sortCode);
    }
    get selectedLabel() {
        if (this.selectedOption) {
            return (this.sortOptions?.find((sort) => sort.code === this.selectedOption)
                ?.name ?? this.sortLabels?.[this.selectedOption]);
        }
    }
}
SortingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SortingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SortingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: SortingComponent, selector: "cx-sorting", inputs: { sortOptions: "sortOptions", ariaControls: "ariaControls", ariaLabel: "ariaLabel", selectedOption: "selectedOption", placeholder: "placeholder", sortLabels: "sortLabels" }, outputs: { sortListEvent: "sortListEvent" }, ngImport: i0, template: "<ng-select\n  [searchable]=\"false\"\n  [clearable]=\"false\"\n  placeholder=\"{{ placeholder }}\"\n  (change)=\"sortList($event)\"\n  [ngModel]=\"selectedOption\"\n  [cxNgSelectA11y]=\"{\n    ariaLabel: ariaLabel || ('productList.sortResults' | cxTranslate),\n    ariaControls: ariaControls\n  }\"\n>\n  <ng-option *ngFor=\"let sort of sortOptions\" [value]=\"sort.code\">{{\n    sort.name ? sort.name : sortLabels && sort.code ? sortLabels[sort.code] : ''\n  }}</ng-option>\n</ng-select>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i2.NgSelectComponent, selector: "ng-select", inputs: ["bindLabel", "bindValue", "markFirst", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "appearance", "dropdownPosition", "appendTo", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "openOnEnter", "maxSelectedItems", "groupBy", "groupValue", "bufferAmount", "virtualScroll", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "tabIndex", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "typeahead", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { kind: "component", type: i2.NgOptionComponent, selector: "ng-option", inputs: ["value", "disabled"] }, { kind: "directive", type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: NgSelectA11yDirective, selector: "[cxNgSelectA11y]", inputs: ["cxNgSelectA11y"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SortingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-sorting', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-select\n  [searchable]=\"false\"\n  [clearable]=\"false\"\n  placeholder=\"{{ placeholder }}\"\n  (change)=\"sortList($event)\"\n  [ngModel]=\"selectedOption\"\n  [cxNgSelectA11y]=\"{\n    ariaLabel: ariaLabel || ('productList.sortResults' | cxTranslate),\n    ariaControls: ariaControls\n  }\"\n>\n  <ng-option *ngFor=\"let sort of sortOptions\" [value]=\"sort.code\">{{\n    sort.name ? sort.name : sortLabels && sort.code ? sortLabels[sort.code] : ''\n  }}</ng-option>\n</ng-select>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { sortOptions: [{
                type: Input
            }], ariaControls: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], selectedOption: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], sortLabels: [{
                type: Input
            }], sortListEvent: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NgSelectA11yModule {
}
NgSelectA11yModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NgSelectA11yModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgSelectA11yModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: NgSelectA11yModule, declarations: [NgSelectA11yDirective], exports: [NgSelectA11yDirective] });
NgSelectA11yModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NgSelectA11yModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NgSelectA11yModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgSelectA11yDirective],
                    exports: [NgSelectA11yDirective],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SortingModule {
}
SortingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SortingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SortingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SortingModule, declarations: [SortingComponent], imports: [CommonModule,
        NgSelectModule,
        FormsModule,
        NgSelectA11yModule,
        I18nModule], exports: [SortingComponent] });
SortingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SortingModule, imports: [CommonModule,
        NgSelectModule,
        FormsModule,
        NgSelectA11yModule,
        I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SortingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        NgSelectModule,
                        FormsModule,
                        NgSelectA11yModule,
                        I18nModule,
                    ],
                    declarations: [SortingComponent],
                    exports: [SortingComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultPaginationConfig = {
    pagination: {
        addStart: true,
        addEnd: true,
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PaginationConfig {
}
PaginationConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PaginationConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The item type is used to add semantic structure to the
 * PaginationItem, so that the UI understands the usage.
 */
var PaginationItemType;
(function (PaginationItemType) {
    PaginationItemType["GAP"] = "gap";
    PaginationItemType["FIRST"] = "first";
    PaginationItemType["LAST"] = "last";
    PaginationItemType["PREVIOUS"] = "previous";
    PaginationItemType["NEXT"] = "next";
    PaginationItemType["START"] = "start";
    PaginationItemType["END"] = "end";
    PaginationItemType["PAGE"] = "page";
})(PaginationItemType || (PaginationItemType = {}));
var PaginationNavigationPosition;
(function (PaginationNavigationPosition) {
    PaginationNavigationPosition["ASIDE"] = "aside";
    PaginationNavigationPosition["BEFORE"] = "before";
    PaginationNavigationPosition["AFTER"] = "after";
})(PaginationNavigationPosition || (PaginationNavigationPosition = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const FALLBACK_PAGINATION_OPTIONS = {
    rangeCount: 3,
    dotsLabel: '...',
    startLabel: '«',
    previousLabel: '‹',
    nextLabel: '›',
    endLabel: '»',
};
/**
 * Builds a pagination structures based on a pageCount and current page number.
 * There are various {@link PaginationConfig} options which can be used to configure
 * the behavior of the build. Alternatively, CSS can be used to further customize
 * the pagination.
 *
 * Examples:
 * The full blown pagination items contain the follow elements:
 *
 * `« ‹ 1 ... 4 (5) 6 ... 9 › »`
 *
 * This includes pagination items to the following pages:
 * - start page
 * - previous page
 * - first page
 * - page range
 * - last page
 * - next page
 * - end page
 *
 * All of those links are configurable, including the size of the page range.
 * The current page will always be centered in the page range to provide direct access
 * to the previous and next page.
 */
class PaginationBuilder {
    constructor(paginationConfig) {
        this.paginationConfig = paginationConfig;
    }
    /**
     * Builds a list of `PaginationItem`. The give pageCount and current are used
     * to build out the full pagination. There are various {@link PaginationConfig} options
     * which can be used to configure the behavior of the build. Alternatively, CSS
     * can be used to further specialize visibility of the pagination.
     *
     * @param pageCount The total number of pages
     * @param current The current page number, 0-index based
     * @returns An array of `PaginationItem`
     */
    paginate(pageCount, current) {
        const pages = [];
        if (!pageCount || pageCount < 2) {
            return pages;
        }
        this.addPages(pages, pageCount, current);
        this.addDots(pages, pageCount);
        this.addFirstLast(pages, pageCount);
        this.addNavigation(pages, pageCount, current);
        return pages;
    }
    /**
     * Returns the current page with surrounding pages (based on the `config.rangeCount`).
     * The current page is always centered to provide direct access to the previous and next page.
     *
     * @param pages The list of page items that is used to amend
     * @param pageCount The total number of pages
     * @param current The current page number, 0-index based
     */
    addPages(pages, pageCount, current) {
        const start = this.getStartOfRange(pageCount, current);
        if (this.config.rangeCount !== undefined && start !== null) {
            const max = Math.min(this.config.rangeCount, pageCount);
            Array.from(Array(max)).forEach((_, i) => {
                pages.push({
                    number: i + start,
                    label: String(i + start + 1),
                    type: PaginationItemType.PAGE,
                });
            });
        }
    }
    /**
     * Adds dots before and after the given pages, if configured (defaults to true).
     * If the dots only represent a single page, the page number is added instead of
     * the dots, unless the configuration requires dots always.
     *
     * @param pages The list of page items that is used to amend
     * @param pageCount The total number of pages
     */
    addDots(pages, pageCount) {
        if (!this.config.addDots) {
            return;
        }
        pages.unshift(...this.addFirstGapToDots(pages));
        pages.push(...this.addLastGapToDots(pages, pageCount));
    }
    /**
     * Helper method for addDots() whether to add the first gap.
     */
    addFirstGapToDots(pages) {
        const firstItemNumber = pages[0].number;
        const gapNumber = Number(this.config.addFirst);
        if (firstItemNumber !== undefined && firstItemNumber > gapNumber) {
            const isGap = !this.config.substituteDotsForSingularPage ||
                firstItemNumber !== gapNumber + 1;
            const isSubstituted = this.config.addFirst &&
                this.config.substituteDotsForSingularPage &&
                gapNumber === 0;
            const type = isGap
                ? PaginationItemType.GAP
                : isSubstituted
                    ? PaginationItemType.FIRST
                    : PaginationItemType.PAGE;
            return [
                Object.assign({
                    label: isGap ? this.config.dotsLabel : String(gapNumber + 1),
                    type,
                }, isGap ? null : { number: gapNumber }),
            ];
        }
        else {
            return [];
        }
    }
    /**
     * Helper method for addDots() whether to add the last gap.
     */
    addLastGapToDots(pages, pageCount) {
        const pageNumber = pages[pages.length - 1].number;
        const nextPageNumber = pageNumber ? pageNumber + 1 : undefined;
        const last = pageCount - (Number(this.config.addLast) + 1);
        if (nextPageNumber && nextPageNumber <= last) {
            const isSubstituted = this.config.addLast &&
                this.config.substituteDotsForSingularPage &&
                nextPageNumber === last;
            const isGap = nextPageNumber <
                pageCount -
                    Number(this.config.substituteDotsForSingularPage) -
                    Number(this.config.addLast);
            const type = isGap
                ? PaginationItemType.GAP
                : isSubstituted
                    ? PaginationItemType.LAST
                    : PaginationItemType.PAGE;
            return [
                Object.assign({
                    label: isGap ? this.config.dotsLabel : String(nextPageNumber + 1),
                    type,
                }, isGap ? null : { number: nextPageNumber }),
            ];
        }
        else {
            return [];
        }
    }
    /**
     * Add links to the first and last page, if configured to do so.
     *
     * @param pages The list of page items that is used to amend
     * @param pageCount The total number of pages
     *
     */
    addFirstLast(pages, pageCount) {
        if (this.config.addFirst && pages[0].number !== 0) {
            pages.unshift({
                number: 0,
                label: '1',
                type: PaginationItemType.FIRST,
            });
        }
        if (this.config.addLast &&
            pages[pages.length - 1].number !== pageCount - 1) {
            pages.push({
                number: pageCount - 1,
                label: String(pageCount),
                type: PaginationItemType.LAST,
            });
        }
    }
    /**
     * Add links to the start, previous, next and last page, if configured to do so.
     * The order of the links can be configured by using the {@link PaginationConfig},
     * using the `PaginationNavigationPosition` (`BEFORE` or `AFTER`).
     * The `PaginationNavigationPosition` allows for 3 flavours:
     *
     * - by default the pagination starts with start and previous and ends with the next and end links
     * - BEFORE – all navigation links are added in the front of the pagination list
     * - AFTER – all navigation links are pushed to the end of the pagination list
     *
     * @param pages The list of page items that is used to amend
     * @param pageCount The total number of pages
     * @param current The current page number, 0-index based
     *
     */
    addNavigation(pages, pageCount, current) {
        const before = this.getBeforeLinks(current);
        const after = this.getAfterLinks(pageCount, current);
        const pos = this.config.navigationPosition;
        if (!pos || pos === PaginationNavigationPosition.ASIDE) {
            pages.unshift(...before);
            pages.push(...after);
        }
        else {
            if (pos === PaginationNavigationPosition.BEFORE) {
                pages.unshift(...before, ...after);
            }
            if (pos === PaginationNavigationPosition.AFTER) {
                pages.push(...before, ...after);
            }
        }
    }
    /**
     * Returns the start and previous links, if applicable.
     */
    getBeforeLinks(current) {
        const list = [];
        if (this.config.addStart) {
            const start = () => {
                return Object.assign({
                    label: this.config.startLabel,
                    type: PaginationItemType.START,
                }, current > 0 ? { number: 0 } : null);
            };
            list.push(start());
        }
        if (this.config.addPrevious) {
            const previous = () => {
                return Object.assign({
                    label: this.config.previousLabel,
                    type: PaginationItemType.PREVIOUS,
                }, current > 0 ? { number: current - 1 } : null);
            };
            list.push(previous());
        }
        return list;
    }
    /**
     * Returns the next and end links, if applicable.
     */
    getAfterLinks(pageCount, current) {
        const list = [];
        if (this.config.addNext) {
            const next = () => {
                return Object.assign({
                    label: this.config.nextLabel,
                    type: PaginationItemType.NEXT,
                }, current < pageCount - 1 ? { number: current + 1 } : null);
            };
            list.push(next());
        }
        if (this.config.addEnd) {
            const end = () => {
                return Object.assign({
                    label: this.config.endLabel,
                    type: PaginationItemType.END,
                }, current < pageCount - 1 ? { number: pageCount - 1 } : null);
            };
            list.push(end());
        }
        return list;
    }
    /**
     * Resolves the first page of the range we need to build.
     * This is the page that is leading up to the range of the
     * current page.
     *
     * @param pageCount The total number of pages.
     * @param current The current page number, 0-index based.
     */
    getStartOfRange(pageCount, current) {
        if (this.config.rangeCount !== undefined) {
            const count = this.config.rangeCount - 1;
            // the least number of pages before and after the current
            const delta = Math.round(count / 2);
            // ensure that we start with at least the first page
            const minStart = Math.max(0, current - delta);
            // ensures that we start with at least 1 and do not pass the last range
            const maxStart = Math.max(0, pageCount - count - 1);
            // ensure that we get at least a full range at the end
            return Math.min(maxStart, minStart);
        }
        return null;
    }
    /**
     * Returns the pagination configuration. The configuration is driven by the
     * (default) application configuration.
     *
     * The default application is limited to adding the start and end link:
     * ```ts
     *   addStart: true,
     *   addEnd: true
     * ```
     *
     * The application configuration is however merged into the following static configuration:
     * ```ts
     * {
     *   rangeCount: 3,
     *   dotsLabel: '...',
     *   startLabel: '«',
     *   previousLabel: '‹',
     *   nextLabel: '›',
     *   endLabel: '»'
     * }
     * ```
     */
    get config() {
        return Object.assign(FALLBACK_PAGINATION_OPTIONS, this.paginationConfig.pagination);
    }
}
PaginationBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationBuilder, deps: [{ token: PaginationConfig }], target: i0.ɵɵFactoryTarget.Injectable });
PaginationBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: PaginationConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The `PaginationComponent` is a generic component that is used for
 * all lists in Spartacus that require pagination. The component supports
 * all common features, which can be configured or hidden by CSS.
 */
class PaginationComponent {
    get pagination() {
        return this._pagination;
    }
    set pagination(value) {
        if (value) {
            this._pagination = value;
            this.render(value);
        }
    }
    constructor(paginationBuilder, activatedRoute) {
        this.paginationBuilder = paginationBuilder;
        this.activatedRoute = activatedRoute;
        /** The (optional) pageRoute used for the anchor links created in the pagination   */
        this.pageRoute = '.';
        this.viewPageEvent = new EventEmitter();
        this.pages = [];
    }
    render(pagination) {
        if (!pagination) {
            return;
        }
        this.pages = this.paginationBuilder.paginate(pagination.totalPages ?? 0, pagination.currentPage ?? 0);
    }
    /**
     * Format aria-label based on pagination item type.
     *
     * @param label string
     * @param type PaginationItemType
     * @returns string
     */
    getAriaLabel(label, type) {
        // Convert 'Start' to First, and 'End' to Last for a more natural screen read.
        type = type === PaginationItemType.START ? PaginationItemType.FIRST : type;
        type = type === PaginationItemType.END ? PaginationItemType.LAST : type;
        return type === PaginationItemType.PAGE
            ? `${type} ${label}`
            : `${type} ${PaginationItemType.PAGE}`;
    }
    /**
     * Indicates whether the given item is the current item.
     *
     * @param item PaginationItem
     * @returns boolean
     */
    isCurrent(item) {
        return (item.type === PaginationItemType.PAGE &&
            item.number === this.pagination.currentPage);
    }
    /**
     * Indicates whether the pagination item is inactive. This is used
     * to disabled a link or set the tabindex to `-1`.
     *
     * Defaults to true
     *
     * @param item PaginationItem
     * @returns returns -1 in case of a disabled
     */
    isInactive(item) {
        return (!item.hasOwnProperty('number') ||
            item.number === this.pagination.currentPage);
    }
    getQueryParams(item) {
        const queryParams = Object.assign({}, this.activatedRoute.snapshot.queryParams);
        if (this.queryParam &&
            item.number !== undefined &&
            this.pagination.totalPages !== undefined &&
            item.number < this.pagination.totalPages &&
            !this.isCurrent(item)) {
            queryParams[this.queryParam] = item.number;
        }
        // omit the page number from the query parameters in case it's the default
        // to clean up the experience and avoid unnecessary polluting of the URL
        if (queryParams[this.queryParam] === this.defaultPage) {
            delete queryParams[this.queryParam];
        }
        return queryParams;
    }
    pageChange(page) {
        this.viewPageEvent.emit(page.number);
    }
}
PaginationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationComponent, deps: [{ token: PaginationBuilder }, { token: i1$2.ActivatedRoute }], target: i0.ɵɵFactoryTarget.Component });
PaginationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PaginationComponent, selector: "cx-pagination", inputs: { pageRoute: "pageRoute", queryParam: "queryParam", defaultPage: "defaultPage", pagination: "pagination" }, outputs: { viewPageEvent: "viewPageEvent" }, ngImport: i0, template: "<a\n  *ngFor=\"let item of pages\"\n  [class]=\"item.type\"\n  [class.disabled]=\"isInactive(item)\"\n  [class.current]=\"isCurrent(item)\"\n  [routerLink]=\"pageRoute\"\n  [queryParams]=\"getQueryParams(item)\"\n  [tabIndex]=\"isInactive(item) ? -1 : 0\"\n  (click)=\"pageChange(item)\"\n  [attr.aria-label]=\"getAriaLabel(item.label, item.type)\"\n>\n  {{ item.label }}\n</a>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-pagination', changeDetection: ChangeDetectionStrategy.OnPush, template: "<a\n  *ngFor=\"let item of pages\"\n  [class]=\"item.type\"\n  [class.disabled]=\"isInactive(item)\"\n  [class.current]=\"isCurrent(item)\"\n  [routerLink]=\"pageRoute\"\n  [queryParams]=\"getQueryParams(item)\"\n  [tabIndex]=\"isInactive(item) ? -1 : 0\"\n  (click)=\"pageChange(item)\"\n  [attr.aria-label]=\"getAriaLabel(item.label, item.type)\"\n>\n  {{ item.label }}\n</a>\n" }]
        }], ctorParameters: function () { return [{ type: PaginationBuilder }, { type: i1$2.ActivatedRoute }]; }, propDecorators: { pageRoute: [{
                type: Input
            }], queryParam: [{
                type: Input
            }], defaultPage: [{
                type: Input
            }], pagination: [{
                type: Input
            }], viewPageEvent: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PaginationModule {
}
PaginationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PaginationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PaginationModule, declarations: [PaginationComponent], imports: [CommonModule, RouterModule], exports: [PaginationComponent] });
PaginationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationModule, providers: [provideDefaultConfig(defaultPaginationConfig)], imports: [CommonModule, RouterModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaginationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule],
                    providers: [provideDefaultConfig(defaultPaginationConfig)],
                    declarations: [PaginationComponent],
                    exports: [PaginationComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TotalComponent {
    get pagination() {
        return this._pagination;
    }
    set pagination(paginationModel) {
        this._pagination = paginationModel ?? { totalResults: 0 };
    }
    /**
     * Current page, starting form page 0
     * */
    get currentPage() {
        return this.pagination?.currentPage ?? 0;
    }
    get pageSize() {
        return this.pagination?.pageSize ?? 0;
    }
    get totalResults() {
        return this.pagination?.totalResults ?? 0;
    }
    get fromItem() {
        return this.currentPage * this.pageSize + 1;
    }
    get toItem() {
        const lastItem = (this.currentPage + 1) * this.pageSize;
        return lastItem > this.totalResults ? this.totalResults : lastItem;
    }
}
TotalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TotalComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TotalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: TotalComponent, selector: "cx-total", inputs: { pagination: "pagination" }, ngImport: i0, template: "<ng-container *ngIf=\"totalResults > 0\">\n  <div>{{ totalResults }} {{ 'common.results' | cxTranslate }}</div>\n  <div class=\"cx-vertical-line-separator\"></div>\n  <div>\n    {{ fromItem }}-{{ toItem }} {{ 'common.of' | cxTranslate }}\n    {{ totalResults }}\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TotalComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-total', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"totalResults > 0\">\n  <div>{{ totalResults }} {{ 'common.results' | cxTranslate }}</div>\n  <div class=\"cx-vertical-line-separator\"></div>\n  <div>\n    {{ fromItem }}-{{ toItem }} {{ 'common.of' | cxTranslate }}\n    {{ totalResults }}\n  </div>\n</ng-container>\n" }]
        }], propDecorators: { pagination: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TotalModule {
}
TotalModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TotalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TotalModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: TotalModule, declarations: [TotalComponent], imports: [CommonModule, FormsModule, I18nModule], exports: [TotalComponent] });
TotalModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TotalModule, imports: [CommonModule, FormsModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TotalModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, FormsModule, I18nModule],
                    declarations: [TotalComponent],
                    exports: [TotalComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ListNavigationModule {
}
ListNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ListNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ListNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ListNavigationModule, imports: [CommonModule,
        NgSelectModule,
        FormsModule,
        ReactiveFormsModule,
        IconModule,
        PaginationModule,
        SortingModule,
        TotalModule], exports: [SortingComponent, PaginationComponent, TotalComponent] });
ListNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ListNavigationModule, imports: [CommonModule,
        NgSelectModule,
        FormsModule,
        ReactiveFormsModule,
        IconModule,
        PaginationModule,
        SortingModule,
        TotalModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ListNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        NgSelectModule,
                        FormsModule,
                        ReactiveFormsModule,
                        IconModule,
                        PaginationModule,
                        SortingModule,
                        TotalModule,
                    ],
                    exports: [SortingComponent, PaginationComponent, TotalComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Provides configuration specific to Media, such as images. This is used to optimize
 * rendering of the media, SEO and performance.
 */
class MediaConfig {
}
MediaConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MediaConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MediaConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProgressButtonComponent {
    constructor() {
        this.ariaLabel = '';
        this.class = '';
        this.disabled = false;
        this.loading = false;
        this.clickEvent = new EventEmitter();
        // Intentional empty constructor
    }
}
ProgressButtonComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProgressButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ProgressButtonComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProgressButtonComponent, selector: "cx-progress-button", inputs: { ariaLabel: "ariaLabel", class: "class", disabled: "disabled", loading: "loading" }, outputs: { clickEvent: "clickEvent" }, ngImport: i0, template: "<button\n  (click)=\"clickEvent.emit()\"\n  [attr.aria-label]=\"ariaLabel\"\n  [disabled]=\"disabled || loading\"\n  [ngClass]=\"class\"\n  class=\"btn btn-primary\"\n>\n  <div class=\"cx-progress-button-container\">\n    <div *ngIf=\"loading\" class=\"loader-container\">\n      <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n    </div>\n    <ng-content></ng-content>\n  </div>\n</button>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProgressButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-progress-button', template: "<button\n  (click)=\"clickEvent.emit()\"\n  [attr.aria-label]=\"ariaLabel\"\n  [disabled]=\"disabled || loading\"\n  [ngClass]=\"class\"\n  class=\"btn btn-primary\"\n>\n  <div class=\"cx-progress-button-container\">\n    <div *ngIf=\"loading\" class=\"loader-container\">\n      <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n    </div>\n    <ng-content></ng-content>\n  </div>\n</button>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { ariaLabel: [{
                type: Input
            }], class: [{
                type: Input
            }], disabled: [{
                type: Input
            }], loading: [{
                type: Input
            }], clickEvent: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProgressButtonModule {
}
ProgressButtonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProgressButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProgressButtonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProgressButtonModule, declarations: [ProgressButtonComponent], imports: [CommonModule, I18nModule], exports: [ProgressButtonComponent] });
ProgressButtonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProgressButtonModule, imports: [CommonModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProgressButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    declarations: [ProgressButtonComponent],
                    exports: [ProgressButtonComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Supposed to be injected in the split view component, so that the split view state
 * is maintained for a single split view.
 */
class SplitViewService {
    constructor() {
        /**
         * Newly added views are hidden by default, unless it is the first view of the split view.
         * The default hide mode can be overridden.
         */
        this.defaultHideMode = true;
        this.splitViewCount = 1;
        this._views$ = new BehaviorSubject([]);
    }
    /**
     * Adds a view to the list of views. The view is initialized with the `SplitViewState`
     * state. If no state is provided, the state is created with the hidden property. The hidden
     * property is provided by the `defaultHideMode`, unless it's the first view (position: 0).
     */
    add(position, initialState) {
        const state = {
            ...{ hidden: position === 0 ? false : this.defaultHideMode },
            ...initialState,
        };
        if (!this.views[position]) {
            this.views[position] = state;
            this.updateState(position, state.hidden);
            this._views$.next(this.views);
        }
    }
    /**
     * The split view is based on a number of views that can be used next to each other.
     * When the number changes (i.e. if the screen goes from wide to small), the visibility state
     * of the views should be updated.
     */
    updateSplitView(splitViewCount) {
        if (splitViewCount !== this.splitViewCount) {
            this.splitViewCount = splitViewCount;
            this.updateState();
        }
    }
    /**
     * Returns an observable with the active view number. The active view number
     * represents the last visible view.
     */
    getActiveView() {
        return this._views$.pipe(map((views) => this.getActive(views)), distinctUntilChanged());
    }
    /**
     * Returns an observable with the SplitViewState for the given view position.
     */
    getViewState(position) {
        return this._views$.pipe(map((views) => views[position]), 
        // we must filter here, since outlet driven views will destroyed the view
        filter((view) => Boolean(view)));
    }
    /**
     * Removes a view from the list of views.
     *
     * Removing a view is different from hiding a view. Removing a view is typically done
     * when a component is destroyed.
     *
     * When the view is removed, the SplitViewState is updated to reflect that new organization
     * of views.
     */
    remove(position) {
        const activePosition = this.getActive(this.views);
        this._views$.next(this.views.splice(0, position));
        if (activePosition >= position) {
            this.updateState(position);
        }
    }
    /**
     * Returns the next view position. This is useful for views that do not want to be bothered
     * with controlling view numbers.
     */
    get nextPosition() {
        return this.views.length || 0;
    }
    /**
     * Toggles the visibility of the views based on the given view position. If the view
     * is already visible, we close the view and active the former view. Unless the hide flag
     * is used, to force the view.
     *
     * The view state of other views in the split view are updated as well.
     *
     * @param position The zero-based position number of the view.
     * @param forceHide The (optional) hide state for the view position.
     */
    toggle(position, forceHide) {
        // add the view if it hasn't been added before.
        if (!this.views[position]) {
            this.add(position, { hidden: forceHide ?? false });
        }
        // If the position is already visible, we move to a previous position. Only if the hide
        // state is forced, we keep the current position.
        if (this.views[position] &&
            forceHide === undefined &&
            !this.views[position].hidden) {
            position--;
        }
        this.updateState(position, forceHide === true);
    }
    /**
     * Updates the hidden state of all the views.
     */
    updateState(position, hide) {
        const views = [...this.views];
        if (hide !== undefined && position && views[position]) {
            views[position].hidden = hide;
        }
        let lastVisible = views.length - [...views].reverse().findIndex((view) => !view.hidden) - 1;
        if (lastVisible === views.length) {
            if (position) {
                // When there's only 1 view (mobile), we might not find any active
                // if the user navigates back.
                lastVisible = position - 1;
            }
            else {
                lastVisible = views.length - 1;
            }
        }
        views.forEach((view, pos) => {
            if (view && pos !== position) {
                // hide other views that are outside the split view
                view.hidden =
                    pos > lastVisible || pos < lastVisible - (this.splitViewCount - 1);
            }
        });
        this._views$.next(views);
    }
    /**
     * Returns the active view count for the list of views.
     */
    getActive(views) {
        // we reverse the list to find the last visible view
        const l = [...views]
            .reverse()
            .findIndex((view) => !view.hidden);
        const last = l === -1 ? 0 : views.length - l - 1;
        return last;
    }
    /**
     * Utility method that resolves all views from the subject.
     */
    get views() {
        return this._views$.value;
    }
}
SplitViewService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SplitViewService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SplitViewService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SplitViewService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SplitViewService, decorators: [{
            type: Injectable
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The split-view component supports an unlimited number of nested views. The component
 * is a host to those view components and doesn't add any restrictions to it's content;
 * content is projected as-is.
 *
 * ```html
 * <cx-split-view>
 *   <cx-view></cx-view>
 *   <cx-view></cx-view>
 *   <any-wrapper>
 *     <cx-view></cx-view>
 *   </any-wrapper>
 * </cx-split-view>
 * ```
 *
 * The split view component is only concerned with tracking the underlying _visible_
 * view components, so that the `lastVisibleView` can be updated accordingly. The actual
 * visibility of views is controlled by CSS. To allow for maximum flexibility, the CSS
 * implementation is using CSS variables. The `lastVisibleView` is bind to the
 * `--cx-active-view` on the host, so that all descendants views will inherit the
 * property conveniently.
 */
class SplitViewComponent {
    /**
     * Sets the default hide mode for views. This mode is useful in case views are dynamically being created,
     * for example when they are created by router components.
     *
     * The mode defaults to true, unless this is the first view; the first view is never hidden.
     */
    set hideMode(mode) {
        this.splitService.defaultHideMode = mode;
    }
    constructor(splitService, breakpointService, elementRef) {
        this.splitService = splitService;
        this.breakpointService = breakpointService;
        this.elementRef = elementRef;
        this.subscription = new Subscription();
        /**
         * Indicates the last visible view in the range of views that is visible. This
         * is bind to a css variable `--cx-active-view` so that the experience
         * can be fully controlled by css.
         */
        this.lastVisibleView = 1;
    }
    ngOnInit() {
        this.subscription.add(this.splitService
            .getActiveView()
            .subscribe((lastVisible) => (this.lastVisibleView = lastVisible + 1)));
        this.subscription.add(this.breakpointService.breakpoint$.subscribe(() => {
            this.splitService.updateSplitView(this.splitViewCount);
        }));
    }
    /**
     * Returns the maximum number of views per split-view. The number is based on the
     * CSS custom property `--cx-max-views`.
     */
    get splitViewCount() {
        return Number(getComputedStyle(this.elementRef.nativeElement).getPropertyValue('--cx-max-views'));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
SplitViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SplitViewComponent, deps: [{ token: SplitViewService }, { token: BreakpointService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
SplitViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: SplitViewComponent, selector: "cx-split-view", inputs: { hideMode: "hideMode" }, host: { properties: { "style.--cx-active-view": "this.lastVisibleView", "attr.active-view": "this.lastVisibleView" } }, providers: [SplitViewService], ngImport: i0, template: "<ng-content></ng-content>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SplitViewComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-split-view', changeDetection: ChangeDetectionStrategy.OnPush, providers: [SplitViewService], template: "<ng-content></ng-content>\n" }]
        }], ctorParameters: function () { return [{ type: SplitViewService }, { type: BreakpointService }, { type: i0.ElementRef }]; }, propDecorators: { hideMode: [{
                type: Input
            }], lastVisibleView: [{
                type: HostBinding,
                args: ['style.--cx-active-view']
            }, {
                type: HostBinding,
                args: ['attr.active-view']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The view component is part of the `SplitViewComponent`. The view
 * contains the navigable content that should be split up. It maintains
 * a view position and allows to show or hide the view.
 *
 * The ViewComponent interacts with the `SplitViewService` for handing over the
 * view state, so that the overarching `SplitViewComponent` can manage the
 * overall experience.
 */
class ViewComponent {
    /**
     * The hidden input is used to set the initial visible state of the view.
     * The hidden state defaults to false.
     *
     * The hidden input supports 2-way binding, see `hiddenChange` property.
     */
    set hidden(hidden) {
        this._hidden = hidden;
        this.splitService.toggle(this.viewPosition, hidden);
    }
    constructor(splitService, elementRef, cd) {
        this.splitService = splitService;
        this.elementRef = elementRef;
        this.cd = cd;
        /**
         * The disappeared flag is added to the
         */
        this.disappeared = true;
        /**
         * An update of the view visibility is emitted to the hiddenChange output.
         */
        this.hiddenChange = new EventEmitter();
    }
    ngOnInit() {
        const hidden = this._hidden ? { hidden: this._hidden } : {};
        this.splitService.add(this.viewPosition, hidden);
        this.subscription = this.splitService
            .getViewState(this.viewPosition)
            // delay the disappeared state, so that the (CSS driven) animation has time to finish
            .pipe(delayWhen((view) => timer(view.hidden ? this.duration * 1.25 : 0)))
            .subscribe((view) => {
            this.hiddenChange.emit(view.hidden);
            this._hidden = view.hidden;
            this.disappeared = view.hidden;
            this.cd.markForCheck();
        });
    }
    /**
     * Toggles the visibility of the view.
     *
     * An optional force flag can be used to explicitly show or hide view component.
     */
    toggle(force) {
        this.splitService.toggle(this.viewPosition, force);
    }
    /**
     * Returns the position for the view.
     *
     * The position is either taken from the input `position` or generated by the `SplitService`.
     */
    get viewPosition() {
        if (!(Number(this.position) >= 0)) {
            this.position = this.splitService.nextPosition.toString();
        }
        return Number(this.position);
    }
    /**
     * Returns the duration in milliseconds. The duration is based on the CSS custom property
     * `--cx-transition-duration`. Defaults to 300 milliseconds.
     */
    get duration() {
        const duration = getComputedStyle(this.elementRef.nativeElement)
            .getPropertyValue('--cx-transition-duration')
            .trim();
        if (duration.indexOf('ms') > -1) {
            return Number(duration.split('ms')[0]);
        }
        else if (duration.indexOf('s') > -1) {
            return Number(duration.split('s')[0]) * 1000;
        }
        else {
            return 300;
        }
    }
    /**
     * The view is removed from the `SplitService` so that the view no longer
     * plays a role in the overall split view.
     */
    ngOnDestroy() {
        this.splitService.remove(this.viewPosition);
        this.subscription?.unsubscribe();
    }
}
ViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ViewComponent, deps: [{ token: SplitViewService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ViewComponent, selector: "cx-view", inputs: { position: "position", hidden: "hidden" }, outputs: { hiddenChange: "hiddenChange" }, host: { properties: { "attr.position": "this.position", "style.--cx-view-position": "this.position", "attr.disappeared": "this.disappeared" } }, ngImport: i0, template: "<ng-content></ng-content>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ViewComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-view', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-content></ng-content>\n" }]
        }], ctorParameters: function () { return [{ type: SplitViewService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { position: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.position']
            }, {
                type: HostBinding,
                args: ['style.--cx-view-position']
            }], disappeared: [{
                type: HostBinding,
                args: ['attr.disappeared']
            }], hidden: [{
                type: Input
            }], hiddenChange: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The split-view component supports an unlimited number of nested views. Nested views are rendered
 * next to each other. The views can be rendered next to each other, but the max number of visible
 * views can be limisted as well. This is configurable in the CSS layer, so that the max number of views
 * per split-view can be different for each component.
 *
 * The basic structure of the split-view component is shown below:
 *
 *
 * ```
 * <cx-split-view>
 * </cx-split-view>
 * ```
 *
 * The UX pattern used for the split-view is driven by an initial view, which gets splitted into
 * more views as soon as the user starts interacting with the initial and subsequantial views.
 * The views can be driven by routes, which means that you can navigate through the splitted views
 * by using the browser history as well as share or bookmark splitted views.
 *
 * The UI is implemented in the style layer, with only a few generic style rules. Most of the split
 * view style is driven by CSS properties, so that alternative split-view styles can be introduced
 * per page or component.
 *
 * The max number of views per split-view on mobile is limited to 1 by default, where as on tablet
 * (and higher) it is set to 2. Spartacus has a pretty narrow layout, which is why 2 is maximum,
 * but customers could alter the layout to bring in more views in the same split-view at the time.
 *
 */
class SplitViewModule {
}
SplitViewModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SplitViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SplitViewModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SplitViewModule, declarations: [SplitViewComponent, ViewComponent], imports: [CommonModule, RouterModule], exports: [SplitViewComponent, ViewComponent] });
SplitViewModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SplitViewModule, imports: [CommonModule, RouterModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SplitViewModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [SplitViewComponent, ViewComponent],
                    imports: [CommonModule, RouterModule],
                    exports: [SplitViewComponent, ViewComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class GlobalMessageComponent {
    constructor(globalMessageService) {
        this.globalMessageService = globalMessageService;
        this.iconTypes = ICON_TYPE;
        this.messageType = GlobalMessageType;
    }
    ngOnInit() {
        this.messages$ = this.globalMessageService.get();
    }
    clear(type, index) {
        this.globalMessageService.remove(type, index);
    }
}
GlobalMessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GlobalMessageComponent, deps: [{ token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Component });
GlobalMessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: GlobalMessageComponent, selector: "cx-global-message", ngImport: i0, template: "<div *ngIf=\"messages$ | async as messages\">\n  <div\n    class=\"cx-visually-hidden\"\n    *ngFor=\"let assistiveMsg of messages[messageType.MSG_TYPE_ASSISTIVE]\"\n  >\n    <span>{{ assistiveMsg | cxTranslate }}</span>\n  </div>\n  <div\n    class=\"alert alert-success\"\n    *ngFor=\"\n      let confMsg of messages[messageType.MSG_TYPE_CONFIRMATION];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.SUCCESS\"></cx-icon>\n    </span>\n    <span>{{ confMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_CONFIRMATION, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-info\"\n    *ngFor=\"let infoMsg of messages[messageType.MSG_TYPE_INFO]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_INFO, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-warning\"\n    *ngFor=\"\n      let infoMsg of messages[messageType.MSG_TYPE_WARNING];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.WARNING\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_WARNING, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-danger\"\n    *ngFor=\"let errorMsg of messages[messageType.MSG_TYPE_ERROR]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.ERROR\"></cx-icon>\n    </span>\n    <span>{{ errorMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_ERROR, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GlobalMessageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-global-message', template: "<div *ngIf=\"messages$ | async as messages\">\n  <div\n    class=\"cx-visually-hidden\"\n    *ngFor=\"let assistiveMsg of messages[messageType.MSG_TYPE_ASSISTIVE]\"\n  >\n    <span>{{ assistiveMsg | cxTranslate }}</span>\n  </div>\n  <div\n    class=\"alert alert-success\"\n    *ngFor=\"\n      let confMsg of messages[messageType.MSG_TYPE_CONFIRMATION];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.SUCCESS\"></cx-icon>\n    </span>\n    <span>{{ confMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_CONFIRMATION, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-info\"\n    *ngFor=\"let infoMsg of messages[messageType.MSG_TYPE_INFO]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_INFO, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-warning\"\n    *ngFor=\"\n      let infoMsg of messages[messageType.MSG_TYPE_WARNING];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.WARNING\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_WARNING, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-danger\"\n    *ngFor=\"let errorMsg of messages[messageType.MSG_TYPE_ERROR]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.ERROR\"></cx-icon>\n    </span>\n    <span>{{ errorMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_ERROR, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.GlobalMessageService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class GlobalMessageComponentModule {
}
GlobalMessageComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GlobalMessageComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
GlobalMessageComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: GlobalMessageComponentModule, declarations: [GlobalMessageComponent], imports: [CommonModule, IconModule, I18nModule], exports: [GlobalMessageComponent] });
GlobalMessageComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GlobalMessageComponentModule, imports: [CommonModule, IconModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: GlobalMessageComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IconModule, I18nModule],
                    declarations: [GlobalMessageComponent],
                    exports: [GlobalMessageComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MessageComponent {
    constructor() {
        this.showBody = false;
        this.isVisibleCloseButton = true;
        this.closeMessage = new EventEmitter();
        this.buttonAction = new EventEmitter();
        this.iconTypes = ICON_TYPE;
        // Intentional empty constructor
    }
    get getCssClassesForMessage() {
        return {
            'cx-message-success': this.type === GlobalMessageType.MSG_TYPE_CONFIRMATION,
            'cx-message-info': this.type === GlobalMessageType.MSG_TYPE_INFO,
            'cx-message-warning': this.type === GlobalMessageType.MSG_TYPE_WARNING,
            'cx-message-danger': this.type === GlobalMessageType.MSG_TYPE_ERROR,
        };
    }
    get getIconType() {
        switch (this.type) {
            case GlobalMessageType.MSG_TYPE_WARNING:
                return ICON_TYPE.WARNING;
            case GlobalMessageType.MSG_TYPE_ERROR:
                return ICON_TYPE.ERROR;
            case GlobalMessageType.MSG_TYPE_INFO:
                return ICON_TYPE.INFO;
            default:
                return ICON_TYPE.SUCCESS;
        }
    }
}
MessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MessageComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: MessageComponent, selector: "cx-message", inputs: { text: "text", actionButtonText: "actionButtonText", actionButtonMessage: "actionButtonMessage", accordionText: "accordionText", showBody: "showBody", isVisibleCloseButton: "isVisibleCloseButton", type: "type" }, outputs: { closeMessage: "closeMessage", buttonAction: "buttonAction" }, ngImport: i0, template: "<div [ngClass]=\"getCssClassesForMessage\" class=\"cx-message\">\n  <div class=\"cx-message-content\">\n    <div class=\"cx-message-header\">\n      <span class=\"cx-message-icon\">\n        <cx-icon [type]=\"getIconType\"></cx-icon>\n      </span>\n\n      <span class=\"cx-message-text\">\n        {{ text }}\n        <button\n          *ngIf=\"accordionText\"\n          (click)=\"showBody = !showBody\"\n          [attr.aria-expanded]=\"showBody\"\n          [attr.aria-label]=\"accordionText\"\n          aria-hidden=\"true\"\n          class=\"cx-message-accordion-button link cx-action-link\"\n          type=\"button\"\n        >\n          {{ accordionText }}\n          <cx-icon\n            [type]=\"showBody ? 'CARET_UP' : 'CARET_DOWN'\"\n            class=\"cx-message-accordion-icon\"\n          ></cx-icon>\n        </button>\n\n        <button\n          *ngIf=\"actionButtonText\"\n          (click)=\"buttonAction.emit()\"\n          [cxAtMessage]=\"actionButtonMessage\"\n          aria-hidden=\"true\"\n          class=\"btn btn-link cx-action-link\"\n          type=\"button\"\n        >\n          {{ actionButtonText }}\n        </button>\n      </span>\n\n      <button\n        *ngIf=\"isVisibleCloseButton\"\n        (click)=\"closeMessage.emit()\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        [cxAtMessage]=\"'common.close' | cxTranslate\"\n        aria-hidden=\"true\"\n        class=\"close\"\n        type=\"button\"\n      >\n        <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n      </button>\n    </div>\n\n    <div *ngIf=\"showBody || !accordionText\" class=\"cx-message-body\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: AtMessageDirective, selector: "[cxAtMessage]", inputs: ["cxAtMessage"] }, { kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MessageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-message', template: "<div [ngClass]=\"getCssClassesForMessage\" class=\"cx-message\">\n  <div class=\"cx-message-content\">\n    <div class=\"cx-message-header\">\n      <span class=\"cx-message-icon\">\n        <cx-icon [type]=\"getIconType\"></cx-icon>\n      </span>\n\n      <span class=\"cx-message-text\">\n        {{ text }}\n        <button\n          *ngIf=\"accordionText\"\n          (click)=\"showBody = !showBody\"\n          [attr.aria-expanded]=\"showBody\"\n          [attr.aria-label]=\"accordionText\"\n          aria-hidden=\"true\"\n          class=\"cx-message-accordion-button link cx-action-link\"\n          type=\"button\"\n        >\n          {{ accordionText }}\n          <cx-icon\n            [type]=\"showBody ? 'CARET_UP' : 'CARET_DOWN'\"\n            class=\"cx-message-accordion-icon\"\n          ></cx-icon>\n        </button>\n\n        <button\n          *ngIf=\"actionButtonText\"\n          (click)=\"buttonAction.emit()\"\n          [cxAtMessage]=\"actionButtonMessage\"\n          aria-hidden=\"true\"\n          class=\"btn btn-link cx-action-link\"\n          type=\"button\"\n        >\n          {{ actionButtonText }}\n        </button>\n      </span>\n\n      <button\n        *ngIf=\"isVisibleCloseButton\"\n        (click)=\"closeMessage.emit()\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        [cxAtMessage]=\"'common.close' | cxTranslate\"\n        aria-hidden=\"true\"\n        class=\"close\"\n        type=\"button\"\n      >\n        <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n      </button>\n    </div>\n\n    <div *ngIf=\"showBody || !accordionText\" class=\"cx-message-body\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { text: [{
                type: Input
            }], actionButtonText: [{
                type: Input
            }], actionButtonMessage: [{
                type: Input
            }], accordionText: [{
                type: Input
            }], showBody: [{
                type: Input
            }], isVisibleCloseButton: [{
                type: Input
            }], type: [{
                type: Input
            }], closeMessage: [{
                type: Output
            }], buttonAction: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MessageComponentModule {
}
MessageComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MessageComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MessageComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: MessageComponentModule, declarations: [MessageComponent], imports: [AtMessageModule, CommonModule, I18nModule, IconModule], exports: [MessageComponent] });
MessageComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MessageComponentModule, imports: [AtMessageModule, CommonModule, I18nModule, IconModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MessageComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [AtMessageModule, CommonModule, I18nModule, IconModule],
                    declarations: [MessageComponent],
                    exports: [MessageComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PromotionsComponent {
    constructor() {
        // Intentional empty constructor
    }
}
PromotionsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PromotionsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
PromotionsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PromotionsComponent, selector: "cx-promotions", inputs: { promotions: "promotions" }, ngImport: i0, template: "<div class=\"cx-promotions\" *ngIf=\"promotions\">\n  <ng-container *ngIf=\"promotions.length === 1\">\n    <p>{{ promotions[0].description }}</p>\n  </ng-container>\n  <ng-container *ngIf=\"promotions.length > 1\">\n    <ul>\n      <li *ngFor=\"let promotion of promotions\">\n        {{ promotion.description }}\n      </li>\n    </ul>\n  </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PromotionsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-promotions', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"cx-promotions\" *ngIf=\"promotions\">\n  <ng-container *ngIf=\"promotions.length === 1\">\n    <p>{{ promotions[0].description }}</p>\n  </ng-container>\n  <ng-container *ngIf=\"promotions.length > 1\">\n    <ul>\n      <li *ngFor=\"let promotion of promotions\">\n        {{ promotion.description }}\n      </li>\n    </ul>\n  </ng-container>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { promotions: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PromotionsModule {
}
PromotionsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PromotionsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PromotionsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PromotionsModule, declarations: [PromotionsComponent], imports: [CommonModule], exports: [PromotionsComponent] });
PromotionsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PromotionsModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PromotionsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [PromotionsComponent],
                    exports: [PromotionsComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var SiteContextType;
(function (SiteContextType) {
    SiteContextType["LANGUAGE"] = "LANGUAGE";
    SiteContextType["CURRENCY"] = "CURRENCY";
})(SiteContextType || (SiteContextType = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const LABELS = {
    [LANGUAGE_CONTEXT_ID]: 'Language',
    [CURRENCY_CONTEXT_ID]: 'Currency',
};
class SiteContextComponentService {
    constructor(componentData, contextServiceMap, injector) {
        this.componentData = componentData;
        this.contextServiceMap = contextServiceMap;
        this.injector = injector;
    }
    getItems(context) {
        return this.getService(context).pipe(switchMap((service) => service.getAll()), switchMap((items) => this.getContext(context).pipe(switchMap((ctx) => {
            const itemsCopy = [];
            for (const item of items) {
                itemsCopy.push({
                    ...item,
                    label: this.getOptionLabel(item, ctx),
                });
            }
            return of(itemsCopy);
        }))));
    }
    getActiveItem(context) {
        return this.getService(context).pipe(switchMap((service) => service.getActive()));
    }
    getLabel(context) {
        return this.getContext(context).pipe(map((ctx) => {
            if (ctx) {
                return LABELS[ctx];
            }
        }));
    }
    setActive(value, context) {
        this.getService(context)
            .pipe(take(1))
            .subscribe((service) => {
            service.setActive(value);
        });
    }
    getService(context) {
        return this.getContext(context).pipe(map((ctx) => ctx ? this.getInjectedService(ctx) : undefined), filter(isNotUndefined));
    }
    getContext(context) {
        if (context) {
            if (context === SiteContextType.CURRENCY) {
                return of(CURRENCY_CONTEXT_ID);
            }
            else if (context === SiteContextType.LANGUAGE) {
                return of(LANGUAGE_CONTEXT_ID);
            }
            else {
                return of(context);
            }
        }
        else if (this.componentData) {
            return this.componentData.data$.pipe(map((data) => data.context), map((ctx) => {
                switch (ctx) {
                    case 'LANGUAGE':
                        return LANGUAGE_CONTEXT_ID;
                    case 'CURRENCY':
                        return CURRENCY_CONTEXT_ID;
                    default:
                        return ctx;
                }
            }));
        }
        return of(undefined);
    }
    getInjectedService(context) {
        return this.injector.get(this.contextServiceMap[context], undefined);
    }
    getOptionLabel(item, context) {
        switch (context) {
            case LANGUAGE_CONTEXT_ID:
                return item.nativeName;
            case CURRENCY_CONTEXT_ID:
                return item.symbol + ' ' + item.isocode;
            default:
                return item.isocode;
        }
    }
}
SiteContextComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SiteContextComponentService, deps: [{ token: CmsComponentData, optional: true }, { token: i1.ContextServiceMap }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
SiteContextComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SiteContextComponentService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SiteContextComponentService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CmsComponentData, decorators: [{
                    type: Optional
                }] }, { type: i1.ContextServiceMap }, { type: i0.Injector }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SiteContextSelectorComponent {
    constructor(componentService) {
        this.componentService = componentService;
        this.iconTypes = ICON_TYPE;
    }
    get items$() {
        return this.componentService.getItems(this.context);
    }
    get activeItem$() {
        return this.componentService.getActiveItem(this.context);
    }
    set active(value) {
        this.componentService.setActive(value, this.context);
    }
    get label$() {
        return this.componentService.getLabel(this.context);
    }
}
SiteContextSelectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SiteContextSelectorComponent, deps: [{ token: SiteContextComponentService }], target: i0.ɵɵFactoryTarget.Component });
SiteContextSelectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: SiteContextSelectorComponent, selector: "cx-site-context-selector", inputs: { context: "context" }, ngImport: i0, template: "<label *ngIf=\"(items$ | async)?.length > 1 && (items$ | async) as items\">\n  <span>{{ label$ | async }}:</span>\n  <select (change)=\"active = $any($event).target.value\">\n    <option\n      *ngFor=\"let item of items\"\n      value=\"{{ item.isocode }}\"\n      [selected]=\"(activeItem$ | async) === item.isocode\"\n    >\n      {{ item.label }}\n    </option>\n  </select>\n  <cx-icon [type]=\"iconTypes.CARET_DOWN\" class=\"small\"></cx-icon>\n</label>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SiteContextSelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-site-context-selector', changeDetection: ChangeDetectionStrategy.OnPush, template: "<label *ngIf=\"(items$ | async)?.length > 1 && (items$ | async) as items\">\n  <span>{{ label$ | async }}:</span>\n  <select (change)=\"active = $any($event).target.value\">\n    <option\n      *ngFor=\"let item of items\"\n      value=\"{{ item.isocode }}\"\n      [selected]=\"(activeItem$ | async) === item.isocode\"\n    >\n      {{ item.label }}\n    </option>\n  </select>\n  <cx-icon [type]=\"iconTypes.CARET_DOWN\" class=\"small\"></cx-icon>\n</label>\n" }]
        }], ctorParameters: function () { return [{ type: SiteContextComponentService }]; }, propDecorators: { context: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class LanguageCurrencyComponent {
    constructor() {
        this.siteContextType = SiteContextType;
    }
}
LanguageCurrencyComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LanguageCurrencyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LanguageCurrencyComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: LanguageCurrencyComponent, selector: "cx-language-currency-selector", ngImport: i0, template: `
    <cx-site-context-selector
      [context]="siteContextType.LANGUAGE"
    ></cx-site-context-selector>
    <cx-site-context-selector
      [context]="siteContextType.CURRENCY"
    ></cx-site-context-selector>
  `, isInline: true, dependencies: [{ kind: "component", type: SiteContextSelectorComponent, selector: "cx-site-context-selector", inputs: ["context"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LanguageCurrencyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-language-currency-selector',
                    template: `
    <cx-site-context-selector
      [context]="siteContextType.LANGUAGE"
    ></cx-site-context-selector>
    <cx-site-context-selector
      [context]="siteContextType.CURRENCY"
    ></cx-site-context-selector>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SiteContextSelectorModule {
}
SiteContextSelectorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SiteContextSelectorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SiteContextSelectorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SiteContextSelectorModule, declarations: [SiteContextSelectorComponent, LanguageCurrencyComponent], imports: [CommonModule, RouterModule, SiteContextModule, IconModule], exports: [SiteContextSelectorComponent, LanguageCurrencyComponent] });
SiteContextSelectorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SiteContextSelectorModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CMSSiteContextComponent: {
                    component: SiteContextSelectorComponent,
                    providers: [
                        {
                            provide: SiteContextComponentService,
                            useClass: SiteContextComponentService,
                            deps: [CmsComponentData, ContextServiceMap, Injector],
                        },
                    ],
                },
                LanguageCurrencyComponent: {
                    component: LanguageCurrencyComponent,
                },
            },
        }),
        SiteContextComponentService,
    ], imports: [CommonModule, RouterModule, SiteContextModule, IconModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SiteContextSelectorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, SiteContextModule, IconModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSSiteContextComponent: {
                                    component: SiteContextSelectorComponent,
                                    providers: [
                                        {
                                            provide: SiteContextComponentService,
                                            useClass: SiteContextComponentService,
                                            deps: [CmsComponentData, ContextServiceMap, Injector],
                                        },
                                    ],
                                },
                                LanguageCurrencyComponent: {
                                    component: LanguageCurrencyComponent,
                                },
                            },
                        }),
                        SiteContextComponentService,
                    ],
                    declarations: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                    exports: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Star rating component can be used to view existing ratings as well
 * as create new ratings. The component can be used for any ratings.
 */
class StarRatingComponent {
    constructor() {
        this.initialRate = 0;
        this.icon = ICON_TYPE.STAR;
        /**
         * The rating component can be used in disabled mode,
         * so that the interaction is not provided.
         *
         * Defaults to true.
         */
        this.disabled = true;
        /**
         * The rating is used to color the rating stars. It can have a
         * precise number. The rating number is used for a CSS custom property
         * (AKA css variable) value. The actually coloring is done in CSS.
         */
        this.rating = this.initialRate;
        /**
         * Emits the given rating when the user clicks on a star.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
    }
    setRate(value) {
        if (this.disabled) {
            return;
        }
        this.rating = value;
    }
    reset() {
        if (this.disabled) {
            return;
        }
        this.rating = this.initialRate ?? 0;
    }
    saveRate(rating) {
        if (this.disabled) {
            return;
        }
        this.initialRate = rating;
        this.setRate(rating);
        this.change.emit(rating);
    }
}
StarRatingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StarRatingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
StarRatingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: StarRatingComponent, selector: "cx-star-rating", inputs: { disabled: "disabled", rating: "rating" }, outputs: { change: "change" }, host: { listeners: { "mouseout": "reset()" }, properties: { "attr.disabled": "this.disabled", "style.--star-fill": "this.rating" } }, ngImport: i0, template: "<cx-icon\n  *ngFor=\"let i of [1, 2, 3, 4, 5]\"\n  [type]=\"icon\"\n  class=\"star\"\n  (mouseover)=\"setRate(i)\"\n  (click)=\"saveRate(i)\"\n  (keydown.space)=\"saveRate(i)\"\n  [attr.tabindex]=\"disabled ? null : 0\"\n  role=\"button\"\n  attr.aria-label=\"{{ 'productReview.addRate' | cxTranslate: { count: i } }}\"\n></cx-icon>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StarRatingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-star-rating', changeDetection: ChangeDetectionStrategy.OnPush, template: "<cx-icon\n  *ngFor=\"let i of [1, 2, 3, 4, 5]\"\n  [type]=\"icon\"\n  class=\"star\"\n  (mouseover)=\"setRate(i)\"\n  (click)=\"saveRate(i)\"\n  (keydown.space)=\"saveRate(i)\"\n  [attr.tabindex]=\"disabled ? null : 0\"\n  role=\"button\"\n  attr.aria-label=\"{{ 'productReview.addRate' | cxTranslate: { count: i } }}\"\n></cx-icon>\n" }]
        }], propDecorators: { disabled: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.disabled']
            }], rating: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['style.--star-fill']
            }], change: [{
                type: Output
            }], reset: [{
                type: HostListener,
                args: ['mouseout']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class StarRatingModule {
}
StarRatingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StarRatingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StarRatingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: StarRatingModule, declarations: [StarRatingComponent], imports: [CommonModule, IconModule, I18nModule], exports: [StarRatingComponent] });
StarRatingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StarRatingModule, imports: [CommonModule, IconModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StarRatingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IconModule, I18nModule],
                    declarations: [StarRatingComponent],
                    exports: [StarRatingComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TableDataCellComponent {
    constructor(outlet) {
        this.outlet = outlet;
    }
    get value() {
        return this.model[this.field];
    }
    get model() {
        return this.outlet?.context;
    }
    get field() {
        return this.outlet?.context?._field;
    }
}
TableDataCellComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableDataCellComponent, deps: [{ token: OutletContextData }], target: i0.ɵɵFactoryTarget.Component });
TableDataCellComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: TableDataCellComponent, selector: "cx-table-data-cell", host: { properties: { "attr.title": "this.value" } }, ngImport: i0, template: `{{ value }}`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableDataCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-table-data-cell',
                    template: `{{ value }}`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OutletContextData }]; }, propDecorators: { value: [{
                type: HostBinding,
                args: ['attr.title']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TableHeaderCellComponent {
    constructor(outlet) {
        this.outlet = outlet;
    }
    /**
     * Returns the static label for the given field, if available.
     */
    get header() {
        if (typeof this.fieldOptions?.label === 'string') {
            return this.fieldOptions.label;
        }
    }
    /**
     * Returns the localized label for the given field.
     *
     * The localized label is either driven by the configured `label.i18nKey`
     * or concatenated by the table `type` and field `key`:
     *
     * `[tableType].[fieldKey]`
     *
     * The localized header can be translated with the `cxTranslate` pipe or `TranslationService`.
     */
    get localizedHeader() {
        return (this.fieldOptions?.label?.i18nKey ||
            `${this.i18nRoot}.${this.field}`);
    }
    get fieldOptions() {
        return this.outlet?.context._options?.cells?.[this.field];
    }
    get field() {
        return this.outlet?.context?._field;
    }
    get type() {
        return this.outlet?.context?._type;
    }
    get i18nRoot() {
        return this.outlet?.context?._i18nRoot;
    }
}
TableHeaderCellComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableHeaderCellComponent, deps: [{ token: OutletContextData }], target: i0.ɵɵFactoryTarget.Component });
TableHeaderCellComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: TableHeaderCellComponent, selector: "cx-table-header-cell", ngImport: i0, template: `{{ header || (localizedHeader | cxTranslate) }}`, isInline: true, dependencies: [{ kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableHeaderCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-table-header-cell',
                    template: `{{ header || (localizedHeader | cxTranslate) }}`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: OutletContextData }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultTableConfig = {
    tableOptions: {
        headerComponent: TableHeaderCellComponent,
        dataComponent: TableDataCellComponent,
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The `TableConfig` provides a table configurations for specific table types. You can define
 * an all-screen table structure as well as a breakpoint specific table structure. The various
 * table structures are merged from small to large screen configurations, depending on the users
 * screen size.
 *
 * The `table.type` is used as a key to distinguish the various table configurations in the application.
 */
class TableConfig {
}
TableConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TableConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TableDataCellModule {
}
TableDataCellModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableDataCellModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TableDataCellModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: TableDataCellModule, declarations: [TableDataCellComponent], imports: [CommonModule] });
TableDataCellModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableDataCellModule, imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableDataCellModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [TableDataCellComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TableHeaderCellModule {
}
TableHeaderCellModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableHeaderCellModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TableHeaderCellModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: TableHeaderCellModule, declarations: [TableHeaderCellComponent], imports: [CommonModule, I18nModule] });
TableHeaderCellModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableHeaderCellModule, imports: [CommonModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableHeaderCellModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    declarations: [TableHeaderCellComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The table renderer service adds a component for each table cells (th and td)
 * based on a fine grained configuration. Each table type can configure both global
 * components for headers and cells as well as individual components for field
 * specific cells.
 *
 * The components are added to the outlet slots for the corresponding cells. The table
 * structure and data is added to the outlet context.
 */
class TableRendererService {
    constructor(outletService, componentFactoryResolver, config) {
        this.outletService = outletService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.config = config;
        // keep a list of outletRefs to avoid recreation
        this.outletRefs = new Map();
    }
    /**
     * Adds the configured table component for the header and data.
     */
    add(structure) {
        structure?.cells?.forEach((field) => {
            const thRenderer = this.getHeaderRenderer(structure, field);
            if (thRenderer) {
                const ref = this.getHeaderOutletRef(structure.type, field);
                this.render(ref, thRenderer);
            }
            const tdRenderer = this.getDataRenderer(structure, field);
            if (tdRenderer) {
                const ref = this.getDataOutletRef(structure.type, field);
                this.render(ref, tdRenderer);
            }
        });
    }
    render(outletRef, renderer) {
        if (this.outletRefs.has(outletRef)) {
            return;
        }
        this.outletRefs.set(outletRef, true);
        const template = this.componentFactoryResolver.resolveComponentFactory(renderer);
        this.outletService.add(outletRef, template);
    }
    /**
     * Returns the header render component for the given field.
     */
    getHeaderRenderer(structure, field) {
        return (structure.options?.cells?.[field]?.headerComponent ||
            structure.options?.headerComponent ||
            this.config.tableOptions?.headerComponent);
    }
    /**
     * Returns the data render component for the given field.
     */
    getDataRenderer(structure, field) {
        return (structure.options?.cells?.[field]?.dataComponent ||
            structure.options?.dataComponent ||
            this.config.tableOptions?.dataComponent);
    }
    /**
     * Returns the header (th) outlet reference for the given field.
     *
     * The outlet reference is generated as:
     * `table.[tableType].header.[field]`
     */
    getHeaderOutletRef(type, field) {
        return `table.${type}.header.${field}`;
    }
    /**
     * Returns the header (th) outlet context for the given field.
     */
    getHeaderOutletContext(type, options, i18nRoot, field) {
        return {
            _type: type,
            _options: options,
            _field: field,
            _i18nRoot: i18nRoot,
        };
    }
    /**
     * Returns the data (td) outlet reference for the given field.
     *
     * The field is generated as:
     * `table.[tableType].data.[tableField]`
     */
    getDataOutletRef(type, field) {
        return `table.${type}.data.${field}`;
    }
    /**
     * Returns the data (td) outlet context for the given field.
     */
    getDataOutletContext(type, options, i18nRoot, field, data) {
        return {
            ...data,
            _type: type,
            _options: options,
            _field: field,
            _i18nRoot: i18nRoot,
        };
    }
}
TableRendererService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableRendererService, deps: [{ token: OutletService }, { token: i0.ComponentFactoryResolver }, { token: TableConfig }], target: i0.ɵɵFactoryTarget.Injectable });
TableRendererService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableRendererService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableRendererService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: OutletService }, { type: i0.ComponentFactoryResolver }, { type: TableConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Layout orientation for the table configuration.
 */
var TableLayout;
(function (TableLayout) {
    /**
     * Renders the table vertically, with a heading on top of the table.
     *
     * Vertical layout is most common and the default layout.
     */
    TableLayout[TableLayout["VERTICAL"] = 1] = "VERTICAL";
    /**
     * Stacks items in a tables by generating a `tbody` for each item.
     */
    TableLayout[TableLayout["VERTICAL_STACKED"] = 2] = "VERTICAL_STACKED";
    /**
     * Horizontal oriented table layout renders the table headers in the first column of the table.
     */
    TableLayout[TableLayout["HORIZONTAL"] = 3] = "HORIZONTAL";
})(TableLayout || (TableLayout = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The table component provides a generic table DOM structure, with 3 layout types:
 * horizontal, vertical and _stacked vertical_ layout. The layout is driven by the
 * table structure.
 *
 * The implementation is fairly "dumb" and only renders string based content for TH
 * and TD elements. The actual cell rendering is delegated to a (configurable) cell
 * component. Additionally, each cell is registered as an outlet, so that customizations
 * can be done by both outlet templates and components.
 *
 * The outlet references are concatenated from the table `type` and header `key`. The
 * following snippet shows an outlet generated for a table header, for the table type
 * "cost-center" with a header key "name":
 *
 * ```
 * <th>
 *   <template cxOutlet="table.cost-center.header.name">
 *   </template>
 * </th>
 * ```
 *
 * Similarly, the data cells (`<td>`) are generated with the outlet template reference
 * `table.cost-center.data.name`.
 */
class TableComponent {
    set structure(structure) {
        this._structure = structure;
        this.init();
    }
    get structure() {
        return this._structure;
    }
    constructor(rendererService) {
        this.rendererService = rendererService;
        this.launch = new EventEmitter();
    }
    init() {
        this.verticalLayout = !this.layout || this.layout === TableLayout.VERTICAL;
        this.verticalStackedLayout = this.layout === TableLayout.VERTICAL_STACKED;
        this.horizontalLayout = this.layout === TableLayout.HORIZONTAL;
        this.rendererService.add(this.structure);
        this.addTableDebugInfo();
    }
    launchItem(item) {
        this.launch.emit(item);
    }
    /**
     * Indicates whether the given item is the current item.
     *
     * The current item is driven by the `currentItem`, that holds a
     * property and value to compare.
     */
    isCurrentItem(item) {
        if (!this.currentItem || !this.currentItem.value) {
            return false;
        }
        return this.currentItem?.value === item?.[this.currentItem?.property];
    }
    /**
     * Returns the header (th) outlet reference for the given field.
     */
    getHeaderOutletRef(field) {
        return this.rendererService.getHeaderOutletRef(this.type, field);
    }
    /**
     * Returns the header (th) outlet context for the given field.
     */
    getHeaderOutletContext(field) {
        return this.rendererService.getHeaderOutletContext(this.type, this.options, this.i18nRoot, field);
    }
    /**
     * Returns the data (td) outlet reference for the given field.
     */
    getDataOutletRef(field) {
        return this.rendererService.getDataOutletRef(this.type, field);
    }
    /**
     * Returns the data (td) outlet context for the given field.
     */
    getDataOutletContext(field, data) {
        return this.rendererService.getDataOutletContext(this.type, this.options, this.i18nRoot, field, data);
    }
    trackData(_i, item) {
        return JSON.stringify(item);
    }
    /**
     * Generates the table type into the UI in devMode, so that developers
     * can easily get the notion of the table type.
     */
    addTableDebugInfo() {
        if (isDevMode() && this.type) {
            this.tableType = this.type;
        }
    }
    /**
     * Helper method to return the deeply nested orientation configuration.
     */
    get layout() {
        return this.structure?.options?.layout;
    }
    /**
     * Helper method to return the deeply nested type.
     */
    get type() {
        return this.structure?.type;
    }
    get options() {
        return this.structure?.options;
    }
}
TableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableComponent, deps: [{ token: TableRendererService }], target: i0.ɵɵFactoryTarget.Component });
TableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: TableComponent, selector: "cx-table", inputs: { structure: "structure", data: "data", i18nRoot: "i18nRoot", currentItem: "currentItem" }, outputs: { launch: "launch" }, host: { properties: { "attr.__cx-table-type": "this.tableType", "class.horizontal": "this.horizontalLayout", "class.vertical": "this.verticalLayout", "class.vertical-stacked": "this.verticalStackedLayout" } }, ngImport: i0, template: "<table *ngIf=\"structure\">\n  <ng-container *ngIf=\"verticalStackedLayout\">\n    <tbody\n      *ngFor=\"let item of data; trackBy: trackData\"\n      (click)=\"launchItem(item)\"\n      [class.is-current]=\"isCurrentItem(item)\"\n    >\n      <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n        <th>\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n        <td>\n          <ng-template\n            [cxOutlet]=\"getDataOutletRef(cell)\"\n            [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n          >\n            {{ $any(item)[cell] }}\n          </ng-template>\n        </td>\n      </tr>\n    </tbody>\n  </ng-container>\n\n  <!-- vertical tables render the item  -->\n  <ng-container *ngIf=\"verticalLayout\">\n    <thead>\n      <tr>\n        <th scope=\"col\" *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n      </tr>\n    </thead>\n\n    <tr\n      *ngFor=\"let item of data; trackBy: trackData\"\n      [class.is-current]=\"isCurrentItem(item)\"\n      (click)=\"launchItem(item)\"\n    >\n      <td *ngFor=\"let cell of structure.cells; let i = index\" [class]=\"cell\">\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ $any(item)[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n\n  <ng-container *ngIf=\"horizontalLayout\">\n    <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n      <th scope=\"col\">\n        <ng-template\n          [cxOutlet]=\"getHeaderOutletRef(cell)\"\n          [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n        >\n          {{ cell }}\n        </ng-template>\n      </th>\n      <td\n        *ngFor=\"let item of data; trackBy: trackData\"\n        [class.is-current]=\"isCurrentItem(item)\"\n        (click)=\"launchItem(item)\"\n      >\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ $any(item)[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n</table>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-table', changeDetection: ChangeDetectionStrategy.OnPush, template: "<table *ngIf=\"structure\">\n  <ng-container *ngIf=\"verticalStackedLayout\">\n    <tbody\n      *ngFor=\"let item of data; trackBy: trackData\"\n      (click)=\"launchItem(item)\"\n      [class.is-current]=\"isCurrentItem(item)\"\n    >\n      <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n        <th>\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n        <td>\n          <ng-template\n            [cxOutlet]=\"getDataOutletRef(cell)\"\n            [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n          >\n            {{ $any(item)[cell] }}\n          </ng-template>\n        </td>\n      </tr>\n    </tbody>\n  </ng-container>\n\n  <!-- vertical tables render the item  -->\n  <ng-container *ngIf=\"verticalLayout\">\n    <thead>\n      <tr>\n        <th scope=\"col\" *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n      </tr>\n    </thead>\n\n    <tr\n      *ngFor=\"let item of data; trackBy: trackData\"\n      [class.is-current]=\"isCurrentItem(item)\"\n      (click)=\"launchItem(item)\"\n    >\n      <td *ngFor=\"let cell of structure.cells; let i = index\" [class]=\"cell\">\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ $any(item)[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n\n  <ng-container *ngIf=\"horizontalLayout\">\n    <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n      <th scope=\"col\">\n        <ng-template\n          [cxOutlet]=\"getHeaderOutletRef(cell)\"\n          [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n        >\n          {{ cell }}\n        </ng-template>\n      </th>\n      <td\n        *ngFor=\"let item of data; trackBy: trackData\"\n        [class.is-current]=\"isCurrentItem(item)\"\n        (click)=\"launchItem(item)\"\n      >\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ $any(item)[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n</table>\n" }]
        }], ctorParameters: function () { return [{ type: TableRendererService }]; }, propDecorators: { tableType: [{
                type: HostBinding,
                args: ['attr.__cx-table-type']
            }], horizontalLayout: [{
                type: HostBinding,
                args: ['class.horizontal']
            }], verticalLayout: [{
                type: HostBinding,
                args: ['class.vertical']
            }], verticalStackedLayout: [{
                type: HostBinding,
                args: ['class.vertical-stacked']
            }], structure: [{
                type: Input
            }], data: [{
                type: Input
            }], i18nRoot: [{
                type: Input
            }], currentItem: [{
                type: Input
            }], launch: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The TableModule provides a table component that is driven by (responsible) configuration.
 */
class TableModule {
}
TableModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TableModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: TableModule, declarations: [TableComponent], imports: [CommonModule,
        OutletModule,
        TableHeaderCellModule,
        TableDataCellModule], exports: [TableComponent] });
TableModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableModule, providers: [provideDefaultConfig(defaultTableConfig)], imports: [CommonModule,
        OutletModule,
        TableHeaderCellModule,
        TableDataCellModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        OutletModule,
                        TableHeaderCellModule,
                        TableDataCellModule,
                    ],
                    declarations: [TableComponent],
                    exports: [TableComponent],
                    providers: [provideDefaultConfig(defaultTableConfig)],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Responsive table service.
 *
 * The `TableService` is used to build a `TableStructure` by configuration. The configuration
 * allows for breakpoint specific configuration, so that the table can differentiate for
 * various screen sizes.
 *
 * While there are some global options, the configuration is mainly driven by the table _type_.
 *
 * If there is no table configuration for the given type found, a table header structure
 * is generated based on the actual data (if available) or randomly by generating 5 random headers.
 */
class TableService {
    constructor(breakpointService, config) {
        this.breakpointService = breakpointService;
        this.config = config;
    }
    /**
     * Builds the table structure.
     *
     * @param tableType The table type is used  to find the specific table configuration.
     * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
     * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
     */
    buildStructure(tableType, defaultStructure) {
        if (this.hasTableConfig(tableType)) {
            return this.buildStructureFromConfig(tableType, defaultStructure);
        }
        else {
            return this.buildRandomStructure(tableType);
        }
    }
    /**
     * Returns the table structure by configuration. The configuration can be
     * breakpoint-driven, which means that an alternative header structure can
     * be created per screen size.
     *
     * The breakpoint is resolved by teh `BreakpointService`.
     */
    buildStructureFromConfig(type, defaultStructure) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => ({
            ...this.getTableConfig(type, breakpoint, defaultStructure),
            type,
        })));
    }
    /**
     * Finds all applicable table configuration for the given type and breakpoint.
     * The default table configuration is merged with all relevant breakpoint
     * configurations.
     *
     * This allows to have some default configurations that apply to all screens, and
     * add configuration options for some screens.
     */
    getTableConfig(type, breakpoint, defaultStructure) {
        if (!this.config.table?.[type]) {
            return null;
        }
        const relevant = this.findRelevantBreakpoints(breakpoint);
        const closestBreakpoint = [...relevant]
            .reverse()
            .find((br) => !!this.config.table?.[type][br]?.cells);
        const cells = (closestBreakpoint &&
            this.config.table[type][closestBreakpoint]?.cells) ||
            this.config.table[type].cells ||
            defaultStructure?.cells;
        // add all default table configurations
        let options = {
            ...defaultStructure?.options,
            ...this.config.table[type].options,
        };
        // We merge all table options for smaller breakpoints into the global
        // options, so we inherit options.
        relevant.forEach((br) => {
            options = {
                ...options,
                ...defaultStructure?.[br]?.options,
                ...this.config.table?.[type]?.[br]?.options,
            };
        });
        return { cells, options };
    }
    /**
     * Generates the table structure by the help of the first data row.
     */
    buildStructureFromData(type, data$) {
        this.logWarning(`No table configuration found to render table with type "${type}". The table header for "${type}" is generated by the help of the first data item`);
        return data$.pipe(map((data) => {
            const cells = Object.keys(data?.[0]).map((key) => key);
            return { type, cells };
        }));
    }
    /**
     * As a last resort, the table structure is randomly created. The random structure
     * contains 5 headers, so that some of the unknown data is visualized.
     */
    buildRandomStructure(type) {
        this.logWarning(`No data available for "${type}", a random structure is generated (with hidden table headers).`);
        return of({
            type,
            cells: ['unknown', 'unknown', 'unknown', 'unknown', 'unknown'],
        });
    }
    /**
     * Finds all the breakpoints can contribute to the table configuration, from small
     * to current.
     *
     * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
     */
    findRelevantBreakpoints(breakpoint) {
        const current = this.breakpointService.breakpoints.indexOf(breakpoint);
        return this.breakpointService.breakpoints.slice(0, current + 1);
    }
    /**
     * Indicates if the there is a configuration for the table available.
     */
    hasTableConfig(tableType) {
        return !!this.config.table?.[tableType];
    }
    /**
     * Logs a message in the console to increase developer experience.
     *
     * The message is only logged in dev mode.
     */
    logWarning(message) {
        if (isDevMode()) {
            console.warn(message);
        }
    }
}
TableService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableService, deps: [{ token: BreakpointService }, { token: TableConfig }], target: i0.ɵɵFactoryTarget.Injectable });
TableService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TableService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: BreakpointService }, { type: TableConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FilesFormValidators {
    constructor() {
        this.CONVERT_TO_MB = 1000000;
        this.extenstionRegEx = /\.([0-9a-z]+)(?:[\?#]|$)/i;
    }
    /**
     * Checks max size of file
     *
     * @param {number} maxSize Max size [MB]
     * @returns Uses 'tooLarge' validator error with maxSize property
     * @memberOf FilesFormValidators
     */
    maxSize(maxSize) {
        return (control) => {
            const errors = {};
            if (maxSize && control.value) {
                const files = Array.from(control.value);
                files.forEach(({ size, name }) => {
                    if (size > maxSize * this.CONVERT_TO_MB) {
                        const invalidFiles = errors.tooLarge?.invalidFiles ?? [];
                        errors.tooLarge = {
                            maxSize,
                            invalidFiles: [...invalidFiles, name],
                        };
                    }
                });
            }
            return Object.keys(errors).length === 0 ? null : errors;
        };
    }
    /**
     * Checks maximum entries
     *
     * @param {number} maxEntries Max number of entries
     * @returns Uses 'tooManyEntries' validator error with maxEntries property
     * @memberOf FilesFormValidators
     */
    maxEntries(maxEntries) {
        return (control) => {
            const errors = {};
            if (maxEntries && control.value) {
                const files = Array.from(control.value);
                if (files.length > maxEntries) {
                    errors.tooManyEntries = { maxEntries };
                }
            }
            return Object.keys(errors).length === 0 ? null : errors;
        };
    }
    /**
     * Checks allowed types
     *
     * @param {Array<string>} allowedTypes Allowed types of files
     * @returns Uses 'notParsable' validator error with allowedTypes property
     * @memberOf FilesFormValidators
     */
    allowedTypes(allowedTypes) {
        return (control) => {
            const errors = {};
            if (allowedTypes && control.value) {
                const files = Array.from(control.value);
                errors.fileNotAllowed = files.some(({ name }) => !allowedTypes.includes(this.getExtension(name)));
            }
            return errors[Object.keys(errors)?.[0]] ? errors : null;
        };
    }
    getExtension(filename) {
        return (filename?.match(this.extenstionRegEx) || [])[0] || '';
    }
}
FilesFormValidators.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FilesFormValidators, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FilesFormValidators.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FilesFormValidators, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FilesFormValidators, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AvatarComponent {
    constructor() {
        this.iconTypes = ICON_TYPE;
    }
    getInitials(author) {
        return author
            .split(' ')
            .map((string) => string[0])
            .join('');
    }
}
AvatarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AvatarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
AvatarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: AvatarComponent, selector: "cx-avatar", inputs: { message: "message" }, ngImport: i0, template: "<div\n  *ngIf=\"message\"\n  class=\"cx-avatar\"\n  [ngClass]=\"{ 'right-align': message.rightAlign }\"\n>\n  <span *ngIf=\"!message.rightAlign && message?.author\">\n    {{ getInitials(message?.author || '') }}\n  </span>\n\n  <cx-icon\n    *ngIf=\"!message.rightAlign && !message?.author\"\n    [type]=\"iconTypes.USER\"\n  ></cx-icon>\n\n  <cx-icon *ngIf=\"message.rightAlign\" [type]=\"iconTypes.HEADSET\"></cx-icon>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AvatarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-avatar', template: "<div\n  *ngIf=\"message\"\n  class=\"cx-avatar\"\n  [ngClass]=\"{ 'right-align': message.rightAlign }\"\n>\n  <span *ngIf=\"!message.rightAlign && message?.author\">\n    {{ getInitials(message?.author || '') }}\n  </span>\n\n  <cx-icon\n    *ngIf=\"!message.rightAlign && !message?.author\"\n    [type]=\"iconTypes.USER\"\n  ></cx-icon>\n\n  <cx-icon *ngIf=\"message.rightAlign\" [type]=\"iconTypes.HEADSET\"></cx-icon>\n</div>\n" }]
        }], propDecorators: { message: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MessagingComponent {
    get inputCharacterLeft() {
        return ((this.messagingConfigs?.charactersLimit || this.MAX_INPUT_CHARACTERS) -
            (this.form.get('message')?.value?.length || 0));
    }
    get maxSize() {
        return (this.messagingConfigs?.attachmentRestrictions?.maxSize || this.MAX_SIZE);
    }
    get maxEntries() {
        return (this.messagingConfigs?.attachmentRestrictions?.maxEntries ||
            this.MAX_ENTRIES);
    }
    get allowedTypes() {
        return this.messagingConfigs?.attachmentRestrictions?.allowedTypes || [];
    }
    constructor(windowRef, filesFormValidators) {
        this.windowRef = windowRef;
        this.filesFormValidators = filesFormValidators;
        this.scrollToInput = true;
        this.send = new EventEmitter();
        this.downloadAttachment = new EventEmitter();
        this.iconTypes = ICON_TYPE;
        this.MAX_INPUT_CHARACTERS = 2000;
        this.MAX_SIZE = 10;
        this.MAX_ENTRIES = 1;
        this.dateFormat = 'MMMM d, YYYY h:mm aa';
        this.scrollOnceOnLoad = true;
    }
    ngOnInit() {
        this.buildForm();
    }
    ngAfterViewChecked() {
        if (this.scrollToInput) {
            this.observeScroll();
            if (this.scrollOnceOnLoad) {
                this.scrollOnLoad();
            }
        }
    }
    onSend() {
        if (this.form.valid) {
            this.send.emit({
                files: this.form.get('file')?.value,
                message: this.form.get('message')?.value,
            });
        }
    }
    resetForm() {
        this.form.reset();
        this.fileUploadComponent.removeFile();
    }
    triggerDownload(messageCode, attachmentId, fileName) {
        this.downloadAttachment.emit({
            messageCode: messageCode,
            attachmentId: attachmentId,
            fileName: fileName,
        });
    }
    buildForm() {
        const form = new UntypedFormGroup({});
        form.setControl('message', new UntypedFormControl('', [
            Validators.required,
            Validators.maxLength(this.messagingConfigs?.charactersLimit || this.MAX_INPUT_CHARACTERS),
        ]));
        form.setControl('file', new UntypedFormControl('', [
            this.filesFormValidators.maxSize(this.maxSize),
            this.filesFormValidators.maxEntries(this.maxEntries),
            this.filesFormValidators.allowedTypes(this.allowedTypes),
        ]));
        this.form = form;
    }
    focusNextChild(event) {
        event.preventDefault();
        const [results, focusedIndex] = [
            this.getResultElements(),
            this.getFocusedIndex(),
        ];
        if (results.length) {
            if (focusedIndex >= results.length - 1) {
                results[0].focus();
            }
            else {
                results[focusedIndex + 1].focus();
            }
        }
    }
    focusPreviousChild(event) {
        if (!this.windowRef.isBrowser()) {
            return;
        }
        event.preventDefault();
        const [results, focusedIndex] = [
            this.getResultElements(),
            this.getFocusedIndex(),
        ];
        if (results.length) {
            if (focusedIndex < 1) {
                results[results.length - 1].focus();
            }
            else {
                results[focusedIndex - 1].focus();
            }
        }
    }
    observeScroll() {
        const element = this.windowRef.document.querySelector('.cx-messages');
        if (element) {
            const resizeObserver = new ResizeObserver((entries) => {
                this.scrollToBottom(element, entries[0].target.scrollHeight);
                this.updatedScrollHeight = entries[0].target.scrollHeight;
            });
            resizeObserver.observe(element);
        }
    }
    scrollToBottom(element, previousScrollHeight) {
        if (this.heightChanged(previousScrollHeight)) {
            element?.scroll({
                top: element?.scrollHeight,
                behavior: 'auto',
            });
        }
    }
    heightChanged(previousScrollHeight) {
        return this.updatedScrollHeight !== previousScrollHeight;
    }
    scrollOnLoad() {
        const element = this.windowRef.document.getElementById('cx-message-footer');
        const resizeObserver = new ResizeObserver(() => {
            element?.scrollIntoView({ behavior: 'auto', block: 'end' });
            this.scrollOnceOnLoad = false;
        });
        if (element) {
            resizeObserver.observe(element);
        }
    }
    getResultElements() {
        return Array.from(this.windowRef.document.querySelectorAll('[role="listitem"]'));
    }
    getFocusedIndex() {
        return this.getResultElements().indexOf(this.getFocusedElement());
    }
    getFocusedElement() {
        return this.windowRef.document.activeElement;
    }
}
MessagingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MessagingComponent, deps: [{ token: i1.WindowRef }, { token: FilesFormValidators }], target: i0.ɵɵFactoryTarget.Component });
MessagingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: MessagingComponent, selector: "cx-messaging", inputs: { messageEvents$: "messageEvents$", scrollToInput: "scrollToInput", messagingConfigs: "messagingConfigs" }, outputs: { send: "send", downloadAttachment: "downloadAttachment" }, viewQueries: [{ propertyName: "fileUploadComponent", first: true, predicate: FileUploadComponent, descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"messageEvents$ | async as messageEvents\">\n  <div class=\"container\">\n    <div class=\"cx-avatar-line\"></div>\n    <div\n      class=\"cx-messages\"\n      id=\"cx-messages\"\n      (keydown.arrowdown)=\"focusNextChild($any($event))\"\n      (keydown.arrowup)=\"focusPreviousChild($any($event))\"\n      [attr.aria-label]=\"'chatMessaging.messages' | cxTranslate\"\n    >\n      <ng-container *ngFor=\"let message of messageEvents; let i = index\">\n        <div\n          class=\"cx-message-card\"\n          [ngClass]=\"{ 'cx-message-display': message?.rightAlign ?? false }\"\n        >\n          <cx-avatar [message]=\"message!\"> </cx-avatar>\n\n          <div>\n            <label>{{\n              (message?.createdAt | cxDate: messagingConfigs?.dateFormat) ??\n                dateFormat\n            }}</label>\n            <div\n              [ngClass]=\"\n                message?.rightAlign ?? false\n                  ? 'cx-message-right-align-text'\n                  : 'cx-message-left-align-text'\n              \"\n              [tabindex]=\"i ? -1 : 0\"\n              role=\"listitem\"\n              [attr.aria-label]=\"\n                'chatMessaging.informationLabel'\n                  | cxTranslate\n                    : {\n                        author: message?.author!,\n                        text: message?.text!,\n                        date:\n                          (message?.createdAt\n                            | cxDate: messagingConfigs?.dateFormat) ??\n                          dateFormat\n                      }\n              \"\n            >\n              {{ message?.text! }}\n            </div>\n            <a\n              *ngFor=\"let attachment of message?.attachments ?? []\"\n              class=\"cx-attachment\"\n              (click)=\"\n                triggerDownload(\n                  message?.code,\n                  attachment?.id,\n                  attachment?.filename\n                )\n              \"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              <cx-icon [type]=\"iconTypes.ATTACHMENT\"></cx-icon>\n              {{ attachment.filename }}\n            </a>\n          </div>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n\n  <div\n    [formGroup]=\"form\"\n    class=\"cx-message-footer\"\n    *ngIf=\"messagingConfigs?.displayAddMessageSection | async\"\n  >\n    <div class=\"cx-message-box\">\n      <label class=\"cx-footer-label\">\n        <span>\n          {{ 'chatMessaging.addNewMessage' | cxTranslate }}\n        </span>\n        <div class=\"cx-message-input\">\n          <input\n            formControlName=\"message\"\n            type=\"text\"\n            class=\"form-control\"\n            (keydown.enter)=\"onSend()\"\n            [maxLength]=\"\n              messagingConfigs?.charactersLimit || MAX_INPUT_CHARACTERS\n            \"\n            placeholder=\"{{\n              messagingConfigs?.newMessagePlaceHolder ||\n                ('chatMessaging.addMessagePlaceHolder' | cxTranslate)\n            }}\"\n          />\n          <span\n            class=\"cx-visually-hidden\"\n            *ngIf=\"inputCharacterLeft === 0\"\n            role=\"alert\"\n          >\n            {{ 'chatMessaging.characterLimitAlert' | cxTranslate }}\n          </span>\n          <button class=\"btn btn-block btn-primary cx-send\" (click)=\"onSend()\">\n            {{ 'chatMessaging.send' | cxTranslate }}\n          </button>\n        </div>\n      </label>\n      <div class=\"cx-message-footer-info\" id=\"cx-message-footer\">\n        <cx-file-upload\n          [formControl]=\"$any(form.get('file'))\"\n          [accept]=\"allowedTypes\"\n          *ngIf=\"messagingConfigs?.enableFileUploadOption\"\n        >\n          <ng-template>\n            <cx-icon [type]=\"iconTypes.UPLOAD\"></cx-icon>\n            <span class=\"cx-message-footer-text\"\n              >{{ 'chatMessaging.uploadFile' | cxTranslate }}\n            </span>\n          </ng-template>\n        </cx-file-upload>\n\n        <p class=\"cx-message-footer-info-text\">\n          {{\n            'chatMessaging.charactersLeft'\n              | cxTranslate: { count: inputCharacterLeft }\n          }}\n        </p>\n      </div>\n      <cx-form-errors\n        [control]=\"form.get('file')\"\n        prefix=\"formErrors.file\"\n      ></cx-form-errors>\n    </div>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "directive", type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i3$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: FileUploadComponent, selector: "cx-file-upload", inputs: ["accept", "multiple"], outputs: ["update"] }, { kind: "component", type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { kind: "component", type: AvatarComponent, selector: "cx-avatar", inputs: ["message"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.CxDatePipe, name: "cxDate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MessagingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-messaging', template: "<ng-container *ngIf=\"messageEvents$ | async as messageEvents\">\n  <div class=\"container\">\n    <div class=\"cx-avatar-line\"></div>\n    <div\n      class=\"cx-messages\"\n      id=\"cx-messages\"\n      (keydown.arrowdown)=\"focusNextChild($any($event))\"\n      (keydown.arrowup)=\"focusPreviousChild($any($event))\"\n      [attr.aria-label]=\"'chatMessaging.messages' | cxTranslate\"\n    >\n      <ng-container *ngFor=\"let message of messageEvents; let i = index\">\n        <div\n          class=\"cx-message-card\"\n          [ngClass]=\"{ 'cx-message-display': message?.rightAlign ?? false }\"\n        >\n          <cx-avatar [message]=\"message!\"> </cx-avatar>\n\n          <div>\n            <label>{{\n              (message?.createdAt | cxDate: messagingConfigs?.dateFormat) ??\n                dateFormat\n            }}</label>\n            <div\n              [ngClass]=\"\n                message?.rightAlign ?? false\n                  ? 'cx-message-right-align-text'\n                  : 'cx-message-left-align-text'\n              \"\n              [tabindex]=\"i ? -1 : 0\"\n              role=\"listitem\"\n              [attr.aria-label]=\"\n                'chatMessaging.informationLabel'\n                  | cxTranslate\n                    : {\n                        author: message?.author!,\n                        text: message?.text!,\n                        date:\n                          (message?.createdAt\n                            | cxDate: messagingConfigs?.dateFormat) ??\n                          dateFormat\n                      }\n              \"\n            >\n              {{ message?.text! }}\n            </div>\n            <a\n              *ngFor=\"let attachment of message?.attachments ?? []\"\n              class=\"cx-attachment\"\n              (click)=\"\n                triggerDownload(\n                  message?.code,\n                  attachment?.id,\n                  attachment?.filename\n                )\n              \"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              <cx-icon [type]=\"iconTypes.ATTACHMENT\"></cx-icon>\n              {{ attachment.filename }}\n            </a>\n          </div>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n\n  <div\n    [formGroup]=\"form\"\n    class=\"cx-message-footer\"\n    *ngIf=\"messagingConfigs?.displayAddMessageSection | async\"\n  >\n    <div class=\"cx-message-box\">\n      <label class=\"cx-footer-label\">\n        <span>\n          {{ 'chatMessaging.addNewMessage' | cxTranslate }}\n        </span>\n        <div class=\"cx-message-input\">\n          <input\n            formControlName=\"message\"\n            type=\"text\"\n            class=\"form-control\"\n            (keydown.enter)=\"onSend()\"\n            [maxLength]=\"\n              messagingConfigs?.charactersLimit || MAX_INPUT_CHARACTERS\n            \"\n            placeholder=\"{{\n              messagingConfigs?.newMessagePlaceHolder ||\n                ('chatMessaging.addMessagePlaceHolder' | cxTranslate)\n            }}\"\n          />\n          <span\n            class=\"cx-visually-hidden\"\n            *ngIf=\"inputCharacterLeft === 0\"\n            role=\"alert\"\n          >\n            {{ 'chatMessaging.characterLimitAlert' | cxTranslate }}\n          </span>\n          <button class=\"btn btn-block btn-primary cx-send\" (click)=\"onSend()\">\n            {{ 'chatMessaging.send' | cxTranslate }}\n          </button>\n        </div>\n      </label>\n      <div class=\"cx-message-footer-info\" id=\"cx-message-footer\">\n        <cx-file-upload\n          [formControl]=\"$any(form.get('file'))\"\n          [accept]=\"allowedTypes\"\n          *ngIf=\"messagingConfigs?.enableFileUploadOption\"\n        >\n          <ng-template>\n            <cx-icon [type]=\"iconTypes.UPLOAD\"></cx-icon>\n            <span class=\"cx-message-footer-text\"\n              >{{ 'chatMessaging.uploadFile' | cxTranslate }}\n            </span>\n          </ng-template>\n        </cx-file-upload>\n\n        <p class=\"cx-message-footer-info-text\">\n          {{\n            'chatMessaging.charactersLeft'\n              | cxTranslate: { count: inputCharacterLeft }\n          }}\n        </p>\n      </div>\n      <cx-form-errors\n        [control]=\"form.get('file')\"\n        prefix=\"formErrors.file\"\n      ></cx-form-errors>\n    </div>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: FilesFormValidators }]; }, propDecorators: { fileUploadComponent: [{
                type: ViewChild,
                args: [FileUploadComponent]
            }], messageEvents$: [{
                type: Input
            }], scrollToInput: [{
                type: Input
            }], messagingConfigs: [{
                type: Input
            }], send: [{
                type: Output
            }], downloadAttachment: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ChatMessagingModule {
}
ChatMessagingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ChatMessagingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ChatMessagingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ChatMessagingModule, declarations: [AvatarComponent, MessagingComponent], imports: [CommonModule,
        I18nModule,
        IconModule,
        FormsModule,
        ReactiveFormsModule,
        FileUploadModule,
        FormErrorsModule], exports: [AvatarComponent, MessagingComponent] });
ChatMessagingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ChatMessagingModule, imports: [CommonModule,
        I18nModule,
        IconModule,
        FormsModule,
        ReactiveFormsModule,
        FileUploadModule,
        FormErrorsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ChatMessagingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        IconModule,
                        FormsModule,
                        ReactiveFormsModule,
                        FileUploadModule,
                        FormErrorsModule,
                    ],
                    declarations: [AvatarComponent, MessagingComponent],
                    exports: [AvatarComponent, MessagingComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class BannerCarouselModule {
}
BannerCarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerCarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BannerCarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: BannerCarouselModule, declarations: [BannerCarouselComponent], imports: [CommonModule, PageComponentModule, CarouselModule, MediaModule], exports: [BannerCarouselComponent] });
BannerCarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerCarouselModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                RotatingImagesComponent: {
                    component: BannerCarouselComponent,
                },
            },
        }),
    ], imports: [CommonModule, PageComponentModule, CarouselModule, MediaModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerCarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, PageComponentModule, CarouselModule, MediaModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                RotatingImagesComponent: {
                                    component: BannerCarouselComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BannerCarouselComponent],
                    exports: [BannerCarouselComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class BannerComponent {
    constructor(component, urlService, cmsService) {
        this.component = component;
        this.urlService = urlService;
        this.cmsService = cmsService;
        this.data$ = this.component.data$.pipe(tap((data) => {
            this.setRouterLink(data);
            this.styleClasses = data.styleClasses;
        }));
    }
    /**
     * Returns `_blank` to force opening the link in a new window whenever the
     * `data.external` flag is set to true.
     */
    getTarget(data) {
        return data.external === 'true' || data.external === true ? '_blank' : null;
    }
    setRouterLink(data) {
        if (data.urlLink) {
            this.routerLink = data.urlLink;
        }
        else if (data.contentPage) {
            this.cmsService
                .getPage({
                id: data.contentPage,
                type: PageType.CONTENT_PAGE,
            })
                .pipe(take(1))
                .subscribe((page) => {
                this.routerLink = page?.label;
            });
        }
        else if (data.product) {
            this.routerLink = this.urlService.transform({
                cxRoute: 'product',
                params: { code: data.product },
            });
        }
        else if (data.category) {
            this.routerLink = this.urlService.transform({
                cxRoute: 'category',
                params: { code: data.category },
            });
        }
    }
    getImage(data) {
        if (data.media) {
            if ('url' in data.media) {
                return data.media;
            }
            else {
                return data.media;
            }
        }
    }
}
BannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerComponent, deps: [{ token: CmsComponentData }, { token: i1.SemanticPathService }, { token: i1.CmsService }], target: i0.ɵɵFactoryTarget.Component });
BannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: BannerComponent, selector: "cx-banner", host: { properties: { "class": "this.styleClasses" } }, ngImport: i0, template: "<ng-container *ngIf=\"data$ | async as data\">\n  <cx-generic-link\n    *ngIf=\"routerLink\"\n    [url]=\"routerLink\"\n    [target]=\"getTarget(data)\"\n  >\n    <p class=\"headline\" *ngIf=\"data.headline\" [innerHTML]=\"data.headline\"></p>\n    <cx-media [container]=\"getImage(data)\"></cx-media>\n    <p class=\"content\" *ngIf=\"data.content\" [innerHTML]=\"data.content\"></p>\n  </cx-generic-link>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }, { kind: "component", type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-banner', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"data$ | async as data\">\n  <cx-generic-link\n    *ngIf=\"routerLink\"\n    [url]=\"routerLink\"\n    [target]=\"getTarget(data)\"\n  >\n    <p class=\"headline\" *ngIf=\"data.headline\" [innerHTML]=\"data.headline\"></p>\n    <cx-media [container]=\"getImage(data)\"></cx-media>\n    <p class=\"content\" *ngIf=\"data.content\" [innerHTML]=\"data.content\"></p>\n  </cx-generic-link>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.SemanticPathService }, { type: i1.CmsService }]; }, propDecorators: { styleClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class BannerModule {
}
BannerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BannerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: BannerModule, declarations: [BannerComponent], imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule], exports: [BannerComponent] });
BannerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                SimpleResponsiveBannerComponent: {
                    component: BannerComponent,
                },
                BannerComponent: {
                    component: BannerComponent,
                },
                SimpleBannerComponent: {
                    component: BannerComponent,
                },
            },
        }),
    ], imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BannerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, GenericLinkModule, MediaModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                SimpleResponsiveBannerComponent: {
                                    component: BannerComponent,
                                },
                                BannerComponent: {
                                    component: BannerComponent,
                                },
                                SimpleBannerComponent: {
                                    component: BannerComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BannerComponent],
                    exports: [BannerComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class LinkComponent {
    constructor(component) {
        this.component = component;
        this.data$ = this.component.data$.pipe(tap((data) => (this.styleClasses = data?.styleClasses)));
    }
    /**
     * Returns `_blank` to force opening the link in a new window whenever the
     * `data.target` flag is set to `true`.
     */
    getTarget(data) {
        return data.target === 'true' || data.target === true ? '_blank' : null;
    }
}
LinkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LinkComponent, deps: [{ token: CmsComponentData }], target: i0.ɵɵFactoryTarget.Component });
LinkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: LinkComponent, selector: "cx-link", host: { properties: { "class": "this.styleClasses" } }, ngImport: i0, template: "<cx-generic-link\n  *ngIf=\"data$ | async as data\"\n  [url]=\"data.url ?? ''\"\n  [style]=\"data.styleAttributes\"\n  [target]=\"getTarget(data)\"\n  >{{ data.linkName }}</cx-generic-link\n>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LinkComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-link', changeDetection: ChangeDetectionStrategy.OnPush, template: "<cx-generic-link\n  *ngIf=\"data$ | async as data\"\n  [url]=\"data.url ?? ''\"\n  [style]=\"data.styleAttributes\"\n  [target]=\"getTarget(data)\"\n  >{{ data.linkName }}</cx-generic-link\n>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }]; }, propDecorators: { styleClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class LinkModule {
}
LinkModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LinkModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LinkModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: LinkModule, declarations: [LinkComponent], imports: [CommonModule, RouterModule, GenericLinkModule], exports: [LinkComponent] });
LinkModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LinkModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CMSLinkComponent: { component: LinkComponent },
            },
        }),
    ], imports: [CommonModule, RouterModule, GenericLinkModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LinkModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, GenericLinkModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSLinkComponent: { component: LinkComponent },
                            },
                        }),
                    ],
                    declarations: [LinkComponent],
                    exports: [LinkComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/*
 * Supplements the anchor links that contain only the hash fragment in the `href` attribute,
 * (e.g. `<a href="#someId">`), by prepending the current location (path and query params),
 * so it becomes a link to a full url
 * e.g. `<a href="https://domain.com/current/path?and=query-params#someId">`.
 *
 * This helps to avoid the undesirable navigation to the homepage URL (`/#someId`)
 * when clicking the original link.
 *
 * It's useful for example for cms-provided content passed to the [innerHTML] directive.
 */
class SupplementHashAnchorsPipe {
    constructor(renderer, winRef) {
        this.renderer = renderer;
        this.winRef = winRef;
    }
    getPath(anchorId) {
        const currentUrlWithoutFragment = this.winRef.location.href?.replace(/#.*$/, '');
        return `${currentUrlWithoutFragment}${anchorId}`;
    }
    transform(html = '') {
        const template = this.renderer.createElement('template');
        template.innerHTML = html.trim();
        const linkNodes = template.content.querySelectorAll('a');
        Array.from(linkNodes).forEach((link) => {
            const href = link.getAttribute('href');
            if (href?.indexOf('#') === 0) {
                this.renderer.setProperty(link, 'href', this.getPath(href));
            }
        });
        return template.innerHTML;
    }
}
SupplementHashAnchorsPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SupplementHashAnchorsPipe, deps: [{ token: i0.Renderer2 }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Pipe });
SupplementHashAnchorsPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SupplementHashAnchorsPipe, name: "cxSupplementHashAnchors" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SupplementHashAnchorsPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'cxSupplementHashAnchors' }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i1.WindowRef }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ParagraphComponent {
    handleClick(event) {
        if (event.target instanceof HTMLAnchorElement) {
            const element = event.target;
            const href = element?.getAttribute('href');
            const documentHost = element.ownerDocument.URL.split('://')[1].split('/')[0];
            // Use router for internal link navigation
            if (href && documentHost === element.host) {
                event.preventDefault();
                this.router.navigateByUrl(href);
            }
        }
    }
    constructor(component, router) {
        this.component = component;
        this.router = router;
    }
}
ParagraphComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ParagraphComponent, deps: [{ token: CmsComponentData }, { token: i1$2.Router }], target: i0.ɵɵFactoryTarget.Component });
ParagraphComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ParagraphComponent, selector: "cx-paragraph", host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0, template: "<div\n  *ngIf=\"component.data$ | async as data\"\n  [innerHTML]=\"data.content ?? '' | cxSupplementHashAnchors\"\n></div>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: SupplementHashAnchorsPipe, name: "cxSupplementHashAnchors" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ParagraphComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-paragraph', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  *ngIf=\"component.data$ | async as data\"\n  [innerHTML]=\"data.content ?? '' | cxSupplementHashAnchors\"\n></div>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1$2.Router }]; }, propDecorators: { handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SupplementHashAnchorsModule {
}
SupplementHashAnchorsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SupplementHashAnchorsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SupplementHashAnchorsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SupplementHashAnchorsModule, declarations: [SupplementHashAnchorsPipe], exports: [SupplementHashAnchorsPipe] });
SupplementHashAnchorsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SupplementHashAnchorsModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SupplementHashAnchorsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [SupplementHashAnchorsPipe],
                    exports: [SupplementHashAnchorsPipe],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CmsParagraphModule {
}
CmsParagraphModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsParagraphModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CmsParagraphModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: CmsParagraphModule, declarations: [ParagraphComponent], imports: [CommonModule, RouterModule, SupplementHashAnchorsModule], exports: [ParagraphComponent] });
CmsParagraphModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsParagraphModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CMSParagraphComponent: {
                    component: ParagraphComponent,
                },
                CMSTabParagraphComponent: {
                    component: ParagraphComponent,
                },
            },
        }),
    ], imports: [CommonModule, RouterModule, SupplementHashAnchorsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CmsParagraphModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, SupplementHashAnchorsModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSParagraphComponent: {
                                    component: ParagraphComponent,
                                },
                                CMSTabParagraphComponent: {
                                    component: ParagraphComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ParagraphComponent],
                    exports: [ParagraphComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PDFComponent {
    constructor(component, mediaService) {
        this.component = component;
        this.mediaService = mediaService;
        this.data$ = this.component.data$.pipe(tap((data) => {
            if (data?.pdfFile?.url) {
                this.url = this.mediaService.getMedia(data.pdfFile)?.src;
            }
        }));
    }
    addPdfExtension(title) {
        if (!title) {
            return '';
        }
        const trimTitle = title.trim();
        return trimTitle.endsWith('.pdf') ? trimTitle : `${trimTitle}.pdf`;
    }
}
PDFComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PDFComponent, deps: [{ token: CmsComponentData }, { token: MediaService }], target: i0.ɵɵFactoryTarget.Component });
PDFComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PDFComponent, selector: "cx-pdf", ngImport: i0, template: "<ng-container *ngIf=\"data$ | async as data\">\n  <div class=\"pdf-container\">\n    <a [href]=\"url\" target=\"_blank\" rel=\"noopener noreferrer\">\n      <span>{{\n        addPdfExtension(\n          data?.title ||\n            data?.pdfFile?.altText ||\n            ('pdf.defaultTitle' | cxTranslate)\n        )\n      }}</span>\n      <span aria-hidden=\"true\">\n        <cx-icon [type]=\"'PDF_FILE'\"></cx-icon>\n      </span>\n    </a>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PDFComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-pdf', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"data$ | async as data\">\n  <div class=\"pdf-container\">\n    <a [href]=\"url\" target=\"_blank\" rel=\"noopener noreferrer\">\n      <span>{{\n        addPdfExtension(\n          data?.title ||\n            data?.pdfFile?.altText ||\n            ('pdf.defaultTitle' | cxTranslate)\n        )\n      }}</span>\n      <span aria-hidden=\"true\">\n        <cx-icon [type]=\"'PDF_FILE'\"></cx-icon>\n      </span>\n    </a>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: MediaService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PDFModule {
}
PDFModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PDFModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PDFModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PDFModule, declarations: [PDFComponent], imports: [CommonModule, IconModule, I18nModule], exports: [PDFComponent] });
PDFModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PDFModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                PDFDocumentComponent: {
                    component: PDFComponent,
                },
            },
        }),
    ], imports: [CommonModule, IconModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PDFModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IconModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                PDFDocumentComponent: {
                                    component: PDFComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [PDFComponent],
                    exports: [PDFComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TabParagraphContainerComponent {
    constructor(componentData, cmsService, winRef) {
        this.componentData = componentData;
        this.cmsService = cmsService;
        this.winRef = winRef;
        this.activeTabNum = 0;
        this.tabTitleParams = [];
        this.components$ = this.componentData.data$.pipe(distinctUntilChanged((x, y) => x?.components === y?.components), tap((data) => {
            this.ariaLabel = `${data?.uid}.tabPanelContainerRegion`;
        }), switchMap((data) => combineLatest((data?.components ?? '').split(' ').map((component) => this.cmsService.getComponentData(component).pipe(distinctUntilChanged(), map((tab) => {
            if (!tab) {
                return undefined;
            }
            if (!tab.flexType) {
                tab = {
                    ...tab,
                    flexType: tab.typeCode,
                };
            }
            return {
                ...tab,
                title: `${data.uid}.tabs.${tab.uid}`,
            };
        }))))));
    }
    select(tabNum, event) {
        this.activeTabNum = this.activeTabNum === tabNum ? -1 : tabNum;
        if (event && event?.target) {
            const target = event.target;
            const parentNode = target.parentNode;
            this.winRef?.nativeWindow?.scrollTo({
                left: 0,
                top: parentNode.offsetTop,
                behavior: 'smooth',
            });
        }
    }
    ngOnInit() {
        this.activeTabNum =
            this.winRef?.nativeWindow?.history?.state?.activeTab ?? this.activeTabNum;
    }
    ngAfterViewInit() {
        // If the sub cms components data exist, the components created before ngAfterViewInit are called.
        // In this case, the title parameters are directly pulled from them.
        if (this.children.length > 0) {
            this.getTitleParams(this.children);
        }
    }
    tabCompLoaded(componentRef) {
        this.tabTitleParams.push(componentRef.instance.tabTitleParam$);
    }
    getTitleParams(children) {
        children.forEach((comp) => {
            this.tabTitleParams.push(comp['cmpRef']?.instance.tabTitleParam$ ?? null);
        });
    }
}
TabParagraphContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabParagraphContainerComponent, deps: [{ token: CmsComponentData }, { token: i1.CmsService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Component });
TabParagraphContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: TabParagraphContainerComponent, selector: "cx-tab-paragraph-container", viewQueries: [{ propertyName: "children", predicate: ComponentWrapperDirective, descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"components$ | async as components\">\n  <div\n    role=\"region\"\n    tabindex=\"-1\"\n    [attr.aria-label]=\"ariaLabel | cxTranslate\"\n    class=\"container\"\n  >\n    <ng-container *ngFor=\"let component of components; let i = index\">\n      <ng-container *ngIf=\"component\">\n        <button\n          [class.active]=\"i === activeTabNum\"\n          (click)=\"select(i, $event)\"\n          [attr.aria-expanded]=\"i === activeTabNum\"\n        >\n          {{\n            component.title | cxTranslate: { param: tabTitleParams[i] | async }\n          }}\n\n          <span class=\"accordion-icon\" aria-hidden=\"true\"></span>\n        </button>\n\n        <div\n          [class.active]=\"i === activeTabNum\"\n          class=\"cx-tab-paragraph-content\"\n          tabindex=\"0\"\n          role=\"presentation\"\n        >\n          <ng-template [cxOutlet]=\"component.flexType\" [cxOutletContext]=\"{}\">\n            <ng-container\n              [cxComponentWrapper]=\"component\"\n              (cxComponentRef)=\"tabCompLoaded($event)\"\n            ></ng-container>\n          </ng-template>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabParagraphContainerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-tab-paragraph-container', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"components$ | async as components\">\n  <div\n    role=\"region\"\n    tabindex=\"-1\"\n    [attr.aria-label]=\"ariaLabel | cxTranslate\"\n    class=\"container\"\n  >\n    <ng-container *ngFor=\"let component of components; let i = index\">\n      <ng-container *ngIf=\"component\">\n        <button\n          [class.active]=\"i === activeTabNum\"\n          (click)=\"select(i, $event)\"\n          [attr.aria-expanded]=\"i === activeTabNum\"\n        >\n          {{\n            component.title | cxTranslate: { param: tabTitleParams[i] | async }\n          }}\n\n          <span class=\"accordion-icon\" aria-hidden=\"true\"></span>\n        </button>\n\n        <div\n          [class.active]=\"i === activeTabNum\"\n          class=\"cx-tab-paragraph-content\"\n          tabindex=\"0\"\n          role=\"presentation\"\n        >\n          <ng-template [cxOutlet]=\"component.flexType\" [cxOutletContext]=\"{}\">\n            <ng-container\n              [cxComponentWrapper]=\"component\"\n              (cxComponentRef)=\"tabCompLoaded($event)\"\n            ></ng-container>\n          </ng-template>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.CmsService }, { type: i1.WindowRef }]; }, propDecorators: { children: [{
                type: ViewChildren,
                args: [ComponentWrapperDirective]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class TabParagraphContainerModule {
}
TabParagraphContainerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabParagraphContainerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TabParagraphContainerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: TabParagraphContainerModule, declarations: [TabParagraphContainerComponent], imports: [CommonModule, PageComponentModule, OutletModule, I18nModule], exports: [TabParagraphContainerComponent] });
TabParagraphContainerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabParagraphContainerModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CMSTabParagraphContainer: {
                    component: TabParagraphContainerComponent,
                },
            },
        }),
    ], imports: [CommonModule, PageComponentModule, OutletModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: TabParagraphContainerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, PageComponentModule, OutletModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSTabParagraphContainer: {
                                    component: TabParagraphContainerComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [TabParagraphContainerComponent],
                    exports: [TabParagraphContainerComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class VideoComponent {
    constructor(component, mediaService, urlService, cmsService, cd) {
        this.component = component;
        this.mediaService = mediaService;
        this.urlService = urlService;
        this.cmsService = cmsService;
        this.cd = cd;
        this.data$ = this.component.data$.pipe(distinctUntilChanged(), tap((data) => {
            this.styleClasses = data.styleClasses;
            this.setMedia(data);
            this.setControls(data);
            this.setRouting(data);
        }));
    }
    setMedia(data) {
        if (data.video) {
            this.source = this.mediaService.getMedia(data.video)?.src;
        }
        if (data?.containerBackground ===
            ContainerBackgroundOptions.UPLOAD_RESPONSIVE_IMAGE &&
            data?.videoMedia) {
            this.thumbnail = this.mediaService.getMedia(data.videoMedia);
        }
        else if (data?.thumbnailSelector === ContainerBackgroundOptions.UPLOAD_THUMBNAIL &&
            data?.thumbnail) {
            this.thumbnail = this.mediaService.getMedia(data.thumbnail);
        }
        else {
            this.thumbnail = undefined;
        }
    }
    setControls(data) {
        this.autoPlay = data.autoPlay === 'true';
        this.loop = data.loop === 'true';
        this.mute = data.mute === 'true' ? 'muted' : undefined;
    }
    setRouting(data) {
        if (data.url) {
            this.routerLink = data.url;
        }
        else if (data.contentPage) {
            this.cmsService
                .getPage({
                id: data.contentPage,
                type: PageType.CONTENT_PAGE,
            })
                .pipe(take(1))
                .subscribe((page) => {
                this.routerLink = page?.label;
                this.cd.markForCheck();
            });
        }
        else if (data.product) {
            this.routerLink = this.urlService.transform({
                cxRoute: 'product',
                params: { code: data.product },
            });
        }
        else if (data.category) {
            this.routerLink = this.urlService.transform({
                cxRoute: 'category',
                params: { code: data.category },
            });
        }
    }
}
VideoComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: VideoComponent, deps: [{ token: CmsComponentData }, { token: MediaService }, { token: i1.SemanticPathService }, { token: i1.CmsService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
VideoComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: VideoComponent, selector: "cx-video", host: { properties: { "class": "this.styleClasses" } }, ngImport: i0, template: "<div\n  *ngIf=\"data$ | async as data; else loading\"\n  class=\"video-container\"\n  tabindex=\"-1\"\n>\n  <a *ngIf=\"data.overlayTitle\" [routerLink]=\"routerLink\">{{\n    data.overlayTitle\n  }}</a>\n  <video\n    *ngIf=\"source\"\n    [style.height.px]=\"data.videoContainerHeight\"\n    controls\n    [poster]=\"thumbnail?.src\"\n    [loop]=\"loop\"\n    [autoplay]=\"autoPlay\"\n    [muted]=\"mute\"\n    [attr.aria-label]=\"'player.label' | cxTranslate\"\n    [src]=\"source\"\n  ></video>\n</div>\n\n<ng-template #loading>\n  <div class=\"cx-spinner\"><cx-spinner></cx-spinner></div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: VideoComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-video', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  *ngIf=\"data$ | async as data; else loading\"\n  class=\"video-container\"\n  tabindex=\"-1\"\n>\n  <a *ngIf=\"data.overlayTitle\" [routerLink]=\"routerLink\">{{\n    data.overlayTitle\n  }}</a>\n  <video\n    *ngIf=\"source\"\n    [style.height.px]=\"data.videoContainerHeight\"\n    controls\n    [poster]=\"thumbnail?.src\"\n    [loop]=\"loop\"\n    [autoplay]=\"autoPlay\"\n    [muted]=\"mute\"\n    [attr.aria-label]=\"'player.label' | cxTranslate\"\n    [src]=\"source\"\n  ></video>\n</div>\n\n<ng-template #loading>\n  <div class=\"cx-spinner\"><cx-spinner></cx-spinner></div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: MediaService }, { type: i1.SemanticPathService }, { type: i1.CmsService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { styleClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class VideoModule {
}
VideoModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: VideoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
VideoModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: VideoModule, declarations: [VideoComponent], imports: [CommonModule,
        RouterModule,
        GenericLinkModule,
        MediaModule,
        I18nModule,
        SpinnerModule], exports: [VideoComponent] });
VideoModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: VideoModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                VideoComponent: {
                    component: VideoComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        RouterModule,
        GenericLinkModule,
        MediaModule,
        I18nModule,
        SpinnerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: VideoModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        GenericLinkModule,
                        MediaModule,
                        I18nModule,
                        SpinnerModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                VideoComponent: {
                                    component: VideoComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [VideoComponent],
                    exports: [VideoComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2022 SAP Spartacus team <spartacus-team@sap.com>
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Get strings for phone and mobile numbers
 */
function getAddressNumbers(address, textPhone, textMobile) {
    if (address.cellphone && address.phone) {
        if (address.cellphone === address.phone) {
            return textMobile + ': ' + address.cellphone;
        }
        return `${textPhone}: ${address.phone}\n${textMobile}: ${address.cellphone}`;
    }
    if (address.cellphone) {
        return textMobile + ': ' + address.cellphone;
    }
    if (address.phone) {
        return textPhone + ': ' + address.phone;
    }
    return undefined;
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AddressBookComponentService {
    constructor(userAddressService) {
        this.userAddressService = userAddressService;
    }
    getAddresses() {
        return this.userAddressService.getAddresses();
    }
    getAddressesStateLoading() {
        return this.userAddressService.getAddressesLoading();
    }
    loadAddresses() {
        this.userAddressService.loadAddresses();
    }
    addUserAddress(address) {
        this.userAddressService.addUserAddress(address);
    }
    updateUserAddress(addressId, address) {
        this.userAddressService.updateUserAddress(addressId, address);
    }
    setAddressAsDefault(addressId) {
        this.userAddressService.setAddressAsDefault(addressId);
    }
    deleteUserAddress(addressId) {
        this.userAddressService.deleteUserAddress(addressId);
    }
}
AddressBookComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressBookComponentService, deps: [{ token: i1.UserAddressService }], target: i0.ɵɵFactoryTarget.Injectable });
AddressBookComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressBookComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressBookComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.UserAddressService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const titleScores = {
    mr: 1,
    mrs: 2,
    miss: 3,
    ms: 4,
    dr: 5,
    rev: 6,
};
function sortTitles(title1, title2) {
    if (title1.code && title2.code) {
        if (!titleScores[title1.code] || !titleScores[title2.code]) {
            return 1;
        }
        else {
            return titleScores[title1.code] - titleScores[title2.code];
        }
    }
    return 1;
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SkipLinkConfig {
}
SkipLinkConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SkipLinkConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });
class SkipLink {
}
var SkipLinkScrollPosition;
(function (SkipLinkScrollPosition) {
    SkipLinkScrollPosition["BEFORE"] = "BEFORE";
    SkipLinkScrollPosition["AFTER"] = "AFTER";
})(SkipLinkScrollPosition || (SkipLinkScrollPosition = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SkipLinkService {
    constructor(config, keyboardFocusService) {
        this.config = config;
        this.keyboardFocusService = keyboardFocusService;
        this.skipLinks$ = new BehaviorSubject([]);
    }
    getSkipLinks() {
        return this.skipLinks$;
    }
    add(key, target) {
        const found = this.config.skipLinks?.find((skipLink) => skipLink.key === key);
        if (found) {
            const existing = this.skipLinks$.value;
            existing.splice(this.getSkipLinkIndexInArray(key), 0, {
                target,
                i18nKey: found.i18nKey,
                position: found.position,
                key,
            });
            this.skipLinks$.next(existing);
        }
    }
    remove(key) {
        const found = this.config.skipLinks?.find((skipLink) => skipLink.key === key);
        if (found) {
            let existing = this.skipLinks$.value;
            existing = existing.filter((skipLink) => skipLink.key !== key);
            this.skipLinks$.next(existing);
        }
    }
    scrollToTarget(skipLink) {
        const target = skipLink.target instanceof HTMLElement
            ? skipLink.target
            : skipLink.target?.parentElement;
        // focus first focusable element in the
        const firstFocusable = this.keyboardFocusService.findFirstFocusable(target) || target;
        // we force a tabindex if not available, to ensure we can focus into the element
        const hasTabindex = firstFocusable?.hasAttribute('tabindex');
        if (!hasTabindex) {
            firstFocusable?.setAttribute('tabindex', '-1');
        }
        firstFocusable?.focus();
        // drop the tmp tabindex
        if (!hasTabindex) {
            firstFocusable?.removeAttribute('tabindex');
        }
    }
    getSkipLinkIndexInArray(key) {
        let index = this.config.skipLinks?.findIndex((skipLink) => skipLink.key === key) ?? 0;
        while (index > 0) {
            index--;
            const previous = this.config.skipLinks?.[index];
            if (previous) {
                const existing = this.skipLinks$.value;
                const found = existing.findIndex((skipLink) => skipLink.key === previous.key);
                if (found > -1) {
                    return found + 1;
                }
            }
        }
        return 0;
    }
}
SkipLinkService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkService, deps: [{ token: SkipLinkConfig }, { token: KeyboardFocusService }], target: i0.ɵɵFactoryTarget.Injectable });
SkipLinkService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: SkipLinkConfig }, { type: KeyboardFocusService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SkipLinkComponent {
    constructor(skipLinkService) {
        this.skipLinkService = skipLinkService;
        this.skipLinks$ = this.skipLinkService.getSkipLinks();
    }
    scrollToTarget(skipLink) {
        this.skipLinkService.scrollToTarget(skipLink);
    }
}
SkipLinkComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkComponent, deps: [{ token: SkipLinkService }], target: i0.ɵɵFactoryTarget.Component });
SkipLinkComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: SkipLinkComponent, selector: "cx-skip-link", ngImport: i0, template: "<div [cxFocus]=\"{ tab: true }\" *ngIf=\"skipLinks$ | async as links\">\n  <button *ngFor=\"let link of links\" (click)=\"scrollToTarget(link)\">\n    {{ 'skipLink.skipTo' | cxTranslate }}\n    {{ link.i18nKey | cxTranslate }}\n  </button>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-skip-link', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div [cxFocus]=\"{ tab: true }\" *ngIf=\"skipLinks$ | async as links\">\n  <button *ngFor=\"let link of links\" (click)=\"scrollToTarget(link)\">\n    {{ 'skipLink.skipTo' | cxTranslate }}\n    {{ link.i18nKey | cxTranslate }}\n  </button>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: SkipLinkService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultSkipLinkConfig = {
    skipLinks: [
        {
            key: 'cx-header',
            i18nKey: 'skipLink.labels.header',
        },
        {
            key: 'cx-main',
            i18nKey: 'skipLink.labels.main',
        },
        { key: 'cx-footer', i18nKey: 'skipLink.labels.footer' },
    ],
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SkipLinkDirective {
    constructor(elementRef, skipLinkService) {
        this.elementRef = elementRef;
        this.skipLinkService = skipLinkService;
    }
    ngOnInit() {
        this.skipLinkService.add(this.cxSkipLink, this.elementRef.nativeElement);
    }
    ngOnDestroy() {
        this.skipLinkService.remove(this.cxSkipLink);
    }
}
SkipLinkDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkDirective, deps: [{ token: i0.ElementRef }, { token: SkipLinkService }], target: i0.ɵɵFactoryTarget.Directive });
SkipLinkDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: SkipLinkDirective, selector: "[cxSkipLink]", inputs: { cxSkipLink: "cxSkipLink" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cxSkipLink]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: SkipLinkService }]; }, propDecorators: { cxSkipLink: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SkipLinkModule {
}
SkipLinkModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SkipLinkModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkModule, declarations: [SkipLinkComponent, SkipLinkDirective], imports: [CommonModule,
        I18nModule, i1.ConfigModule, KeyboardFocusModule], exports: [SkipLinkDirective] });
SkipLinkModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkModule, providers: [
        provideDefaultConfig(defaultSkipLinkConfig),
        {
            provide: APP_INITIALIZER,
            useFactory: skipLinkFactory,
            deps: [ComponentFactoryResolver, OutletService],
            multi: true,
        },
    ], imports: [CommonModule,
        I18nModule,
        ConfigModule.withConfig(defaultSkipLinkConfig),
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SkipLinkModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        ConfigModule.withConfig(defaultSkipLinkConfig),
                        KeyboardFocusModule,
                    ],
                    declarations: [SkipLinkComponent, SkipLinkDirective],
                    exports: [SkipLinkDirective],
                    providers: [
                        provideDefaultConfig(defaultSkipLinkConfig),
                        {
                            provide: APP_INITIALIZER,
                            useFactory: skipLinkFactory,
                            deps: [ComponentFactoryResolver, OutletService],
                            multi: true,
                        },
                    ],
                }]
        }] });
/**
 * Adds the skip link component before the cx-storefront.
 */
function skipLinkFactory(componentFactoryResolver, outletService) {
    const isReady = () => {
        const factory = componentFactoryResolver.resolveComponentFactory(SkipLinkComponent);
        outletService.add('cx-storefront', factory, OutletPosition.BEFORE);
    };
    return isReady;
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultLayoutConfig = {
    breakpoints: {
        xs: 576,
        sm: 768,
        md: 992,
        lg: 1200,
        xl: {
            min: 1200,
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The direction config provides an easy way to configure "ltr" versus "rtl" direction
 * for the storefront. The direction can be configured to detect the direction by language.
 *
 * The following configuration detects rtl languages by isoCode for Arabic and Hebrew:
 *
 * ```typescript
 * direction: {
 *   detect: true,
 *   default: DirectionMode.LTR,
 *   rtlLanguages: ['ar', 'he']
 * }
 * ```
 */
class DirectionConfig {
}
DirectionConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DirectionConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultDirectionConfig = {
    direction: {
        detect: true,
        default: DirectionMode.LTR,
        // we're not polluting the system with all defaults for ltr, but add 2 common used
        // languages (hebrew and arabic) to easily demo directionality
        // see https://meta.wikimedia.org/wiki/Template:List_of_language_names_ordered_by_code
        rtlLanguages: ['he', 'ar'],
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The `DirectionService` can be used to add the direction to the overall storefront or individual elements.
 * By default, the direction is added to the `html` element (i.e. `<html dir="ltr">`). The API of this service
 * does however provide methods to add direction to individual elements if needed.
 *
 * The direction is configurable and allows for language driven direction configuration.
 *
 * To react to the active language, the service subscribes to the active language in the initialize method. This
 * is called from an APP_INITIALIZER method and should only happen once.
 */
class DirectionService {
    constructor(configInit, languageService, winRef) {
        this.configInit = configInit;
        this.languageService = languageService;
        this.winRef = winRef;
        this.startsDetecting = false;
        this.subscription = new Subscription();
    }
    /**
     * Initializes the layout direction for the storefront.
     */
    initialize() {
        return this.configInit
            .getStable('direction')
            .pipe(tap((config) => {
            this.config = config?.direction;
            if (this.config?.detect) {
                this.detect();
            }
            else {
                this.setDirection(this.winRef.document.documentElement, this.config?.default);
            }
        }))
            .toPromise();
    }
    /**
     * Observes the _active_ language and set the required direction for the given language.
     * The method is guarded to ensure that the active language is observed only once.
     */
    detect() {
        if (this.startsDetecting) {
            return;
        }
        this.subscription.add(this.languageService
            .getActive()
            .subscribe((isoCode) => this.setDirection(this.winRef.document.documentElement, this.getDirection(isoCode))));
        this.startsDetecting = true;
    }
    /**
     * Sets the direction attribute for the given element. If the direction is undefined, the `dir`
     * attribute is removed.
     */
    setDirection(el, direction) {
        if (direction) {
            el.setAttribute('dir', direction);
        }
        else {
            el.removeAttribute('dir');
        }
    }
    /**
     * Gets the `DirectionMode` for the given language isoCode. The language isoCode is compared
     * to the configured list of languages(`direction.rtlLanguages` vs `direction.ltrLanguages`).
     *
     * If no language is given, or no language mapping could be found, we fallback to the default
     * `direction.mode`.
     */
    getDirection(language) {
        if (language && this.config?.rtlLanguages?.includes(language)) {
            return DirectionMode.RTL;
        }
        if (language && this.config?.ltrLanguages?.includes(language)) {
            return DirectionMode.LTR;
        }
        return this.config?.default;
    }
    ngOnDestroy() {
        // Cleans up the subscription, to avoid memory leaks in SSR.
        this.subscription.unsubscribe();
    }
}
DirectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionService, deps: [{ token: i1.ConfigInitializerService }, { token: i1.LanguageService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Injectable });
DirectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ConfigInitializerService }, { type: i1.LanguageService }, { type: i1.WindowRef }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
function initHtmlDirAttribute(directionService, featureConfigService) {
    const result = () => {
        if (featureConfigService.isLevel('2.1')) {
            return directionService.initialize();
        }
    };
    return result;
}
/**
 * Provides a configuration and APP_INITIALIZER to add the correct (language drive) html direction.
 */
class DirectionModule {
}
DirectionModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DirectionModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: DirectionModule });
DirectionModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionModule, providers: [
        {
            provide: APP_INITIALIZER,
            multi: true,
            useFactory: initHtmlDirAttribute,
            deps: [DirectionService, FeatureConfigService],
        },
        provideDefaultConfig(defaultDirectionConfig),
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: DirectionModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: APP_INITIALIZER,
                            multi: true,
                            useFactory: initHtmlDirAttribute,
                            deps: [DirectionService, FeatureConfigService],
                        },
                        provideDefaultConfig(defaultDirectionConfig),
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class HamburgerMenuService {
    constructor(router) {
        this.isExpanded = new BehaviorSubject(false);
        router.events
            .pipe(filter((event) => event instanceof NavigationStart))
            .subscribe(() => {
            this.toggle(true);
        });
    }
    /**
     * toggles the expand state of the hamburger menu
     */
    toggle(forceCollapse) {
        if (forceCollapse) {
            this.isExpanded.next(false);
        }
        else {
            this.isExpanded.next(!this.isExpanded.value);
        }
    }
}
HamburgerMenuService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuService, deps: [{ token: i1$2.Router }], target: i0.ɵɵFactoryTarget.Injectable });
HamburgerMenuService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$2.Router }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class HamburgerMenuComponent {
    constructor(hamburgerMenuService) {
        this.hamburgerMenuService = hamburgerMenuService;
    }
    toggle() {
        this.hamburgerMenuService.toggle();
    }
    get isExpanded() {
        return this.hamburgerMenuService.isExpanded;
    }
}
HamburgerMenuComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuComponent, deps: [{ token: HamburgerMenuService }], target: i0.ɵɵFactoryTarget.Component });
HamburgerMenuComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: HamburgerMenuComponent, selector: "cx-hamburger-menu", ngImport: i0, template: "<button\n  class=\"cx-hamburger\"\n  type=\"button\"\n  (click)=\"toggle()\"\n  [class.is-active]=\"isExpanded | async\"\n  [attr.aria-expanded]=\"isExpanded | async\"\n  [attr.aria-label]=\"'common.menu' | cxTranslate\"\n  aria-controls=\"cx-header\"\n>\n  <span class=\"hamburger-box\">\n    <span class=\"hamburger-inner\"></span>\n  </span>\n</button>\n", dependencies: [{ kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-hamburger-menu', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  class=\"cx-hamburger\"\n  type=\"button\"\n  (click)=\"toggle()\"\n  [class.is-active]=\"isExpanded | async\"\n  [attr.aria-expanded]=\"isExpanded | async\"\n  [attr.aria-label]=\"'common.menu' | cxTranslate\"\n  aria-controls=\"cx-header\"\n>\n  <span class=\"hamburger-box\">\n    <span class=\"hamburger-inner\"></span>\n  </span>\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: HamburgerMenuService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class HamburgerMenuModule {
}
HamburgerMenuModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
HamburgerMenuModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuModule, declarations: [HamburgerMenuComponent], imports: [CommonModule, I18nModule], exports: [HamburgerMenuComponent] });
HamburgerMenuModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                HamburgerMenuComponent: {
                    component: HamburgerMenuComponent,
                },
            },
        }),
    ], imports: [CommonModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HamburgerMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                HamburgerMenuComponent: {
                                    component: HamburgerMenuComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [HamburgerMenuComponent],
                    exports: [HamburgerMenuComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ThemeService {
    constructor(config, rendererFactory) {
        this.config = config;
        this.rendererFactory = rendererFactory;
    }
    /**
     * This function is to be called for the root component that is
     * bootstrapped.
     */
    init(rootComponent) {
        this.renderer = this.rendererFactory.createRenderer(null, null);
        this.rootComponent = rootComponent;
        // Theme value is a string. It is put in the generic multi-value
        // property of the SiteContextConfig. So the array's first item
        // is the theme value.
        this.setTheme(this.config.context?.[THEME_CONTEXT_ID]?.[0]);
    }
    setTheme(theme) {
        if (theme) {
            const element = this.rootComponent.location.nativeElement;
            // remove the old theme
            this.renderer.removeClass(element, this.existingTheme);
            // add the new theme
            this.renderer.addClass(element, theme);
            this.existingTheme = theme;
        }
    }
}
ThemeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ThemeService, deps: [{ token: i1.SiteContextConfig }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });
ThemeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ThemeService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ThemeService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.SiteContextConfig }, { type: i0.RendererFactory2 }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
function initTheme(themeService) {
    const result = (component) => themeService.init(component);
    return result;
}
class ThemeModule {
}
ThemeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ThemeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ThemeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ThemeModule });
ThemeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ThemeModule, providers: [
        {
            provide: APP_BOOTSTRAP_LISTENER,
            multi: true,
            useFactory: initTheme,
            deps: [ThemeService],
        },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ThemeModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        {
                            provide: APP_BOOTSTRAP_LISTENER,
                            multi: true,
                            useFactory: initTheme,
                            deps: [ThemeService],
                        },
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class LayoutModule {
}
LayoutModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LayoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LayoutModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: LayoutModule, imports: [OutletRefModule, LaunchDialogModule, DirectionModule,
        ThemeModule], exports: [OutletRefModule] });
LayoutModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LayoutModule, providers: [provideDefaultConfig(defaultLayoutConfig)], imports: [OutletRefModule,
        LaunchDialogModule.forRoot(),
        DirectionModule,
        ThemeModule, OutletRefModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LayoutModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        OutletRefModule,
                        LaunchDialogModule.forRoot(),
                        DirectionModule,
                        ThemeModule,
                    ],
                    providers: [provideDefaultConfig(defaultLayoutConfig)],
                    exports: [OutletRefModule],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var StorefrontOutlets;
(function (StorefrontOutlets) {
    StorefrontOutlets["STOREFRONT"] = "cx-storefront";
})(StorefrontOutlets || (StorefrontOutlets = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class StorefrontComponent {
    handleEscape(event) {
        this.keyboardFocusService.handleEscape(this.elementRef.nativeElement, this.keyboardFocusConfig, event);
    }
    constructor(hamburgerMenuService, routingService, elementRef, keyboardFocusService) {
        this.hamburgerMenuService = hamburgerMenuService;
        this.routingService = routingService;
        this.elementRef = elementRef;
        this.keyboardFocusService = keyboardFocusService;
        this.isExpanded$ = this.hamburgerMenuService.isExpanded;
        this.StorefrontOutlets = StorefrontOutlets;
        this.role = 'presentation';
        // required by esc focus
        this.tabindex = '0';
        this.keyboardFocusConfig = {
            focusOnEscape: true,
            focusOnDoubleEscape: true,
        };
    }
    ngOnInit() {
        this.navigateSubscription = this.routingService
            .isNavigating()
            .subscribe((val) => {
            this.startNavigating = val === true;
            this.stopNavigating = val === false;
        });
    }
    collapseMenuIfClickOutside(event) {
        const element = event.target;
        if (element.nodeName.toLowerCase() === 'header' &&
            element.className.includes('is-expanded')) {
            this.collapseMenu();
        }
    }
    collapseMenu() {
        this.hamburgerMenuService.toggle(true);
    }
    ngOnDestroy() {
        if (this.navigateSubscription) {
            this.navigateSubscription.unsubscribe();
        }
    }
}
StorefrontComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StorefrontComponent, deps: [{ token: HamburgerMenuService }, { token: i1.RoutingService }, { token: i0.ElementRef }, { token: KeyboardFocusService }], target: i0.ɵɵFactoryTarget.Component });
StorefrontComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: StorefrontComponent, selector: "cx-storefront", host: { listeners: { "keydown.escape": "handleEscape($event)" }, properties: { "class.start-navigating": "this.startNavigating", "class.stop-navigating": "this.stopNavigating", "attr.role": "this.role", "tabindex": "this.tabindex" } }, viewQueries: [{ propertyName: "child", first: true, predicate: SkipLinkComponent, descendants: true }], ngImport: i0, template: "<ng-template [cxOutlet]=\"StorefrontOutlets.STOREFRONT\" cxPageTemplateStyle>\n  <ng-template cxOutlet=\"cx-header\">\n    <header\n      id=\"cx-header\"\n      cxSkipLink=\"cx-header\"\n      [cxFocus]=\"{ disableMouseFocus: true }\"\n      [class.is-expanded]=\"isExpanded$ | async\"\n      (keydown.escape)=\"collapseMenu()\"\n      (click)=\"collapseMenuIfClickOutside($event)\"\n    >\n      <cx-page-layout section=\"header\"></cx-page-layout>\n      <cx-page-layout section=\"navigation\"></cx-page-layout>\n    </header>\n    <cx-page-slot position=\"BottomHeaderSlot\"></cx-page-slot>\n    <cx-global-message\n      aria-atomic=\"true\"\n      aria-live=\"assertive\"\n    ></cx-global-message>\n  </ng-template>\n\n  <main cxSkipLink=\"cx-main\" [cxFocus]=\"{ disableMouseFocus: true }\">\n    <router-outlet></router-outlet>\n  </main>\n\n  <ng-template cxOutlet=\"cx-footer\">\n    <footer cxSkipLink=\"cx-footer\" [cxFocus]=\"{ disableMouseFocus: true }\">\n      <cx-page-layout section=\"footer\"></cx-page-layout>\n    </footer>\n  </ng-template>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i1$2.RouterOutlet, selector: "router-outlet", inputs: ["name"], outputs: ["activate", "deactivate", "attach", "detach"], exportAs: ["outlet"] }, { kind: "component", type: GlobalMessageComponent, selector: "cx-global-message" }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }, { kind: "component", type: PageLayoutComponent, selector: "cx-page-layout", inputs: ["section"] }, { kind: "directive", type: PageTemplateDirective, selector: "[cxPageTemplateStyle]", inputs: ["cxPageTemplateStyle"] }, { kind: "component", type: PageSlotComponent, selector: "cx-page-slot,[cx-page-slot]", inputs: ["position", "class", "isPageFold", "hasComponents"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "directive", type: SkipLinkDirective, selector: "[cxSkipLink]", inputs: ["cxSkipLink"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StorefrontComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-storefront', template: "<ng-template [cxOutlet]=\"StorefrontOutlets.STOREFRONT\" cxPageTemplateStyle>\n  <ng-template cxOutlet=\"cx-header\">\n    <header\n      id=\"cx-header\"\n      cxSkipLink=\"cx-header\"\n      [cxFocus]=\"{ disableMouseFocus: true }\"\n      [class.is-expanded]=\"isExpanded$ | async\"\n      (keydown.escape)=\"collapseMenu()\"\n      (click)=\"collapseMenuIfClickOutside($event)\"\n    >\n      <cx-page-layout section=\"header\"></cx-page-layout>\n      <cx-page-layout section=\"navigation\"></cx-page-layout>\n    </header>\n    <cx-page-slot position=\"BottomHeaderSlot\"></cx-page-slot>\n    <cx-global-message\n      aria-atomic=\"true\"\n      aria-live=\"assertive\"\n    ></cx-global-message>\n  </ng-template>\n\n  <main cxSkipLink=\"cx-main\" [cxFocus]=\"{ disableMouseFocus: true }\">\n    <router-outlet></router-outlet>\n  </main>\n\n  <ng-template cxOutlet=\"cx-footer\">\n    <footer cxSkipLink=\"cx-footer\" [cxFocus]=\"{ disableMouseFocus: true }\">\n      <cx-page-layout section=\"footer\"></cx-page-layout>\n    </footer>\n  </ng-template>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: HamburgerMenuService }, { type: i1.RoutingService }, { type: i0.ElementRef }, { type: KeyboardFocusService }]; }, propDecorators: { startNavigating: [{
                type: HostBinding,
                args: ['class.start-navigating']
            }], stopNavigating: [{
                type: HostBinding,
                args: ['class.stop-navigating']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], tabindex: [{
                type: HostBinding,
                args: ['tabindex']
            }], child: [{
                type: ViewChild,
                args: [SkipLinkComponent]
            }], handleEscape: [{
                type: HostListener,
                args: ['keydown.escape', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class StorefrontComponentModule {
}
StorefrontComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StorefrontComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StorefrontComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: StorefrontComponentModule, declarations: [StorefrontComponent], imports: [CommonModule,
        RouterModule,
        GlobalMessageComponentModule,
        OutletModule,
        OutletRefModule,
        PageLayoutModule,
        PageSlotModule,
        KeyboardFocusModule,
        SkipLinkModule], exports: [StorefrontComponent] });
StorefrontComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StorefrontComponentModule, imports: [CommonModule,
        RouterModule,
        GlobalMessageComponentModule,
        OutletModule,
        OutletRefModule,
        PageLayoutModule,
        PageSlotModule,
        KeyboardFocusModule,
        SkipLinkModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StorefrontComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        GlobalMessageComponentModule,
                        OutletModule,
                        OutletRefModule,
                        PageLayoutModule,
                        PageSlotModule,
                        KeyboardFocusModule,
                        SkipLinkModule,
                    ],
                    declarations: [StorefrontComponent],
                    exports: [StorefrontComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AddressFormComponent {
    constructor(fb, userService, userAddressService, globalMessageService, translation, launchDialogService) {
        this.fb = fb;
        this.userService = userService;
        this.userAddressService = userAddressService;
        this.globalMessageService = globalMessageService;
        this.translation = translation;
        this.launchDialogService = launchDialogService;
        this.selectedCountry$ = new BehaviorSubject('');
        this.setAsDefaultField = true;
        this.showCancelBtn = true;
        this.submitAddress = new EventEmitter();
        this.backToAddress = new EventEmitter();
        this.subscription = new Subscription();
        this.addressForm = this.fb.group({
            country: this.fb.group({
                isocode: [null, Validators.required],
            }),
            titleCode: [''],
            firstName: ['', Validators.required],
            lastName: ['', Validators.required],
            line1: ['', Validators.required],
            line2: [''],
            town: ['', Validators.required],
            region: this.fb.group({
                isocode: [null, Validators.required],
            }),
            postalCode: ['', Validators.required],
            phone: '',
            cellphone: '',
            defaultAddress: [false],
        });
    }
    ngOnInit() {
        // Fetching countries
        this.countries$ = this.userAddressService.getDeliveryCountries().pipe(tap((countries) => {
            if (Object.keys(countries).length === 0) {
                this.userAddressService.loadDeliveryCountries();
            }
        }));
        // Fetching titles
        this.titles$ = this.getTitles();
        // Fetching regions
        this.regions$ = this.selectedCountry$.pipe(switchMap((country) => this.userAddressService.getRegions(country)), tap((regions) => {
            const regionControl = this.addressForm.get('region.isocode');
            if (regions && regions.length > 0) {
                regionControl?.enable();
            }
            else {
                regionControl?.disable();
            }
        }));
        if (this.addressData && Object.keys(this.addressData).length !== 0) {
            this.addressForm.patchValue(this.addressData);
            this.countrySelected(this.addressData.country);
            if (this.addressData.region) {
                this.regionSelected(this.addressData.region);
            }
        }
        this.addresses$ = this.userAddressService.getAddresses();
    }
    getTitles() {
        return combineLatest([
            this.translation.translate('addressForm.defaultTitle'),
            this.userService.getTitles(),
        ]).pipe(map(([noneTitleText, titles]) => {
            const noneTitle = { code: '', name: noneTitleText };
            titles.sort(sortTitles);
            return [noneTitle, ...titles];
        }));
    }
    handleAddressVerificationResults(results) {
        if (results.decision === 'ACCEPT') {
            this.submitAddress.emit(this.addressForm.value);
        }
        else if (results.decision === 'REJECT') {
            // TODO: Workaround: allow server for decide is titleCode mandatory (if yes, provide personalized message)
            if (results.errors?.errors.some((error) => error.subject === 'titleCode')) {
                this.globalMessageService.add({ key: 'addressForm.titleRequired' }, GlobalMessageType.MSG_TYPE_ERROR);
            }
            else {
                this.globalMessageService.add({ key: 'addressForm.invalidAddress' }, GlobalMessageType.MSG_TYPE_ERROR);
            }
        }
        else if (results.decision === 'REVIEW') {
            this.openSuggestedAddress(results);
        }
    }
    countrySelected(country) {
        this.addressForm.get('country')?.get('isocode')?.setValue(country?.isocode);
        this.selectedCountry$.next(country?.isocode ?? '');
    }
    regionSelected(region) {
        this.addressForm.get('region')?.get('isocode')?.setValue(region.isocode);
    }
    toggleDefaultAddress() {
        this.addressForm['controls'].defaultAddress.setValue(this.addressForm.value.defaultAddress);
    }
    back() {
        this.backToAddress.emit();
    }
    verifyAddress() {
        if (this.addressForm.valid) {
            if (this.addressForm.get('region')?.value.isocode) {
                this.regions$.pipe(take(1)).subscribe((regions) => {
                    const obj = regions.find((region) => region.isocode ===
                        this.addressForm.controls['region'].value.isocode);
                    Object.assign(this.addressForm.value.region, {
                        isocodeShort: obj?.isocodeShort,
                    });
                });
            }
            if (this.addressForm.dirty) {
                this.subscription.add(this.userAddressService
                    .verifyAddress(this.addressForm.value)
                    .subscribe((value) => {
                    this.handleAddressVerificationResults(value);
                }));
            }
            else {
                // address form value not changed
                // ignore duplicate address
                this.submitAddress.emit(undefined);
            }
        }
        else {
            this.addressForm.markAllAsTouched();
        }
    }
    openSuggestedAddress(results) {
        this.launchDialogService.openDialogAndSubscribe("SUGGESTED_ADDRESSES" /* LAUNCH_CALLER.SUGGESTED_ADDRESSES */, this.element, {
            enteredAddress: this.addressForm.value,
            suggestedAddresses: results.suggestedAddresses,
        });
        this.subscription.add(this.launchDialogService.dialogClose
            .pipe(filter((result) => Boolean(result)))
            .subscribe((result) => {
            if (typeof result === 'object') {
                const address = {
                    ...result,
                    titleCode: this.addressForm.value.titleCode,
                    phone: this.addressForm.value.phone,
                    selected: true,
                };
                this.submitAddress.emit(address);
            }
        }));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
AddressFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressFormComponent, deps: [{ token: i3$1.UntypedFormBuilder }, { token: i1.UserService }, { token: i1.UserAddressService }, { token: i1.GlobalMessageService }, { token: i1.TranslationService }, { token: LaunchDialogService }], target: i0.ɵɵFactoryTarget.Component });
AddressFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: AddressFormComponent, selector: "cx-address-form", inputs: { addressData: "addressData", actionBtnLabel: "actionBtnLabel", cancelBtnLabel: "cancelBtnLabel", setAsDefaultField: "setAsDefaultField", showTitleCode: "showTitleCode", showCancelBtn: "showCancelBtn" }, outputs: { submitAddress: "submitAddress", backToAddress: "backToAddress" }, viewQueries: [{ propertyName: "element", first: true, predicate: ["submit"], descendants: true }], ngImport: i0, template: "<form (ngSubmit)=\"verifyAddress()\" [formGroup]=\"addressForm\">\n  <div class=\"form-group\" formGroupName=\"country\">\n    <ng-container *ngIf=\"countries$ | async as countries\">\n      <div *ngIf=\"countries.length !== 0\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.country' | cxTranslate\n          }}</span>\n          <ng-select\n            [inputAttrs]=\"{ required: 'true' }\"\n            class=\"country-select\"\n            id=\"country-select\"\n            formControlName=\"isocode\"\n            [searchable]=\"true\"\n            [clearable]=\"false\"\n            [items]=\"countries\"\n            bindLabel=\"name\"\n            bindValue=\"isocode\"\n            placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n            (change)=\"countrySelected($event)\"\n            [cxNgSelectA11y]=\"{\n              ariaLabel: 'addressForm.country' | cxTranslate\n            }\"\n          >\n          </ng-select>\n          <cx-form-errors\n            [control]=\"addressForm.get('country.isocode')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n    </ng-container>\n  </div>\n  <div class=\"form-group\" *ngIf=\"showTitleCode\">\n    <ng-container *ngIf=\"titles$ | async as titles\">\n      <div *ngIf=\"titles.length !== 0\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.title' | cxTranslate\n          }}</span>\n          <ng-select\n            id=\"title-select\"\n            formControlName=\"titleCode\"\n            [searchable]=\"true\"\n            [clearable]=\"false\"\n            [items]=\"titles\"\n            bindLabel=\"name\"\n            bindValue=\"code\"\n            [placeholder]=\"'addressForm.title' | cxTranslate\"\n            [cxNgSelectA11y]=\"{\n              ariaLabel: 'addressForm.title' | cxTranslate\n            }\"\n          >\n          </ng-select>\n        </label>\n      </div>\n    </ng-container>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content required\">{{\n        'addressForm.firstName.label' | cxTranslate\n      }}</span>\n      <input\n        required=\"true\"\n        class=\"form-control\"\n        type=\"text\"\n        placeholder=\"{{ 'addressForm.firstName.placeholder' | cxTranslate }}\"\n        formControlName=\"firstName\"\n      />\n      <cx-form-errors [control]=\"addressForm.get('firstName')\"></cx-form-errors>\n    </label>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content required\">{{\n        'addressForm.lastName.label' | cxTranslate\n      }}</span>\n      <input\n        required=\"true\"\n        type=\"text\"\n        class=\"form-control\"\n        placeholder=\"{{ 'addressForm.lastName.placeholder' | cxTranslate }}\"\n        formControlName=\"lastName\"\n      />\n      <cx-form-errors [control]=\"addressForm.get('lastName')\"></cx-form-errors>\n    </label>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content required\">{{\n        'addressForm.address1' | cxTranslate\n      }}</span>\n      <input\n        required=\"true\"\n        type=\"text\"\n        class=\"form-control\"\n        placeholder=\"{{ 'addressForm.streetAddress' | cxTranslate }}\"\n        formControlName=\"line1\"\n      />\n      <cx-form-errors [control]=\"addressForm.get('line1')\"></cx-form-errors>\n    </label>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'addressForm.address2' | cxTranslate\n      }}</span>\n      <input\n        type=\"text\"\n        class=\"form-control\"\n        placeholder=\"{{ 'addressForm.aptSuite' | cxTranslate }}\"\n        formControlName=\"line2\"\n      />\n    </label>\n  </div>\n  <div class=\"row\">\n    <div class=\"form-group col-sm-6\">\n      <label>\n        <span class=\"label-content required\">{{\n          'addressForm.city.label' | cxTranslate\n        }}</span>\n        <input\n          required=\"true\"\n          type=\"text\"\n          class=\"form-control\"\n          placeholder=\"{{ 'addressForm.city.placeholder' | cxTranslate }}\"\n          formControlName=\"town\"\n        />\n        <cx-form-errors [control]=\"addressForm.get('town')\"></cx-form-errors>\n      </label>\n    </div>\n    <div class=\"form-group col-sm-6\">\n      <label>\n        <span class=\"label-content required\">{{\n          'addressForm.zipCode.label' | cxTranslate\n        }}</span>\n        <input\n          required=\"true\"\n          type=\"text\"\n          class=\"form-control\"\n          placeholder=\"{{ 'addressForm.zipCode.placeholder' | cxTranslate }}\"\n          formControlName=\"postalCode\"\n        />\n        <cx-form-errors\n          [control]=\"addressForm.get('postalCode')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n    <ng-container *ngIf=\"regions$ | async as regions\" formGroupName=\"region\">\n      <ng-container *ngIf=\"regions.length !== 0\">\n        <div class=\"form-group col-md-6\">\n          <label>\n            <span class=\"label-content required\">{{\n              'addressForm.state' | cxTranslate\n            }}</span>\n            <ng-select\n              [inputAttrs]=\"{ required: 'true' }\"\n              class=\"region-select\"\n              formControlName=\"isocode\"\n              [searchable]=\"true\"\n              [clearable]=\"false\"\n              [items]=\"regions\"\n              bindLabel=\"{{ regions[0].name ? 'name' : 'isocode' }}\"\n              bindValue=\"{{ regions[0].name ? 'isocode' : 'region' }}\"\n              placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n              id=\"region-select\"\n              [cxNgSelectA11y]=\"{\n                ariaLabel: 'addressForm.state' | cxTranslate\n              }\"\n            >\n            </ng-select>\n            <cx-form-errors\n              [control]=\"addressForm.get('region.isocode')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"form-group col-md-6\">\n      <label>\n        <span class=\"label-content\">{{\n          'addressForm.phoneNumber.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"tel\"\n          class=\"form-control\"\n          placeholder=\"{{\n            'addressForm.phoneNumber.placeholder' | cxTranslate\n          }}\"\n          formControlName=\"phone\"\n        />\n      </label>\n    </div>\n    <div class=\"form-group col-md-6\">\n      <label>\n        <span class=\"label-content\">{{\n          'addressForm.cellphone.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"tel\"\n          class=\"form-control\"\n          placeholder=\"{{ 'addressForm.cellphone.placeholder' | cxTranslate }}\"\n          formControlName=\"cellphone\"\n        />\n      </label>\n    </div>\n  </div>\n\n  <div\n    class=\"form-group\"\n    *ngIf=\"(addresses$ | async)?.length && setAsDefaultField\"\n  >\n    <div class=\"form-check\">\n      <label>\n        <input\n          type=\"checkbox\"\n          class=\"form-check-input\"\n          formControlName=\"defaultAddress\"\n          (change)=\"toggleDefaultAddress()\"\n        />\n        <span class=\"form-check-label\">{{\n          'addressForm.setAsDefault' | cxTranslate\n        }}</span>\n      </label>\n    </div>\n  </div>\n  <div class=\"cx-address-form-btns\">\n    <div class=\"row\">\n      <div class=\"col-md-13 col-lg-6\" *ngIf=\"showCancelBtn\">\n        <button class=\"btn btn-block btn-secondary\" (click)=\"back()\">\n          {{ cancelBtnLabel || ('addressForm.chooseAddress' | cxTranslate) }}\n        </button>\n      </div>\n      <div class=\"col-md-13 col-lg-6\">\n        <button #submit class=\"btn btn-block btn-primary\" type=\"submit\">\n          {{ actionBtnLabel || ('common.continue' | cxTranslate) }}\n        </button>\n      </div>\n    </div>\n  </div>\n</form>\n", dependencies: [{ kind: "directive", type: NgSelectA11yDirective, selector: "[cxNgSelectA11y]", inputs: ["cxNgSelectA11y"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3$1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i3$1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "directive", type: i3$1.FormGroupName, selector: "[formGroupName]", inputs: ["formGroupName"] }, { kind: "component", type: i2.NgSelectComponent, selector: "ng-select", inputs: ["bindLabel", "bindValue", "markFirst", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "appearance", "dropdownPosition", "appendTo", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "openOnEnter", "maxSelectedItems", "groupBy", "groupValue", "bufferAmount", "virtualScroll", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "tabIndex", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "typeahead", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { kind: "component", type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-address-form', changeDetection: ChangeDetectionStrategy.OnPush, template: "<form (ngSubmit)=\"verifyAddress()\" [formGroup]=\"addressForm\">\n  <div class=\"form-group\" formGroupName=\"country\">\n    <ng-container *ngIf=\"countries$ | async as countries\">\n      <div *ngIf=\"countries.length !== 0\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.country' | cxTranslate\n          }}</span>\n          <ng-select\n            [inputAttrs]=\"{ required: 'true' }\"\n            class=\"country-select\"\n            id=\"country-select\"\n            formControlName=\"isocode\"\n            [searchable]=\"true\"\n            [clearable]=\"false\"\n            [items]=\"countries\"\n            bindLabel=\"name\"\n            bindValue=\"isocode\"\n            placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n            (change)=\"countrySelected($event)\"\n            [cxNgSelectA11y]=\"{\n              ariaLabel: 'addressForm.country' | cxTranslate\n            }\"\n          >\n          </ng-select>\n          <cx-form-errors\n            [control]=\"addressForm.get('country.isocode')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n    </ng-container>\n  </div>\n  <div class=\"form-group\" *ngIf=\"showTitleCode\">\n    <ng-container *ngIf=\"titles$ | async as titles\">\n      <div *ngIf=\"titles.length !== 0\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.title' | cxTranslate\n          }}</span>\n          <ng-select\n            id=\"title-select\"\n            formControlName=\"titleCode\"\n            [searchable]=\"true\"\n            [clearable]=\"false\"\n            [items]=\"titles\"\n            bindLabel=\"name\"\n            bindValue=\"code\"\n            [placeholder]=\"'addressForm.title' | cxTranslate\"\n            [cxNgSelectA11y]=\"{\n              ariaLabel: 'addressForm.title' | cxTranslate\n            }\"\n          >\n          </ng-select>\n        </label>\n      </div>\n    </ng-container>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content required\">{{\n        'addressForm.firstName.label' | cxTranslate\n      }}</span>\n      <input\n        required=\"true\"\n        class=\"form-control\"\n        type=\"text\"\n        placeholder=\"{{ 'addressForm.firstName.placeholder' | cxTranslate }}\"\n        formControlName=\"firstName\"\n      />\n      <cx-form-errors [control]=\"addressForm.get('firstName')\"></cx-form-errors>\n    </label>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content required\">{{\n        'addressForm.lastName.label' | cxTranslate\n      }}</span>\n      <input\n        required=\"true\"\n        type=\"text\"\n        class=\"form-control\"\n        placeholder=\"{{ 'addressForm.lastName.placeholder' | cxTranslate }}\"\n        formControlName=\"lastName\"\n      />\n      <cx-form-errors [control]=\"addressForm.get('lastName')\"></cx-form-errors>\n    </label>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content required\">{{\n        'addressForm.address1' | cxTranslate\n      }}</span>\n      <input\n        required=\"true\"\n        type=\"text\"\n        class=\"form-control\"\n        placeholder=\"{{ 'addressForm.streetAddress' | cxTranslate }}\"\n        formControlName=\"line1\"\n      />\n      <cx-form-errors [control]=\"addressForm.get('line1')\"></cx-form-errors>\n    </label>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'addressForm.address2' | cxTranslate\n      }}</span>\n      <input\n        type=\"text\"\n        class=\"form-control\"\n        placeholder=\"{{ 'addressForm.aptSuite' | cxTranslate }}\"\n        formControlName=\"line2\"\n      />\n    </label>\n  </div>\n  <div class=\"row\">\n    <div class=\"form-group col-sm-6\">\n      <label>\n        <span class=\"label-content required\">{{\n          'addressForm.city.label' | cxTranslate\n        }}</span>\n        <input\n          required=\"true\"\n          type=\"text\"\n          class=\"form-control\"\n          placeholder=\"{{ 'addressForm.city.placeholder' | cxTranslate }}\"\n          formControlName=\"town\"\n        />\n        <cx-form-errors [control]=\"addressForm.get('town')\"></cx-form-errors>\n      </label>\n    </div>\n    <div class=\"form-group col-sm-6\">\n      <label>\n        <span class=\"label-content required\">{{\n          'addressForm.zipCode.label' | cxTranslate\n        }}</span>\n        <input\n          required=\"true\"\n          type=\"text\"\n          class=\"form-control\"\n          placeholder=\"{{ 'addressForm.zipCode.placeholder' | cxTranslate }}\"\n          formControlName=\"postalCode\"\n        />\n        <cx-form-errors\n          [control]=\"addressForm.get('postalCode')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n    <ng-container *ngIf=\"regions$ | async as regions\" formGroupName=\"region\">\n      <ng-container *ngIf=\"regions.length !== 0\">\n        <div class=\"form-group col-md-6\">\n          <label>\n            <span class=\"label-content required\">{{\n              'addressForm.state' | cxTranslate\n            }}</span>\n            <ng-select\n              [inputAttrs]=\"{ required: 'true' }\"\n              class=\"region-select\"\n              formControlName=\"isocode\"\n              [searchable]=\"true\"\n              [clearable]=\"false\"\n              [items]=\"regions\"\n              bindLabel=\"{{ regions[0].name ? 'name' : 'isocode' }}\"\n              bindValue=\"{{ regions[0].name ? 'isocode' : 'region' }}\"\n              placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n              id=\"region-select\"\n              [cxNgSelectA11y]=\"{\n                ariaLabel: 'addressForm.state' | cxTranslate\n              }\"\n            >\n            </ng-select>\n            <cx-form-errors\n              [control]=\"addressForm.get('region.isocode')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n      </ng-container>\n    </ng-container>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"form-group col-md-6\">\n      <label>\n        <span class=\"label-content\">{{\n          'addressForm.phoneNumber.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"tel\"\n          class=\"form-control\"\n          placeholder=\"{{\n            'addressForm.phoneNumber.placeholder' | cxTranslate\n          }}\"\n          formControlName=\"phone\"\n        />\n      </label>\n    </div>\n    <div class=\"form-group col-md-6\">\n      <label>\n        <span class=\"label-content\">{{\n          'addressForm.cellphone.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"tel\"\n          class=\"form-control\"\n          placeholder=\"{{ 'addressForm.cellphone.placeholder' | cxTranslate }}\"\n          formControlName=\"cellphone\"\n        />\n      </label>\n    </div>\n  </div>\n\n  <div\n    class=\"form-group\"\n    *ngIf=\"(addresses$ | async)?.length && setAsDefaultField\"\n  >\n    <div class=\"form-check\">\n      <label>\n        <input\n          type=\"checkbox\"\n          class=\"form-check-input\"\n          formControlName=\"defaultAddress\"\n          (change)=\"toggleDefaultAddress()\"\n        />\n        <span class=\"form-check-label\">{{\n          'addressForm.setAsDefault' | cxTranslate\n        }}</span>\n      </label>\n    </div>\n  </div>\n  <div class=\"cx-address-form-btns\">\n    <div class=\"row\">\n      <div class=\"col-md-13 col-lg-6\" *ngIf=\"showCancelBtn\">\n        <button class=\"btn btn-block btn-secondary\" (click)=\"back()\">\n          {{ cancelBtnLabel || ('addressForm.chooseAddress' | cxTranslate) }}\n        </button>\n      </div>\n      <div class=\"col-md-13 col-lg-6\">\n        <button #submit class=\"btn btn-block btn-primary\" type=\"submit\">\n          {{ actionBtnLabel || ('common.continue' | cxTranslate) }}\n        </button>\n      </div>\n    </div>\n  </div>\n</form>\n" }]
        }], ctorParameters: function () { return [{ type: i3$1.UntypedFormBuilder }, { type: i1.UserService }, { type: i1.UserAddressService }, { type: i1.GlobalMessageService }, { type: i1.TranslationService }, { type: LaunchDialogService }]; }, propDecorators: { addressData: [{
                type: Input
            }], actionBtnLabel: [{
                type: Input
            }], cancelBtnLabel: [{
                type: Input
            }], setAsDefaultField: [{
                type: Input
            }], showTitleCode: [{
                type: Input
            }], showCancelBtn: [{
                type: Input
            }], submitAddress: [{
                type: Output
            }], backToAddress: [{
                type: Output
            }], element: [{
                type: ViewChild,
                args: ['submit']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AddressBookComponent {
    constructor(service, translation, globalMessageService) {
        this.service = service;
        this.translation = translation;
        this.globalMessageService = globalMessageService;
        this.showAddAddressForm = false;
        this.showEditAddressForm = false;
    }
    ngOnInit() {
        this.addresses$ = this.service.getAddresses();
        this.addressesStateLoading$ = this.service.getAddressesStateLoading();
        this.service.loadAddresses();
    }
    addAddressButtonHandle() {
        this.showEditAddressForm = false;
        this.showAddAddressForm = true;
    }
    editAddressButtonHandle(address) {
        this.showAddAddressForm = false;
        this.showEditAddressForm = true;
        this.currentAddress = address;
    }
    addAddressSubmit(address) {
        this.showAddAddressForm = false;
        this.service.addUserAddress(address);
    }
    addAddressCancel() {
        this.showAddAddressForm = false;
    }
    editAddressSubmit(address) {
        this.showEditAddressForm = false;
        if (address && this.currentAddress['id']) {
            this.service.updateUserAddress(this.currentAddress['id'], address);
        }
    }
    editAddressCancel() {
        this.showEditAddressForm = false;
    }
    getCardContent(address) {
        return combineLatest([
            this.translation.translate('addressCard.default'),
            this.translation.translate('addressCard.setAsDefault'),
            this.translation.translate('common.delete'),
            this.translation.translate('common.edit'),
            this.translation.translate('addressBook.areYouSureToDeleteAddress'),
            this.translation.translate('addressCard.phoneNumber'),
            this.translation.translate('addressCard.mobileNumber'),
        ]).pipe(map(([defaultText, setAsDefaultText, textDelete, textEdit, textVerifyDeleteMsg, textPhone, textMobile,]) => {
            let region = '';
            if (address.region && address.region.isocode) {
                region = address.region.isocode + ', ';
            }
            const actions = [];
            if (!address.defaultAddress) {
                actions.push({ name: setAsDefaultText, event: 'default' });
            }
            actions.push({ name: textEdit, event: 'edit' });
            actions.push({ name: textDelete, event: 'delete' });
            const numbers = getAddressNumbers(address, textPhone, textMobile);
            return {
                role: 'region',
                textBold: address.firstName + ' ' + address.lastName,
                text: [
                    address.line1,
                    address.line2,
                    address.town + ', ' + region + address.country?.isocode,
                    address.postalCode,
                    numbers,
                ],
                actions: actions,
                header: address.defaultAddress ? `✓ ${defaultText}` : '',
                deleteMsg: textVerifyDeleteMsg,
                label: address.defaultAddress
                    ? 'addressBook.defaultDeliveryAddress'
                    : 'addressBook.additionalDeliveryAddress',
            };
        }));
    }
    setAddressAsDefault(address) {
        this.service.setAddressAsDefault(address.id ?? '');
        this.globalMessageService.add({
            key: 'addressMessages.setAsDefaultSuccessfully',
            params: { streetAddress: address.line1 },
        }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
    }
    deleteAddress(addressId) {
        this.service.deleteUserAddress(addressId);
    }
    setEdit(addressId) {
        if (this.editCard !== addressId) {
            this.editCard = addressId;
        }
        else {
            this.deleteAddress(addressId);
        }
    }
    cancelCard() {
        this.editCard = null;
    }
}
AddressBookComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressBookComponent, deps: [{ token: AddressBookComponentService }, { token: i1.TranslationService }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Component });
AddressBookComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: AddressBookComponent, selector: "cx-address-book", ngImport: i0, template: "<div class=\"cx-section\">\n  <ng-container\n    *ngIf=\"\n      (addresses$ | async)?.length &&\n      !(showAddAddressForm || showEditAddressForm)\n    \"\n  >\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <button\n          class=\"btn btn-block btn-secondary\"\n          (click)=\"addAddressButtonHandle()\"\n        >\n          {{ 'addressBook.addNewAddress' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div\n      class=\"row cx-address-deck\"\n      *ngIf=\"!(addressesStateLoading$ | async); else loading\"\n    >\n      <div\n        role=\"status\"\n        [attr.aria-label]=\"'common.loaded' | cxTranslate\"\n      ></div>\n      <div\n        *ngFor=\"let address of addresses$ | async; let i = index\"\n        class=\"col-md-6 cx-address-card\"\n      >\n        <cx-card\n          [index]=\"i\"\n          [border]=\"true\"\n          [fitToContainer]=\"true\"\n          [content]=\"getCardContent(address) | async\"\n          (editCard)=\"editAddressButtonHandle(address)\"\n          (setDefaultCard)=\"setAddressAsDefault(address)\"\n          (deleteCard)=\"setEdit(address.id ?? '')\"\n          [editMode]=\"address.id === editCard\"\n          (cancelCard)=\"cancelCard()\"\n        ></cx-card>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-container\n    *ngIf=\"\n      (!(addresses$ | async)?.length || showAddAddressForm) &&\n      !showEditAddressForm\n    \"\n  >\n    <section>\n      <h2 class=\"cx-section-msg\">\n        {{ 'addressBook.addNewDeliveryAddress' | cxTranslate }}\n      </h2>\n      <cx-address-form\n        class=\"cx-form\"\n        [showTitleCode]=\"true\"\n        [showCancelBtn]=\"!((addresses$ | async)?.length === 0)\"\n        actionBtnLabel=\"{{ 'addressBook.addAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [setAsDefaultField]=\"!((addresses$ | async)?.length === 0)\"\n        (submitAddress)=\"addAddressSubmit($event)\"\n        (backToAddress)=\"addAddressCancel()\"\n        (cancelCard)=\"cancelCard()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n\n  <ng-container *ngIf=\"showEditAddressForm\">\n    <section>\n      <h2 class=\"cx-section-msg\">\n        {{ 'addressBook.editDeliveryAddress' | cxTranslate }}\n      </h2>\n      <cx-address-form\n        [showTitleCode]=\"true\"\n        actionBtnLabel=\"{{ 'addressBook.updateAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [addressData]=\"currentAddress\"\n        (submitAddress)=\"editAddressSubmit($event)\"\n        (backToAddress)=\"editAddressCancel()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n</div>\n\n<ng-template #loading>\n  <div class=\"col-md-12 cx-address-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit", "index"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }, { kind: "component", type: AddressFormComponent, selector: "cx-address-form", inputs: ["addressData", "actionBtnLabel", "cancelBtnLabel", "setAsDefaultField", "showTitleCode", "showCancelBtn"], outputs: ["submitAddress", "backToAddress"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressBookComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-address-book', template: "<div class=\"cx-section\">\n  <ng-container\n    *ngIf=\"\n      (addresses$ | async)?.length &&\n      !(showAddAddressForm || showEditAddressForm)\n    \"\n  >\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <button\n          class=\"btn btn-block btn-secondary\"\n          (click)=\"addAddressButtonHandle()\"\n        >\n          {{ 'addressBook.addNewAddress' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div\n      class=\"row cx-address-deck\"\n      *ngIf=\"!(addressesStateLoading$ | async); else loading\"\n    >\n      <div\n        role=\"status\"\n        [attr.aria-label]=\"'common.loaded' | cxTranslate\"\n      ></div>\n      <div\n        *ngFor=\"let address of addresses$ | async; let i = index\"\n        class=\"col-md-6 cx-address-card\"\n      >\n        <cx-card\n          [index]=\"i\"\n          [border]=\"true\"\n          [fitToContainer]=\"true\"\n          [content]=\"getCardContent(address) | async\"\n          (editCard)=\"editAddressButtonHandle(address)\"\n          (setDefaultCard)=\"setAddressAsDefault(address)\"\n          (deleteCard)=\"setEdit(address.id ?? '')\"\n          [editMode]=\"address.id === editCard\"\n          (cancelCard)=\"cancelCard()\"\n        ></cx-card>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-container\n    *ngIf=\"\n      (!(addresses$ | async)?.length || showAddAddressForm) &&\n      !showEditAddressForm\n    \"\n  >\n    <section>\n      <h2 class=\"cx-section-msg\">\n        {{ 'addressBook.addNewDeliveryAddress' | cxTranslate }}\n      </h2>\n      <cx-address-form\n        class=\"cx-form\"\n        [showTitleCode]=\"true\"\n        [showCancelBtn]=\"!((addresses$ | async)?.length === 0)\"\n        actionBtnLabel=\"{{ 'addressBook.addAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [setAsDefaultField]=\"!((addresses$ | async)?.length === 0)\"\n        (submitAddress)=\"addAddressSubmit($event)\"\n        (backToAddress)=\"addAddressCancel()\"\n        (cancelCard)=\"cancelCard()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n\n  <ng-container *ngIf=\"showEditAddressForm\">\n    <section>\n      <h2 class=\"cx-section-msg\">\n        {{ 'addressBook.editDeliveryAddress' | cxTranslate }}\n      </h2>\n      <cx-address-form\n        [showTitleCode]=\"true\"\n        actionBtnLabel=\"{{ 'addressBook.updateAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [addressData]=\"currentAddress\"\n        (submitAddress)=\"editAddressSubmit($event)\"\n        (backToAddress)=\"editAddressCancel()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n</div>\n\n<ng-template #loading>\n  <div class=\"col-md-12 cx-address-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: AddressBookComponentService }, { type: i1.TranslationService }, { type: i1.GlobalMessageService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ViewConfig {
}
ViewConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ViewConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ViewConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ViewConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ViewConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FileDownloadService {
    /**
     * Triggers the browser downloading of the file from the given URL.
     *
     * @param {string} url URL to file.
     * @param {string} [fileName] The optional parameter for defining filename
     * (including the extension) when saving the file.
     */
    download(url, fileName) {
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `${fileName}`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}
FileDownloadService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileDownloadService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FileDownloadService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileDownloadService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileDownloadService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ExportCsvFileService {
    constructor(fileDownloadService) {
        this.fileDownloadService = fileDownloadService;
    }
    /**
     * Converts array of objects into CSV data structure.
     *
     * @param objectsArray Array of objects which should be converted to CSV.
     * @param separator Separator for CSV data.
     * @returns Processed string ready to be saved into file.
     */
    convert(objectsArray, separator) {
        return objectsArray.reduce((csvString, row) => {
            const line = row.reduce((currentLine, column) => {
                currentLine += currentLine !== '' ? separator : '';
                const cell = column.includes(separator) ? `"${column}"` : column;
                return `${currentLine}${cell}`;
            }, '');
            return `${csvString}${line}\r\n`;
        }, '');
    }
    /**
     * Creates and download CSV file.
     *
     * @param objectsArray Array of objects which should be converted to CSV.
     * @param separator Separator for CSV data.
     * @param fileOptions Exported file options.
     */
    download(objectsArray, separator, fileOptions) {
        const { fileName, type, extension } = fileOptions;
        const fileContent = this.convert(objectsArray, separator);
        const blob = new Blob([fileContent], { type });
        const url = URL.createObjectURL(blob);
        this.fileDownloadService.download(url, `${fileName}.${extension}`);
    }
}
ExportCsvFileService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ExportCsvFileService, deps: [{ token: FileDownloadService }], target: i0.ɵɵFactoryTarget.Injectable });
ExportCsvFileService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ExportCsvFileService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ExportCsvFileService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: FileDownloadService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FileReaderService {
    /**
     * Load text file
     *
     * @param file text file to extract the data
     * @returns Observable from file reader
     */
    loadTextFile(file) {
        return new Observable((observer) => {
            const fileReader = new FileReader();
            fileReader.readAsText(file);
            fileReader.onload = () => {
                observer.next(fileReader.result);
                observer.complete();
            };
            fileReader.onerror = (error) => {
                fileReader.abort();
                observer.error(error);
            };
        });
    }
}
FileReaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileReaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FileReaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileReaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FileReaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ImportCsvFileService {
    constructor(fileReaderService) {
        this.fileReaderService = fileReaderService;
    }
    /**
     * Load CSV file.
     *
     * @param file File we want to load as CSV.
     * @param separator Separator for CSV data.
     * @return {Observable<string[][]>} Imported file
     */
    loadFile(file, separator) {
        return this.fileReaderService
            .loadTextFile(file)
            .pipe(map((res) => this.parse(res, separator)));
    }
    /**
     * Combined csv validation
     *
     * @param file File we want to load as CSV.
     * @param separator Separator for CSV data.
     * @param isDataParsable (optional) Callback for verify that structure type is proper.
     * @param maxEntries (optional) Limitation for maximum entries count.
     * @return {Observable<CsvFileValidationErrors | null>} Result of validation
     */
    validateFile(file, { separator, isDataParsable, maxEntries, }) {
        const validationErrors = {};
        return this.fileReaderService.loadTextFile(file).pipe(tap((data) => {
            this.validateEmpty(data, validationErrors);
        }), map((res) => this.parse(res, separator)), tap((data) => {
            this.validateNotParsable(data, validationErrors, isDataParsable);
            this.validateTooManyEntries(data, validationErrors, maxEntries);
        }), catchError((errors) => of(errors)), map(() => Object.keys(validationErrors).length === 0 ? null : validationErrors));
    }
    /**
     * Processes the CSV data
     *
     * @param csvString raw extracted data from CSV
     * @param separator for csv data
     * @param ignoreHeader (optional) flag allows for ignore headers row while reading
     * @returns {string[][]} Parsed file
     */
    parse(csvString, separator, ignoreHeader = true) {
        return csvString
            .split('\n')
            .map((row) => row.split(separator).map((cell) => cell.replace(/"/g, '')))
            .filter((value, index) => !(ignoreHeader && index === 0) && value[0] !== '');
    }
    validateEmpty(data, errors) {
        if (data.toString().length === 0) {
            errors.empty = true;
            throw errors;
        }
    }
    validateTooManyEntries(data, errors, maxEntries) {
        if (maxEntries && data.length > maxEntries) {
            errors.tooManyEntries = { maxEntries };
            throw errors;
        }
    }
    validateNotParsable(data, errors, isDataParsable) {
        if (isDataParsable && !isDataParsable(data)) {
            errors.notParsable = true;
            throw errors;
        }
    }
}
ImportCsvFileService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ImportCsvFileService, deps: [{ token: FileReaderService }], target: i0.ɵɵFactoryTarget.Injectable });
ImportCsvFileService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ImportCsvFileService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ImportCsvFileService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: FileReaderService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CustomFormValidators {
    /**
     * Checks control's value with predefined email regexp
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxInvalidEmail' validator error
     * @memberof CustomFormValidators
     */
    static emailValidator(control) {
        const email = control.value;
        return email && (!email.length || email.match(EMAIL_PATTERN))
            ? null
            : { cxInvalidEmail: true };
    }
    /**
     * Checks control's value with predefined password regexp
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxInvalidPassword' validator error
     * @memberof CustomFormValidators
     */
    static passwordValidator(control) {
        const password = control.value;
        return password && (!password.length || password.match(PASSWORD_PATTERN))
            ? null
            : { cxInvalidPassword: true };
    }
    /**
     * Checks if control's value is between 1 and 5
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxStarRatingEmpty' validator error
     * @memberof CustomFormValidators
     */
    static starRatingEmpty(control) {
        const rating = control.value;
        return rating >= 1 && rating <= 5 ? null : { cxStarRatingEmpty: true };
    }
    /**
     * Checks if two password controls match
     *
     * NOTE: Use it as a form validator and pass password control names as parameters
     *
     * @static
     * @param {string} password First password control name
     * @param {string} passwordConfirmation Second password control name
     * @returns Uses 'cxPasswordsMustMatch' validator error
     * @memberof CustomFormValidators
     */
    static passwordsMustMatch(password, passwordConfirmation) {
        const validator = (formGroup) => controlsMustMatch(formGroup, password, passwordConfirmation, 'cxPasswordsMustMatch');
        return validator;
    }
    /**
     * Checks if two email controls match
     *
     * NOTE: Use it as a form validator and pass email control names as parameters
     *
     * @static
     * @param {string} email First email control name
     * @param {string} emailConfirmation Second email control name
     * @returns Uses 'cxEmailsMustMatch' validator error
     * @memberof CustomFormValidators
     */
    static emailsMustMatch(email, emailConfirmation) {
        const validator = (formGroup) => controlsMustMatch(formGroup, email, emailConfirmation, 'cxEmailsMustMatch');
        return validator;
    }
    /**
     * Checks if control's value is euqal or greater than 0
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxNegativeAmount' validator error
     * @memberof CustomFormValidators
     */
    static mustBePositive(control) {
        const amount = control.value;
        return amount >= 0 ? null : { cxNegativeAmount: true };
    }
    /**
     * Checks if control's value does not contain any special characters
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxContainsSpecialCharacters' validator error
     * @memberof CustomFormValidators
     */
    static noSpecialCharacters(control) {
        const forbiddenChars = ['/'];
        const str = String(control.value);
        const containsSpecialChars = forbiddenChars.some((char) => str.includes(char));
        return !containsSpecialChars ? null : { cxContainsSpecialCharacters: true };
    }
    /**
     * Checks if control's value passes pattern
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {(date: string) => boolean} isValidFormat Pattern verification function
     * @returns {(control: AbstractControl): ValidationErrors | null} Uses 'pattern' validator error
     * @memberof CustomFormValidators
     */
    static patternValidation(isValidFormat) {
        const validator = (control) => {
            const errors = {};
            if (control.value &&
                control.value !== '' &&
                !isValidFormat(control.value)) {
                errors.pattern = true;
            }
            return Object.keys(errors).length === 0 ? null : errors;
        };
        return validator;
    }
    /**
     * Checks if two email controls match
     *
     * NOTE: Use it as a form validator and pass dates for range
     *
     * @static
     * @param {string} startDateKey First date control name
     * @param {string} endDateKey Second date control name
     * @param {(value: string) => Date} getDate Converting function
     * @returns Uses 'min' and 'max validator error
     * @memberof CustomFormValidators
     */
    static dateRange(startDateKey, endDateKey, getDate) {
        return (formGroup) => {
            const startDateControl = formGroup.controls[startDateKey];
            const endDateControl = formGroup.controls[endDateKey];
            const startDate = getDate(startDateControl.value);
            const endDate = getDate(endDateControl.value);
            if (startDate && endDate) {
                if (!startDateControl.errors?.pattern) {
                    if (startDate > endDate) {
                        startDateControl.setErrors({ max: true });
                    }
                }
                if (!endDateControl.errors?.pattern) {
                    if (endDate < startDate) {
                        endDateControl.setErrors({ min: true });
                    }
                }
            }
            return null;
        };
    }
}
/**
 * Generic function for validators, which checks if two passed controls match.
 *
 * @param formGroup
 * @param firstControlName First control to check
 * @param secondControlName Second control to check
 * @param errorName Error which will be returned by validator
 */
function controlsMustMatch(formGroup, firstControlName, secondControlName, errorName) {
    const firstControl = formGroup.controls[firstControlName];
    const secondControl = formGroup.controls[secondControlName];
    if (secondControl.errors && !secondControl.errors[errorName]) {
        return;
    }
    secondControl.setErrors(firstControl.value !== secondControl.value ? { [errorName]: true } : null);
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SuggestedAddressDialogComponent {
    handleClick(event) {
        if (event.target.tagName === this.el.nativeElement.tagName) {
            this.closeModal('Cross click');
        }
    }
    constructor(launchDialogService, el) {
        this.launchDialogService = launchDialogService;
        this.el = el;
        this.iconTypes = ICON_TYPE;
        this.focusConfig = {
            trap: true,
            block: true,
            autofocus: 'button',
            focusOnEscape: true,
        };
        this.data$ = this.launchDialogService.data$;
    }
    ngOnInit() {
        this.data$.pipe(take(1)).subscribe((data) => this.setSelectedAddress(data));
    }
    closeModal(reason) {
        this.launchDialogService.closeDialog(reason);
    }
    setSelectedAddress(data) {
        this.selectedAddress = data.suggestedAddresses?.length
            ? data.suggestedAddresses[0]
            : data.enteredAddress;
        console.log(this.selectedAddress);
    }
}
SuggestedAddressDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SuggestedAddressDialogComponent, deps: [{ token: LaunchDialogService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
SuggestedAddressDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: SuggestedAddressDialogComponent, selector: "cx-suggested-addresses-dialog", host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0, template: "<div\n  class=\"cx-suggested-addresses-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"closeModal('Escape clicked')\"\n>\n  <div *ngIf=\"data$ | async as data\" class=\"cx-suggested-addresses-container\">\n    <div class=\"cx-suggested-addresses-header cx-modal-header\">\n      <div class=\"cx-suggested-addresses-title\">\n        {{ 'addressSuggestion.verifyYourAddress' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        (click)=\"closeModal('Cross click')\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <div class=\"cx-suggested-addresses-body\" ngForm>\n      <div class=\"cx-dialog-info\">\n        <p>\n          {{ 'addressSuggestion.ensureAccuracySuggestChange' | cxTranslate }}\n          {{ 'addressSuggestion.chooseAddressToUse' | cxTranslate }}\n        </p>\n      </div>\n\n      <div class=\"cx-dialog-options\">\n        <div\n          class=\"form-check\"\n          *ngFor=\"\n            let suggestedAddress of data.suggestedAddresses;\n            let i = index\n          \"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"suggestedAddress\"\n            [id]=\"'suggested-addresses--suggested-' + i\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            [for]=\"'suggested-addresses--suggested-' + i\"\n          >\n            {{ 'addressSuggestion.suggestedAddress' | cxTranslate }}\n            {{ data.suggestedAddresses.length > 1 ? i + 1 : null }}\n          </label>\n          <div class=\"cx-dialog-suggested\">\n            <div class=\"cx-card-container\">\n              <div class=\"cx-card-label\">{{ suggestedAddress?.firstName }}</div>\n              <div class=\"cx-card-label\">{{ suggestedAddress?.lastName }}</div>\n              <div class=\"cx-card-label\">{{ suggestedAddress?.line1 }}</div>\n              <div class=\"cx-card-label\">\n                <span>{{ suggestedAddress?.line2 }}</span>\n              </div>\n              <div class=\"cx-card-label\">{{ suggestedAddress?.town }}</div>\n              <div class=\"cx-card-label\">\n                {{ suggestedAddress?.region?.isocode }}\n              </div>\n              <div class=\"cx-card-label\">\n                {{ suggestedAddress?.postalCode }}\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class=\"form-check\">\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"data.enteredAddress\"\n            id=\"suggested-addresses--entered\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            for=\"suggested-addresses--entered\"\n          >\n            {{ 'addressSuggestion.enteredAddress' | cxTranslate }}\n          </label>\n          <div class=\"cx-dialog-entered\">\n            <div class=\"cx-card-container\">\n              <div class=\"cx-card-label\">\n                {{ data.enteredAddress?.firstName }}\n                {{ data.enteredAddress?.lastName }}\n              </div>\n              <div class=\"cx-card-label\">{{ data.enteredAddress?.line1 }}</div>\n              <div class=\"cx-card-label\">\n                <span>{{ data.enteredAddress?.line2 }}</span>\n              </div>\n              <div class=\"cx-card-label\">\n                {{ data.enteredAddress?.town }}\n                {{ data.enteredAddress?.region?.isocode }}\n              </div>\n              <div class=\"cx-card-label\">\n                {{ data.enteredAddress?.postalCode }}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"cx-suggested-addresses-footer cx-modal-footer\">\n      <div class=\"row\">\n        <div class=\"cx-dialog-actions col-sm-12 col-md-12 col-lg-6 offset-lg-6\">\n          <button\n            class=\"btn btn-secondary cx-dialog-buttons\"\n            (click)=\"closeModal('Edit address')\"\n          >\n            {{ 'addressSuggestion.editAddress' | cxTranslate }}\n          </button>\n          <button\n            cxAutoFocus\n            class=\"btn btn-primary cx-dialog-buttons\"\n            (click)=\"closeModal(selectedAddress)\"\n          >\n            {{ 'addressSuggestion.saveAddress' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3$1.RadioControlValueAccessor, selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]", inputs: ["name", "formControlName", "value"] }, { kind: "directive", type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i3$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i3$1.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SuggestedAddressDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-suggested-addresses-dialog', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"cx-suggested-addresses-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"closeModal('Escape clicked')\"\n>\n  <div *ngIf=\"data$ | async as data\" class=\"cx-suggested-addresses-container\">\n    <div class=\"cx-suggested-addresses-header cx-modal-header\">\n      <div class=\"cx-suggested-addresses-title\">\n        {{ 'addressSuggestion.verifyYourAddress' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        (click)=\"closeModal('Cross click')\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <div class=\"cx-suggested-addresses-body\" ngForm>\n      <div class=\"cx-dialog-info\">\n        <p>\n          {{ 'addressSuggestion.ensureAccuracySuggestChange' | cxTranslate }}\n          {{ 'addressSuggestion.chooseAddressToUse' | cxTranslate }}\n        </p>\n      </div>\n\n      <div class=\"cx-dialog-options\">\n        <div\n          class=\"form-check\"\n          *ngFor=\"\n            let suggestedAddress of data.suggestedAddresses;\n            let i = index\n          \"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"suggestedAddress\"\n            [id]=\"'suggested-addresses--suggested-' + i\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            [for]=\"'suggested-addresses--suggested-' + i\"\n          >\n            {{ 'addressSuggestion.suggestedAddress' | cxTranslate }}\n            {{ data.suggestedAddresses.length > 1 ? i + 1 : null }}\n          </label>\n          <div class=\"cx-dialog-suggested\">\n            <div class=\"cx-card-container\">\n              <div class=\"cx-card-label\">{{ suggestedAddress?.firstName }}</div>\n              <div class=\"cx-card-label\">{{ suggestedAddress?.lastName }}</div>\n              <div class=\"cx-card-label\">{{ suggestedAddress?.line1 }}</div>\n              <div class=\"cx-card-label\">\n                <span>{{ suggestedAddress?.line2 }}</span>\n              </div>\n              <div class=\"cx-card-label\">{{ suggestedAddress?.town }}</div>\n              <div class=\"cx-card-label\">\n                {{ suggestedAddress?.region?.isocode }}\n              </div>\n              <div class=\"cx-card-label\">\n                {{ suggestedAddress?.postalCode }}\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class=\"form-check\">\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"data.enteredAddress\"\n            id=\"suggested-addresses--entered\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            for=\"suggested-addresses--entered\"\n          >\n            {{ 'addressSuggestion.enteredAddress' | cxTranslate }}\n          </label>\n          <div class=\"cx-dialog-entered\">\n            <div class=\"cx-card-container\">\n              <div class=\"cx-card-label\">\n                {{ data.enteredAddress?.firstName }}\n                {{ data.enteredAddress?.lastName }}\n              </div>\n              <div class=\"cx-card-label\">{{ data.enteredAddress?.line1 }}</div>\n              <div class=\"cx-card-label\">\n                <span>{{ data.enteredAddress?.line2 }}</span>\n              </div>\n              <div class=\"cx-card-label\">\n                {{ data.enteredAddress?.town }}\n                {{ data.enteredAddress?.region?.isocode }}\n              </div>\n              <div class=\"cx-card-label\">\n                {{ data.enteredAddress?.postalCode }}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"cx-suggested-addresses-footer cx-modal-footer\">\n      <div class=\"row\">\n        <div class=\"cx-dialog-actions col-sm-12 col-md-12 col-lg-6 offset-lg-6\">\n          <button\n            class=\"btn btn-secondary cx-dialog-buttons\"\n            (click)=\"closeModal('Edit address')\"\n          >\n            {{ 'addressSuggestion.editAddress' | cxTranslate }}\n          </button>\n          <button\n            cxAutoFocus\n            class=\"btn btn-primary cx-dialog-buttons\"\n            (click)=\"closeModal(selectedAddress)\"\n          >\n            {{ 'addressSuggestion.saveAddress' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: LaunchDialogService }, { type: i0.ElementRef }]; }, propDecorators: { handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AddressFormModule {
}
AddressFormModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressFormModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AddressFormModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: AddressFormModule, declarations: [AddressFormComponent, SuggestedAddressDialogComponent], imports: [NgSelectA11yModule,
        CommonModule,
        ReactiveFormsModule,
        FormsModule,
        RouterModule,
        NgSelectModule,
        IconModule,
        I18nModule,
        FormErrorsModule,
        KeyboardFocusModule], exports: [AddressFormComponent, SuggestedAddressDialogComponent] });
AddressFormModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressFormModule, imports: [NgSelectA11yModule,
        CommonModule,
        ReactiveFormsModule,
        FormsModule,
        RouterModule,
        NgSelectModule,
        IconModule,
        I18nModule,
        FormErrorsModule,
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressFormModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        NgSelectA11yModule,
                        CommonModule,
                        ReactiveFormsModule,
                        FormsModule,
                        RouterModule,
                        NgSelectModule,
                        IconModule,
                        I18nModule,
                        FormErrorsModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [AddressFormComponent, SuggestedAddressDialogComponent],
                    exports: [AddressFormComponent, SuggestedAddressDialogComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultSuggestedAddressesDialogLayoutConfig = {
    launch: {
        SUGGESTED_ADDRESSES: {
            inlineRoot: true,
            component: SuggestedAddressDialogComponent,
            dialogType: DIALOG_TYPE.DIALOG,
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AddressBookModule {
}
AddressBookModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressBookModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AddressBookModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: AddressBookModule, declarations: [AddressBookComponent], imports: [CommonModule,
        CardModule,
        AddressFormModule,
        SpinnerModule,
        I18nModule], exports: [AddressBookComponent] });
AddressBookModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressBookModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                AccountAddressBookComponent: {
                    component: AddressBookComponent,
                    guards: [AuthGuard],
                },
            },
        }),
        provideDefaultConfig(defaultSuggestedAddressesDialogLayoutConfig),
        UserAddressService,
    ], imports: [CommonModule,
        CardModule,
        AddressFormModule,
        SpinnerModule,
        I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AddressBookModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CardModule,
                        AddressFormModule,
                        SpinnerModule,
                        I18nModule,
                    ],
                    declarations: [AddressBookComponent],
                    exports: [AddressBookComponent],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                AccountAddressBookComponent: {
                                    component: AddressBookComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                        provideDefaultConfig(defaultSuggestedAddressesDialogLayoutConfig),
                        UserAddressService,
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MyCouponsComponentService {
    constructor(routingService, translation) {
        this.routingService = routingService;
        this.translation = translation;
        this.RELEVANCE = ':relevance';
        this.CUSTOMER_COUPON_CODE = ':customerCouponCode:';
    }
    launchSearchPage(coupon) {
        this.routingService.go({
            cxRoute: 'search',
            params: { query: this.buildSearchParam(coupon) },
        }, {
            queryParams: {
                couponcode: coupon.couponId,
            },
        });
    }
    buildSearchParam(coupon) {
        return coupon.allProductsApplicable
            ? this.RELEVANCE
            : this.RELEVANCE + this.CUSTOMER_COUPON_CODE + coupon.couponId;
    }
    getSortLabels() {
        return combineLatest([
            this.translation.translate('myCoupons.startDateAsc'),
            this.translation.translate('myCoupons.startDateDesc'),
            this.translation.translate('myCoupons.endDateAsc'),
            this.translation.translate('myCoupons.endDateDesc'),
        ]).pipe(map(([textByStartDateAsc, textByStartDateDesc, textByEndDateAsc, textByEndDateDesc,]) => {
            return {
                byStartDateAsc: textByStartDateAsc,
                byStartDateDesc: textByStartDateDesc,
                byEndDateAsc: textByEndDateAsc,
                byEndDateDesc: textByEndDateDesc,
            };
        }));
    }
}
MyCouponsComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsComponentService, deps: [{ token: i1.RoutingService }, { token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Injectable });
MyCouponsComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: i1.TranslationService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CouponCardComponent {
    constructor(myCouponsComponentService, launchDialogService, vcr) {
        this.myCouponsComponentService = myCouponsComponentService;
        this.launchDialogService = launchDialogService;
        this.vcr = vcr;
        this.notificationChanged = new EventEmitter();
    }
    onSubscriptionChange() {
        this.notificationChanged.emit({
            couponId: this.coupon.couponId ?? '',
            notification: !this.coupon.notificationOn,
        });
    }
    readMore() {
        const dialog = this.launchDialogService.openDialog("COUPON" /* LAUNCH_CALLER.COUPON */, this.element, this.vcr, { coupon: this.coupon });
        if (dialog) {
            dialog.pipe(take(1)).subscribe();
        }
    }
    findProducts() {
        this.myCouponsComponentService.launchSearchPage(this.coupon);
    }
}
CouponCardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CouponCardComponent, deps: [{ token: MyCouponsComponentService }, { token: LaunchDialogService }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component });
CouponCardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: CouponCardComponent, selector: "cx-coupon-card", inputs: { coupon: "coupon", couponSubscriptionLoading$: "couponSubscriptionLoading$" }, outputs: { notificationChanged: "notificationChanged" }, viewQueries: [{ propertyName: "element", first: true, predicate: ["element"], descendants: true }], ngImport: i0, template: "<div class=\"card\">\n  <div class=\"card-body cx-card-body\">\n    <div class=\"cx-coupon-data\">\n      <div class=\"cx-coupon-card-row top\">\n        <div class=\"cx-coupon-card-head\">\n          <span class=\"card-label-bold cx-coupon-card-id\">{{\n            coupon?.couponId\n          }}</span>\n          <span>: {{ coupon?.name }}</span>\n        </div>\n\n        <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n          {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n        </div>\n      </div>\n\n      <div class=\"cx-coupon-card-date\">\n        <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n        <div class=\"cx-coupon-date\">\n          <div class=\"cx-coupon-date-start\">\n            {{ coupon?.startDate | cxDate: 'medium' }} -&nbsp;\n          </div>\n          <div class=\"cx-coupon-date-end\">\n            {{ coupon?.endDate | cxDate: 'medium' }}\n          </div>\n        </div>\n      </div>\n      <button\n        class=\"cx-card-read-more link cx-action-link\"\n        (click)=\"readMore()\"\n      >\n        {{ 'myCoupons.readMore' | cxTranslate }}\n      </button>\n      <div class=\"cx-coupon-card-row bottom\">\n        <div class=\"cx-coupon-notification form-check\">\n          <label>\n            <input\n              type=\"checkbox\"\n              class=\"form-check-input\"\n              [checked]=\"coupon?.notificationOn\"\n              [class.disabled]=\"couponSubscriptionLoading$ | async\"\n              [disabled]=\"couponSubscriptionLoading$ | async\"\n              (change)=\"onSubscriptionChange()\"\n            />\n            <span class=\"form-check-label\">\n              {{ 'myCoupons.notification' | cxTranslate }}\n            </span>\n          </label>\n        </div>\n\n        <div class=\"cx-coupon-find-product col-lg-6 col-md-12 col-sm-6\">\n          <button class=\"btn btn-block btn-secondary\" (click)=\"findProducts()\">\n            {{ 'myCoupons.findProducts' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i3.LowerCasePipe, name: "lowercase" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.CxDatePipe, name: "cxDate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CouponCardComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-coupon-card', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"card\">\n  <div class=\"card-body cx-card-body\">\n    <div class=\"cx-coupon-data\">\n      <div class=\"cx-coupon-card-row top\">\n        <div class=\"cx-coupon-card-head\">\n          <span class=\"card-label-bold cx-coupon-card-id\">{{\n            coupon?.couponId\n          }}</span>\n          <span>: {{ coupon?.name }}</span>\n        </div>\n\n        <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n          {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n        </div>\n      </div>\n\n      <div class=\"cx-coupon-card-date\">\n        <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n        <div class=\"cx-coupon-date\">\n          <div class=\"cx-coupon-date-start\">\n            {{ coupon?.startDate | cxDate: 'medium' }} -&nbsp;\n          </div>\n          <div class=\"cx-coupon-date-end\">\n            {{ coupon?.endDate | cxDate: 'medium' }}\n          </div>\n        </div>\n      </div>\n      <button\n        class=\"cx-card-read-more link cx-action-link\"\n        (click)=\"readMore()\"\n      >\n        {{ 'myCoupons.readMore' | cxTranslate }}\n      </button>\n      <div class=\"cx-coupon-card-row bottom\">\n        <div class=\"cx-coupon-notification form-check\">\n          <label>\n            <input\n              type=\"checkbox\"\n              class=\"form-check-input\"\n              [checked]=\"coupon?.notificationOn\"\n              [class.disabled]=\"couponSubscriptionLoading$ | async\"\n              [disabled]=\"couponSubscriptionLoading$ | async\"\n              (change)=\"onSubscriptionChange()\"\n            />\n            <span class=\"form-check-label\">\n              {{ 'myCoupons.notification' | cxTranslate }}\n            </span>\n          </label>\n        </div>\n\n        <div class=\"cx-coupon-find-product col-lg-6 col-md-12 col-sm-6\">\n          <button class=\"btn btn-block btn-secondary\" (click)=\"findProducts()\">\n            {{ 'myCoupons.findProducts' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: MyCouponsComponentService }, { type: LaunchDialogService }, { type: i0.ViewContainerRef }]; }, propDecorators: { coupon: [{
                type: Input
            }], couponSubscriptionLoading$: [{
                type: Input
            }], notificationChanged: [{
                type: Output
            }], element: [{
                type: ViewChild,
                args: ['element']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MyCouponsComponent {
    constructor(couponService, myCouponsComponentService) {
        this.couponService = couponService;
        this.myCouponsComponentService = myCouponsComponentService;
        this.iconTypes = ICON_TYPE;
        this.subscriptions = new Subscription();
        this.PAGE_SIZE = 10;
        this.sortMapping = {
            byStartDateAsc: 'startDate:asc',
            byStartDateDesc: 'startDate:desc',
            byEndDateAsc: 'endDate:asc',
            byEndDateDesc: 'endDate:desc',
        };
        this.sort = 'byStartDateAsc';
        this.sortOptions = [
            {
                code: 'byStartDateAsc',
                selected: false,
            },
            {
                code: 'byStartDateDesc',
                selected: false,
            },
            {
                code: 'byEndDateAsc',
                selected: false,
            },
            {
                code: 'byEndDateDesc',
                selected: false,
            },
        ];
    }
    ngOnInit() {
        this.couponResult$ = this.couponService
            .getCustomerCoupons(this.PAGE_SIZE)
            .pipe(tap((coupons) => (this.pagination = {
            currentPage: coupons.pagination?.page,
            pageSize: coupons.pagination?.count,
            totalPages: coupons.pagination?.totalPages,
            totalResults: coupons.pagination?.totalCount,
            sort: this.sort,
        })));
        this.couponsLoading$ = this.couponService.getCustomerCouponsLoading();
        this.couponSubscriptionLoading$ = combineLatest([
            this.couponService.getSubscribeCustomerCouponResultLoading(),
            this.couponService.getUnsubscribeCustomerCouponResultLoading(),
        ]).pipe(map(([subscribing, unsubscribing]) => subscribing || unsubscribing));
        this.sortLabels = this.myCouponsComponentService.getSortLabels();
        this.subscriptions
            .add(this.couponService
            .getSubscribeCustomerCouponResultError()
            .subscribe((error) => {
            this.subscriptionFail(error);
        }))
            .add(this.couponService
            .getUnsubscribeCustomerCouponResultError()
            .subscribe((error) => {
            this.subscriptionFail(error);
        }));
    }
    subscriptionFail(error) {
        if (error) {
            this.couponService.loadCustomerCoupons(this.PAGE_SIZE);
        }
    }
    sortChange(sort) {
        this.sort = sort;
        this.couponService.loadCustomerCoupons(this.PAGE_SIZE, this.pagination.currentPage, this.sortMapping[sort]);
    }
    pageChange(page) {
        this.couponService.loadCustomerCoupons(this.PAGE_SIZE, page, this.sortMapping[this.sort]);
    }
    notificationChange({ couponId, notification, }) {
        if (notification) {
            this.couponService.subscribeCustomerCoupon(couponId);
        }
        else {
            this.couponService.unsubscribeCustomerCoupon(couponId);
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
MyCouponsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsComponent, deps: [{ token: i1.CustomerCouponService }, { token: MyCouponsComponentService }], target: i0.ɵɵFactoryTarget.Component });
MyCouponsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: MyCouponsComponent, selector: "cx-my-coupons", ngImport: i0, template: "<div class=\"cx-section\">\n  <ng-container *ngIf=\"!(couponsLoading$ | async); else loading\">\n    <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n    <ng-container *ngIf=\"couponResult$ | async as couponResult\">\n      <div class=\"cx-my-coupons-header\">\n        <h2>\n          {{ 'myCoupons.myCoupons' | cxTranslate }}\n        </h2>\n      </div>\n      <ng-container\n        *ngIf=\"\n          couponResult.pagination &&\n            couponResult.pagination.totalCount &&\n            couponResult.pagination.totalCount > 0;\n          else noCoupons\n        \"\n      >\n        <div class=\"cx-my-coupons-sort top row\">\n          <label\n            class=\"\n              cx-my-coupons-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n              [ariaLabel]=\"'myCoupons.sortCoupons' | cxTranslate\"\n              ariaControls=\"coupon-deck\"\n            >\n            </cx-sorting>\n          </label>\n          <div class=\"cx-my-coupons-pagination cx-mycoupon-thead-mobile\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n\n        <div id=\"coupon-deck\" class=\"row cx-coupon-deck\">\n          <div\n            *ngFor=\"let coupon of couponResult.coupons\"\n            class=\"col-md-6 cx-coupon-card\"\n          >\n            <cx-coupon-card\n              [coupon]=\"coupon\"\n              [couponSubscriptionLoading$]=\"couponSubscriptionLoading$\"\n              (notificationChanged)=\"notificationChange($event)\"\n            ></cx-coupon-card>\n          </div>\n        </div>\n\n        <div class=\"cx-my-coupons-sort bottom row\">\n          <label\n            class=\"\n              cx-my-coupons-form-group\n              form-group\n              cx-mycoupon-thead-mobile\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n              placeholder=\"{{ 'myCoupons.sortBy' | cxTranslate }}\"\n              [ariaLabel]=\"'myCoupons.sortCoupons' | cxTranslate\"\n              ariaControls=\"coupon-deck\"\n            >\n            </cx-sorting>\n          </label>\n          <div class=\"cx-my-coupons-pagination\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <div class=\"cx-my-coupons-notes\">\n          <span>\n            <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n            {{ 'myCoupons.notesPreffix' | cxTranslate\n            }}<a [routerLink]=\"['/my-account/notification-preference']\">{{\n              'myCoupons.notesLink' | cxTranslate\n            }}</a\n            >{{ 'myCoupons.notesSuffix' | cxTranslate }}</span\n          >\n        </div>\n      </ng-container>\n    </ng-container>\n\n    <ng-template #noCoupons>\n      <section>\n        <p class=\"cx-section-msg\">\n          {{ 'myCoupons.noCouponsMessage' | cxTranslate }}\n        </p>\n      </section>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"col-md-12 cx-coupon-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "component", type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "ariaControls", "ariaLabel", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { kind: "component", type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { kind: "component", type: CouponCardComponent, selector: "cx-coupon-card", inputs: ["coupon", "couponSubscriptionLoading$"], outputs: ["notificationChanged"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-my-coupons', template: "<div class=\"cx-section\">\n  <ng-container *ngIf=\"!(couponsLoading$ | async); else loading\">\n    <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n    <ng-container *ngIf=\"couponResult$ | async as couponResult\">\n      <div class=\"cx-my-coupons-header\">\n        <h2>\n          {{ 'myCoupons.myCoupons' | cxTranslate }}\n        </h2>\n      </div>\n      <ng-container\n        *ngIf=\"\n          couponResult.pagination &&\n            couponResult.pagination.totalCount &&\n            couponResult.pagination.totalCount > 0;\n          else noCoupons\n        \"\n      >\n        <div class=\"cx-my-coupons-sort top row\">\n          <label\n            class=\"\n              cx-my-coupons-form-group\n              form-group\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n              [ariaLabel]=\"'myCoupons.sortCoupons' | cxTranslate\"\n              ariaControls=\"coupon-deck\"\n            >\n            </cx-sorting>\n          </label>\n          <div class=\"cx-my-coupons-pagination cx-mycoupon-thead-mobile\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n\n        <div id=\"coupon-deck\" class=\"row cx-coupon-deck\">\n          <div\n            *ngFor=\"let coupon of couponResult.coupons\"\n            class=\"col-md-6 cx-coupon-card\"\n          >\n            <cx-coupon-card\n              [coupon]=\"coupon\"\n              [couponSubscriptionLoading$]=\"couponSubscriptionLoading$\"\n              (notificationChanged)=\"notificationChange($event)\"\n            ></cx-coupon-card>\n          </div>\n        </div>\n\n        <div class=\"cx-my-coupons-sort bottom row\">\n          <label\n            class=\"\n              cx-my-coupons-form-group\n              form-group\n              cx-mycoupon-thead-mobile\n              col-sm-12 col-md-4 col-lg-4\n            \"\n          >\n            <span>{{ 'myCoupons.sortBy' | cxTranslate }}</span>\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n              placeholder=\"{{ 'myCoupons.sortBy' | cxTranslate }}\"\n              [ariaLabel]=\"'myCoupons.sortCoupons' | cxTranslate\"\n              ariaControls=\"coupon-deck\"\n            >\n            </cx-sorting>\n          </label>\n          <div class=\"cx-my-coupons-pagination\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <div class=\"cx-my-coupons-notes\">\n          <span>\n            <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n            {{ 'myCoupons.notesPreffix' | cxTranslate\n            }}<a [routerLink]=\"['/my-account/notification-preference']\">{{\n              'myCoupons.notesLink' | cxTranslate\n            }}</a\n            >{{ 'myCoupons.notesSuffix' | cxTranslate }}</span\n          >\n        </div>\n      </ng-container>\n    </ng-container>\n\n    <ng-template #noCoupons>\n      <section>\n        <p class=\"cx-section-msg\">\n          {{ 'myCoupons.noCouponsMessage' | cxTranslate }}\n        </p>\n      </section>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"col-md-12 cx-coupon-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.CustomerCouponService }, { type: MyCouponsComponentService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CouponDialogComponent {
    handleClick(event) {
        if (event.target.tagName === this.el.nativeElement.tagName) {
            this.close('Cross click');
        }
    }
    constructor(launchDialogService, el) {
        this.launchDialogService = launchDialogService;
        this.el = el;
        this.subscription = new Subscription();
        this.iconTypes = ICON_TYPE;
        this.focusConfig = {
            trap: true,
            block: true,
            autofocus: 'button',
            focusOnEscape: true,
        };
    }
    ngOnInit() {
        this.subscription.add(this.launchDialogService.data$.subscribe((data) => {
            this.coupon = data.coupon;
        }));
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
    }
    close(reason) {
        this.launchDialogService.closeDialog(reason);
    }
}
CouponDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CouponDialogComponent, deps: [{ token: LaunchDialogService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
CouponDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: CouponDialogComponent, selector: "cx-coupon-dialog", host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0, template: "<div\n  class=\"cx-coupon-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-coupon-container\">\n    <!-- Modal Header -->\n\n    <div class=\"cx-dialog-header modal-header\">\n      <div class=\"cx-dialog-title modal-title\">\n        {{ 'myCoupons.dialogTitle' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        (click)=\"close('Cross click')\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <div class=\"cx-dialog-body modal-body\">\n      <div class=\"cx-dialog-row\">\n        <div class=\"cx-dialog-item col-sm-12 col-md-12\">\n          <div class=\"cx-coupon-card-head\">\n            <span class=\"card-label-bold cx-coupon-card-id\">{{\n              coupon?.couponId\n            }}</span>\n            <span>: {{ coupon?.name }}</span>\n          </div>\n          <div class=\"cx-coupon-description\">{{ coupon?.description }}</div>\n\n          <div class=\"cx-coupon-dialog-date\">\n            <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n            <div class=\"cx-coupon-date\">\n              {{ coupon?.startDate | cxDate: 'medium' }} -\n              {{ coupon?.endDate | cxDate: 'medium' }}\n            </div>\n          </div>\n\n          <div class=\"cx-coupon-dialog-status\">\n            <p>{{ 'myCoupons.status' | cxTranslate }}</p>\n            <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n              {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "pipe", type: i3.LowerCasePipe, name: "lowercase" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.CxDatePipe, name: "cxDate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CouponDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-coupon-dialog', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"cx-coupon-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-coupon-container\">\n    <!-- Modal Header -->\n\n    <div class=\"cx-dialog-header modal-header\">\n      <div class=\"cx-dialog-title modal-title\">\n        {{ 'myCoupons.dialogTitle' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        (click)=\"close('Cross click')\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <div class=\"cx-dialog-body modal-body\">\n      <div class=\"cx-dialog-row\">\n        <div class=\"cx-dialog-item col-sm-12 col-md-12\">\n          <div class=\"cx-coupon-card-head\">\n            <span class=\"card-label-bold cx-coupon-card-id\">{{\n              coupon?.couponId\n            }}</span>\n            <span>: {{ coupon?.name }}</span>\n          </div>\n          <div class=\"cx-coupon-description\">{{ coupon?.description }}</div>\n\n          <div class=\"cx-coupon-dialog-date\">\n            <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n            <div class=\"cx-coupon-date\">\n              {{ coupon?.startDate | cxDate: 'medium' }} -\n              {{ coupon?.endDate | cxDate: 'medium' }}\n            </div>\n          </div>\n\n          <div class=\"cx-coupon-dialog-status\">\n            <p>{{ 'myCoupons.status' | cxTranslate }}</p>\n            <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n              {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: LaunchDialogService }, { type: i0.ElementRef }]; }, propDecorators: { handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CouponClaimComponent {
    constructor(couponService, routingService, messageService) {
        this.couponService = couponService;
        this.routingService = routingService;
        this.messageService = messageService;
    }
    ngOnInit() {
        this.routingService
            .getRouterState()
            .subscribe((k) => {
            const couponCode = k.state.params.couponCode;
            if (couponCode) {
                this.couponService.claimCustomerCoupon(couponCode);
                this.subscription = this.couponService
                    .getClaimCustomerCouponResultSuccess()
                    .subscribe((success) => {
                    if (success) {
                        this.messageService.add({ key: 'myCoupons.claimCustomerCoupon' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
                    }
                    this.routingService.go({ cxRoute: 'coupons' });
                });
            }
            else {
                this.routingService.go({ cxRoute: 'notFound' });
            }
        })
            .unsubscribe();
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
CouponClaimComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CouponClaimComponent, deps: [{ token: i1.CustomerCouponService }, { token: i1.RoutingService }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Component });
CouponClaimComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: CouponClaimComponent, selector: "cx-coupon-claim", ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CouponClaimComponent, decorators: [{
            type: Component,
            args: [{
                    template: '',
                    selector: 'cx-coupon-claim',
                }]
        }], ctorParameters: function () { return [{ type: i1.CustomerCouponService }, { type: i1.RoutingService }, { type: i1.GlobalMessageService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultCouponLayoutConfig = {
    launch: {
        COUPON: {
            inlineRoot: true,
            component: CouponDialogComponent,
            dialogType: DIALOG_TYPE.DIALOG,
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MyCouponsModule {
}
MyCouponsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MyCouponsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsModule, declarations: [MyCouponsComponent,
        CouponCardComponent,
        CouponDialogComponent,
        CouponClaimComponent], imports: [CommonModule,
        CardModule,
        SpinnerModule,
        I18nModule,
        RouterModule,
        UrlModule,
        IconModule,
        ListNavigationModule, i1$2.RouterModule, KeyboardFocusModule], exports: [MyCouponsComponent, CouponClaimComponent] });
MyCouponsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                MyCouponsComponent: {
                    component: MyCouponsComponent,
                    guards: [AuthGuard],
                },
                CouponClaimComponent: {
                    component: CouponClaimComponent,
                    guards: [AuthGuard],
                },
            },
        }),
        provideDefaultConfig(defaultCouponLayoutConfig),
    ], imports: [CommonModule,
        CardModule,
        SpinnerModule,
        I18nModule,
        RouterModule,
        UrlModule,
        IconModule,
        ListNavigationModule,
        RouterModule.forChild([
            {
                // @ts-ignore
                path: null,
                canActivate: [AuthGuard, CmsPageGuard],
                component: PageLayoutComponent,
                data: { cxRoute: 'couponClaim' },
            },
        ]),
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyCouponsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CardModule,
                        SpinnerModule,
                        I18nModule,
                        RouterModule,
                        UrlModule,
                        IconModule,
                        ListNavigationModule,
                        RouterModule.forChild([
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'couponClaim' },
                            },
                        ]),
                        KeyboardFocusModule,
                    ],
                    declarations: [
                        MyCouponsComponent,
                        CouponCardComponent,
                        CouponDialogComponent,
                        CouponClaimComponent,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                MyCouponsComponent: {
                                    component: MyCouponsComponent,
                                    guards: [AuthGuard],
                                },
                                CouponClaimComponent: {
                                    component: CouponClaimComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                        provideDefaultConfig(defaultCouponLayoutConfig),
                    ],
                    exports: [MyCouponsComponent, CouponClaimComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MyInterestsComponent {
    constructor(productInterestService, translationService, productService, globalMessageService) {
        this.productInterestService = productInterestService;
        this.translationService = translationService;
        this.productService = productService;
        this.globalMessageService = globalMessageService;
        this.DEFAULT_PAGE_SIZE = 10;
        this.sortMapping = {
            byNameAsc: 'name:asc',
            byNameDesc: 'name:desc',
        };
        this.sortChanged = false;
        this.sort = 'byNameAsc';
        this.sortOptions = [
            {
                code: 'byNameAsc',
                selected: false,
            },
            {
                code: 'byNameDesc',
                selected: false,
            },
        ];
    }
    ngOnInit() {
        this.interests$ = this.productInterestService
            .getAndLoadProductInterests(this.DEFAULT_PAGE_SIZE)
            .pipe(tap((interests) => (this.pagination = {
            currentPage: interests.pagination?.page,
            pageSize: interests.pagination?.count,
            totalPages: interests.pagination?.totalPages,
            totalResults: interests.pagination?.totalCount,
            sort: 'byNameAsc',
        })), tap(() => {
            if (this.sortChanged) {
                this.sortChanged = false;
                this.globalMessageService?.add({ key: 'sorting.pageViewUpdated' }, GlobalMessageType.MSG_TYPE_ASSISTIVE, 500);
            }
        }), map((interest) => ({
            ...interest,
            results: interest.results
                ? interest.results.map((result) => ({
                    ...result,
                    product$: this.getProduct(result),
                }))
                : interest.results,
        })));
        this.getInterestsloading$ =
            this.productInterestService.getProdutInterestsLoading();
        this.isRemoveDisabled$ = combineLatest([
            this.getInterestsloading$,
            this.productInterestService.getRemoveProdutInterestLoading(),
        ]).pipe(map(([getLoading, removeLoading]) => getLoading || removeLoading));
        this.sortLabels = this.getSortLabels();
    }
    getSortLabels() {
        return combineLatest([
            this.translationService.translate('myInterests.sorting.byNameAsc'),
            this.translationService.translate('myInterests.sorting.byNameDesc'),
        ]).pipe(map(([asc, desc]) => {
            return {
                byNameAsc: asc,
                byNameDesc: desc,
            };
        }));
    }
    getProduct(interest) {
        return this.productService.get(interest.product?.code ?? '', "details" /* ProductScope.DETAILS */);
    }
    removeInterest(relation) {
        this.productInterestService.removeProdutInterest({
            product: relation.product,
            productInterestEntry: relation.productInterestEntry,
        });
    }
    sortChange(sort) {
        this.sort = sort;
        this.sortChanged = true;
        this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, 0, this.sortMapping[sort]);
    }
    pageChange(page) {
        this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, page, this.sortMapping[this.sort]);
    }
    ngOnDestroy() {
        this.productInterestService.clearProductInterests();
        this.productInterestService.resetRemoveInterestState();
    }
}
MyInterestsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyInterestsComponent, deps: [{ token: i1.UserInterestsService }, { token: i1.TranslationService }, { token: i1.ProductService }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Component });
MyInterestsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: MyInterestsComponent, selector: "cx-my-interests", ngImport: i0, template: "<div *ngIf=\"interests$ | async as interests\" class=\"container\">\n  <div class=\"cx-product-interests-title\">\n    <h2>{{ 'myInterests.header' | cxTranslate }}</h2>\n  </div>\n  <div\n    class=\"cx-product-interests-body\"\n    *ngIf=\"!(getInterestsloading$ | async); else loading\"\n  >\n    <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n    <ng-container\n      *ngIf=\"\n        interests.pagination &&\n          interests.pagination.totalCount &&\n          interests.pagination.totalCount > 0;\n        else noInterest\n      \"\n    >\n      <div class=\"cx-product-interests-sort top row\">\n        <label\n          class=\"\n            cx-product-interests-form-group\n            form-group\n            col-sm-12 col-md-4 col-lg-4\n          \"\n          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortBy' | cxTranslate }}\"\n            [ariaLabel]=\"'myInterests.sortInterests' | cxTranslate\"\n            ariaControls=\"product-interests-table\"\n          >\n          </cx-sorting>\n        </label>\n        <div\n          class=\"\n            cx-product-interests-pagination cx-product-interests-thead-mobile\n          \"\n        >\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n\n      <table\n        id=\"product-interests-table\"\n        class=\"table cx-product-interests-table cx-product-interests-table-list\"\n      >\n        <caption class=\"cx-visually-hidden\">\n          {{\n            'myInterests.caption' | cxTranslate\n          }}\n        </caption>\n        <thead\n          class=\"cx-product-interests-thead-mobile cx-product-interests-header\"\n        >\n          <th role=\"columnheader\">\n            {{ 'myInterests.item' | cxTranslate }}\n          </th>\n          <th role=\"columnheader\">\n            {{ 'myInterests.price' | cxTranslate }}\n          </th>\n          <th role=\"columnheader\">\n            {{ 'myInterests.notifications' | cxTranslate }}\n          </th>\n          <th srole=\"columnheader\">\n            {{ 'myInterests.actions' | cxTranslate }}\n          </th>\n        </thead>\n        <tbody>\n          <tr\n            *ngFor=\"let interest of interests.results\"\n            class=\"cx-product-interests-product-item\"\n            role=\"row\"\n          >\n            <ng-container *ngIf=\"interest.product$ | async as product\">\n              <td role=\"cell\">\n                <div class=\"cx-product-interests-cell-wrapper\">\n                  <div class=\"cx-product-interests-label\">\n                    <a\n                      class=\"cx-product-interests-product-image-link\"\n                      tabindex=\"-1\"\n                      [routerLink]=\"\n                        { cxRoute: 'product', params: product } | cxUrl\n                      \"\n                    >\n                      <cx-media\n                        [container]=\"product.images?.PRIMARY\"\n                        format=\"thumbnail\"\n                      ></cx-media>\n                    </a>\n                  </div>\n\n                  <div class=\"cx-info col-10\">\n                    <div class=\"cx-info-container row\">\n                      <div>\n                        <div *ngIf=\"product.name\" class=\"cx-name\">\n                          <a\n                            class=\"\n                              cx-link cx-product-interests-product-code-link\n                            \"\n                            [routerLink]=\"\n                              { cxRoute: 'product', params: product } | cxUrl\n                            \"\n                          >\n                            {{ product.name }}\n                          </a>\n                        </div>\n                        <div *ngIf=\"product.code\" class=\"cx-code\">\n                          <span>{{\n                            'myInterests.productId'\n                              | cxTranslate: { code: product.code }\n                          }}</span>\n                        </div>\n\n                        <ng-container\n                          *ngFor=\"let baseOptions of product.baseOptions\"\n                        >\n                          <div\n                            *ngFor=\"\n                              let variant of baseOptions.selected\n                                ?.variantOptionQualifiers\n                            \"\n                            class=\"cx-property\"\n                          >\n                            <div\n                              class=\"cx-label cx-product-interests-variant-name\"\n                            >\n                              {{ variant.name }}\n                            </div>\n                            <div\n                              class=\"\n                                cx-value cx-product-interests-variant-value\n                              \"\n                            >\n                              {{ variant.value }}\n                            </div>\n                          </div>\n                        </ng-container>\n                        <div\n                          class=\"cx-property\"\n                          *ngIf=\"\n                            product.stock?.stockLevelStatus === 'outOfStock'\n                          \"\n                        >\n                          <div\n                            class=\"cx-label cx-product-interests-product-stock\"\n                          >\n                            {{ 'myInterests.outOfStock' | cxTranslate }}\n                          </div>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </td>\n              <td role=\"cell\">\n                <div class=\"cx-product-interests-product-price\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.price' | cxTranslate }}\n                  </div>\n                  <span>{{ product.price?.formattedValue }}</span>\n                </div>\n              </td>\n              <td role=\"cell\">\n                <div class=\"cx-product-interests-subscriptions\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.notifications' | cxTranslate }}\n                  </div>\n                  <div\n                    class=\"cx-product-interests-notification\"\n                    *ngFor=\"let interestEntry of interest.productInterestEntry\"\n                  >\n                    <span class=\"cx-product-interests-type\">\n                      {{\n                        'myInterests.' + interestEntry.interestType\n                          | cxTranslate\n                      }}\n                    </span>\n                    <span class=\"cx-product-interests-expiration-date\">\n                      {{\n                        'myInterests.expirationDate'\n                          | cxTranslate\n                            : {\n                                expirationDate:\n                                  interestEntry.expirationDate | cxDate\n                              }\n                      }}\n                    </span>\n                  </div>\n                </div>\n              </td>\n              <td role=\"cell\">\n                <div class=\"cx-actions cx-product-interests-remove-button\">\n                  <button\n                    type=\"button\"\n                    class=\"\n                      cx-product-interests-remove-btn\n                      link\n                      cx-action-link cx-remove-btn\n                    \"\n                    [cxAtMessage]=\"'myInterests.itemRemoved' | cxTranslate\"\n                    [disabled]=\"isRemoveDisabled$ | async\"\n                    (click)=\"removeInterest(interest)\"\n                  >\n                    {{ 'myInterests.remove' | cxTranslate }}\n                  </button>\n                </div>\n              </td>\n            </ng-container>\n          </tr>\n        </tbody>\n      </table>\n\n      <div class=\"cx-product-interests-sort bottom row\">\n        <label\n          class=\"\n            cx-product-interests-form-group cx-product-interests-thead-mobile\n            form-group\n            col-sm-12 col-md-4 col-lg-4\n          \"\n          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortBy' | cxTranslate }}\"\n            [ariaLabel]=\"'myInterests.sortInterests' | cxTranslate\"\n            ariaControls=\"product-interests-table\"\n          >\n          </cx-sorting>\n        </label>\n        <div class=\"cx-product-interests-pagination\">\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n</div>\n<ng-template #noInterest>\n  <div class=\"cx-product-interests-message\">\n    {{ 'myInterests.noInterests' | cxTranslate }}\n  </div>\n</ng-template>\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: AtMessageDirective, selector: "[cxAtMessage]", inputs: ["cxAtMessage"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "ariaControls", "ariaLabel", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { kind: "component", type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { kind: "component", type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.CxDatePipe, name: "cxDate" }, { kind: "pipe", type: i1.UrlPipe, name: "cxUrl" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyInterestsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-my-interests', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div *ngIf=\"interests$ | async as interests\" class=\"container\">\n  <div class=\"cx-product-interests-title\">\n    <h2>{{ 'myInterests.header' | cxTranslate }}</h2>\n  </div>\n  <div\n    class=\"cx-product-interests-body\"\n    *ngIf=\"!(getInterestsloading$ | async); else loading\"\n  >\n    <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n    <ng-container\n      *ngIf=\"\n        interests.pagination &&\n          interests.pagination.totalCount &&\n          interests.pagination.totalCount > 0;\n        else noInterest\n      \"\n    >\n      <div class=\"cx-product-interests-sort top row\">\n        <label\n          class=\"\n            cx-product-interests-form-group\n            form-group\n            col-sm-12 col-md-4 col-lg-4\n          \"\n          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortBy' | cxTranslate }}\"\n            [ariaLabel]=\"'myInterests.sortInterests' | cxTranslate\"\n            ariaControls=\"product-interests-table\"\n          >\n          </cx-sorting>\n        </label>\n        <div\n          class=\"\n            cx-product-interests-pagination cx-product-interests-thead-mobile\n          \"\n        >\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n\n      <table\n        id=\"product-interests-table\"\n        class=\"table cx-product-interests-table cx-product-interests-table-list\"\n      >\n        <caption class=\"cx-visually-hidden\">\n          {{\n            'myInterests.caption' | cxTranslate\n          }}\n        </caption>\n        <thead\n          class=\"cx-product-interests-thead-mobile cx-product-interests-header\"\n        >\n          <th role=\"columnheader\">\n            {{ 'myInterests.item' | cxTranslate }}\n          </th>\n          <th role=\"columnheader\">\n            {{ 'myInterests.price' | cxTranslate }}\n          </th>\n          <th role=\"columnheader\">\n            {{ 'myInterests.notifications' | cxTranslate }}\n          </th>\n          <th srole=\"columnheader\">\n            {{ 'myInterests.actions' | cxTranslate }}\n          </th>\n        </thead>\n        <tbody>\n          <tr\n            *ngFor=\"let interest of interests.results\"\n            class=\"cx-product-interests-product-item\"\n            role=\"row\"\n          >\n            <ng-container *ngIf=\"interest.product$ | async as product\">\n              <td role=\"cell\">\n                <div class=\"cx-product-interests-cell-wrapper\">\n                  <div class=\"cx-product-interests-label\">\n                    <a\n                      class=\"cx-product-interests-product-image-link\"\n                      tabindex=\"-1\"\n                      [routerLink]=\"\n                        { cxRoute: 'product', params: product } | cxUrl\n                      \"\n                    >\n                      <cx-media\n                        [container]=\"product.images?.PRIMARY\"\n                        format=\"thumbnail\"\n                      ></cx-media>\n                    </a>\n                  </div>\n\n                  <div class=\"cx-info col-10\">\n                    <div class=\"cx-info-container row\">\n                      <div>\n                        <div *ngIf=\"product.name\" class=\"cx-name\">\n                          <a\n                            class=\"\n                              cx-link cx-product-interests-product-code-link\n                            \"\n                            [routerLink]=\"\n                              { cxRoute: 'product', params: product } | cxUrl\n                            \"\n                          >\n                            {{ product.name }}\n                          </a>\n                        </div>\n                        <div *ngIf=\"product.code\" class=\"cx-code\">\n                          <span>{{\n                            'myInterests.productId'\n                              | cxTranslate: { code: product.code }\n                          }}</span>\n                        </div>\n\n                        <ng-container\n                          *ngFor=\"let baseOptions of product.baseOptions\"\n                        >\n                          <div\n                            *ngFor=\"\n                              let variant of baseOptions.selected\n                                ?.variantOptionQualifiers\n                            \"\n                            class=\"cx-property\"\n                          >\n                            <div\n                              class=\"cx-label cx-product-interests-variant-name\"\n                            >\n                              {{ variant.name }}\n                            </div>\n                            <div\n                              class=\"\n                                cx-value cx-product-interests-variant-value\n                              \"\n                            >\n                              {{ variant.value }}\n                            </div>\n                          </div>\n                        </ng-container>\n                        <div\n                          class=\"cx-property\"\n                          *ngIf=\"\n                            product.stock?.stockLevelStatus === 'outOfStock'\n                          \"\n                        >\n                          <div\n                            class=\"cx-label cx-product-interests-product-stock\"\n                          >\n                            {{ 'myInterests.outOfStock' | cxTranslate }}\n                          </div>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </td>\n              <td role=\"cell\">\n                <div class=\"cx-product-interests-product-price\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.price' | cxTranslate }}\n                  </div>\n                  <span>{{ product.price?.formattedValue }}</span>\n                </div>\n              </td>\n              <td role=\"cell\">\n                <div class=\"cx-product-interests-subscriptions\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.notifications' | cxTranslate }}\n                  </div>\n                  <div\n                    class=\"cx-product-interests-notification\"\n                    *ngFor=\"let interestEntry of interest.productInterestEntry\"\n                  >\n                    <span class=\"cx-product-interests-type\">\n                      {{\n                        'myInterests.' + interestEntry.interestType\n                          | cxTranslate\n                      }}\n                    </span>\n                    <span class=\"cx-product-interests-expiration-date\">\n                      {{\n                        'myInterests.expirationDate'\n                          | cxTranslate\n                            : {\n                                expirationDate:\n                                  interestEntry.expirationDate | cxDate\n                              }\n                      }}\n                    </span>\n                  </div>\n                </div>\n              </td>\n              <td role=\"cell\">\n                <div class=\"cx-actions cx-product-interests-remove-button\">\n                  <button\n                    type=\"button\"\n                    class=\"\n                      cx-product-interests-remove-btn\n                      link\n                      cx-action-link cx-remove-btn\n                    \"\n                    [cxAtMessage]=\"'myInterests.itemRemoved' | cxTranslate\"\n                    [disabled]=\"isRemoveDisabled$ | async\"\n                    (click)=\"removeInterest(interest)\"\n                  >\n                    {{ 'myInterests.remove' | cxTranslate }}\n                  </button>\n                </div>\n              </td>\n            </ng-container>\n          </tr>\n        </tbody>\n      </table>\n\n      <div class=\"cx-product-interests-sort bottom row\">\n        <label\n          class=\"\n            cx-product-interests-form-group cx-product-interests-thead-mobile\n            form-group\n            col-sm-12 col-md-4 col-lg-4\n          \"\n          ><span>{{ 'myInterests.sortBy' | cxTranslate }}</span>\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortBy' | cxTranslate }}\"\n            [ariaLabel]=\"'myInterests.sortInterests' | cxTranslate\"\n            ariaControls=\"product-interests-table\"\n          >\n          </cx-sorting>\n        </label>\n        <div class=\"cx-product-interests-pagination\">\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n</div>\n<ng-template #noInterest>\n  <div class=\"cx-product-interests-message\">\n    {{ 'myInterests.noInterests' | cxTranslate }}\n  </div>\n</ng-template>\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1.UserInterestsService }, { type: i1.TranslationService }, { type: i1.ProductService }, { type: i1.GlobalMessageService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class MyInterestsModule {
}
MyInterestsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyInterestsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MyInterestsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: MyInterestsModule, declarations: [MyInterestsComponent], imports: [AtMessageModule,
        CommonModule,
        I18nModule,
        ListNavigationModule,
        I18nModule,
        UrlModule,
        MediaModule,
        SpinnerModule, i1$2.RouterModule], exports: [MyInterestsComponent] });
MyInterestsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyInterestsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                MyInterestsComponent: {
                    component: MyInterestsComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [AtMessageModule,
        CommonModule,
        I18nModule,
        ListNavigationModule,
        I18nModule,
        UrlModule,
        MediaModule,
        SpinnerModule,
        RouterModule.forChild([
            {
                // @ts-ignore
                path: null,
                canActivate: [AuthGuard, CmsPageGuard],
                component: PageLayoutComponent,
                data: { cxRoute: 'myInterests' },
            },
        ])] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: MyInterestsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MyInterestsComponent],
                    imports: [
                        AtMessageModule,
                        CommonModule,
                        I18nModule,
                        ListNavigationModule,
                        I18nModule,
                        UrlModule,
                        MediaModule,
                        SpinnerModule,
                        RouterModule.forChild([
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'myInterests' },
                            },
                        ]),
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                MyInterestsComponent: {
                                    component: MyInterestsComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    exports: [MyInterestsComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NotificationPreferenceComponent {
    constructor(notificationPreferenceService) {
        this.notificationPreferenceService = notificationPreferenceService;
        this.preferences = [];
    }
    ngOnInit() {
        this.notificationPreferenceService.resetNotificationPreferences();
        this.preferences$ = this.notificationPreferenceService
            .getPreferences()
            .pipe(tap((preferences) => (this.preferences = preferences)));
        this.notificationPreferenceService.loadPreferences();
        this.isLoading$ = combineLatest([
            this.notificationPreferenceService.getPreferencesLoading(),
            this.notificationPreferenceService.getUpdatePreferencesResultLoading(),
        ]).pipe(map(([prefsLoading, updateLoading]) => prefsLoading || updateLoading));
    }
    updatePreference(preference) {
        const updatedPreferences = [];
        this.preferences.forEach((p) => {
            if (p.channel === preference.channel) {
                updatedPreferences.push({
                    ...p,
                    enabled: !p.enabled,
                });
            }
            else {
                updatedPreferences.push(p);
            }
        });
        this.notificationPreferenceService.updatePreferences(updatedPreferences);
    }
}
NotificationPreferenceComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NotificationPreferenceComponent, deps: [{ token: i1.UserNotificationPreferenceService }], target: i0.ɵɵFactoryTarget.Component });
NotificationPreferenceComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: NotificationPreferenceComponent, selector: "cx-notification-preference", ngImport: i0, template: "<ng-container *ngIf=\"preferences$ | async as preferences\">\n  <div *ngIf=\"preferences.length > 0; else loading\">\n    <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n    <div class=\"row d-flex justify-content-center\">\n      <div class=\"col-md-8\">\n        <div class=\"pref-header\">\n          {{ 'notificationPreference.message' | cxTranslate }}\n        </div>\n        <div class=\"form-check cx-notification-channels\">\n          <ng-container *ngFor=\"let preference of preferences\">\n            <label *ngIf=\"preference.visible\" class=\"pref-channel\">\n              <input\n                class=\"form-check-input cx-np-checkbox\"\n                role=\"checkbox\"\n                type=\"checkbox\"\n                [checked]=\"preference.enabled\"\n                (change)=\"updatePreference(preference)\"\n                [disabled]=\"isLoading$ | async\"\n              />\n              <span class=\"form-check-label\">\n                {{\n                  'notificationPreference.' + preference.channel | cxTranslate\n                }}\n                {{ preference.value }}\n              </span>\n            </label>\n          </ng-container>\n        </div>\n        <label class=\"pref-note\"\n          ><strong>{{ 'notificationPreference.note' | cxTranslate }}</strong\n          >{{ 'notificationPreference.noteMessage' | cxTranslate }}\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NotificationPreferenceComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-notification-preference', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"preferences$ | async as preferences\">\n  <div *ngIf=\"preferences.length > 0; else loading\">\n    <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n    <div class=\"row d-flex justify-content-center\">\n      <div class=\"col-md-8\">\n        <div class=\"pref-header\">\n          {{ 'notificationPreference.message' | cxTranslate }}\n        </div>\n        <div class=\"form-check cx-notification-channels\">\n          <ng-container *ngFor=\"let preference of preferences\">\n            <label *ngIf=\"preference.visible\" class=\"pref-channel\">\n              <input\n                class=\"form-check-input cx-np-checkbox\"\n                role=\"checkbox\"\n                type=\"checkbox\"\n                [checked]=\"preference.enabled\"\n                (change)=\"updatePreference(preference)\"\n                [disabled]=\"isLoading$ | async\"\n              />\n              <span class=\"form-check-label\">\n                {{\n                  'notificationPreference.' + preference.channel | cxTranslate\n                }}\n                {{ preference.value }}\n              </span>\n            </label>\n          </ng-container>\n        </div>\n        <label class=\"pref-note\"\n          ><strong>{{ 'notificationPreference.note' | cxTranslate }}</strong\n          >{{ 'notificationPreference.noteMessage' | cxTranslate }}\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: i1.UserNotificationPreferenceService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NotificationPreferenceModule {
}
NotificationPreferenceModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NotificationPreferenceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NotificationPreferenceModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: NotificationPreferenceModule, declarations: [NotificationPreferenceComponent], imports: [CommonModule,
        SpinnerModule,
        I18nModule, i1$2.RouterModule], exports: [NotificationPreferenceComponent] });
NotificationPreferenceModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NotificationPreferenceModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                NotificationPreferenceComponent: {
                    component: NotificationPreferenceComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [CommonModule,
        SpinnerModule,
        I18nModule,
        RouterModule.forChild([
            {
                // @ts-ignore
                path: null,
                canActivate: [AuthGuard, CmsPageGuard],
                component: PageLayoutComponent,
                data: { cxRoute: 'notificationPreference' },
            },
        ])] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NotificationPreferenceModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NotificationPreferenceComponent],
                    imports: [
                        CommonModule,
                        SpinnerModule,
                        I18nModule,
                        RouterModule.forChild([
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'notificationPreference' },
                            },
                        ]),
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                NotificationPreferenceComponent: {
                                    component: NotificationPreferenceComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    exports: [NotificationPreferenceComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PaymentMethodsComponent {
    constructor(userPaymentService, translation, globalMessageService) {
        this.userPaymentService = userPaymentService;
        this.translation = translation;
        this.globalMessageService = globalMessageService;
        this.iconTypes = ICON_TYPE;
    }
    ngOnInit() {
        this.paymentMethods$ = this.userPaymentService.getPaymentMethods().pipe(tap((paymentDetails) => {
            // Set first payment method to DEFAULT if none is set
            if (paymentDetails.length > 0 &&
                !paymentDetails.find((paymentDetail) => paymentDetail.defaultPayment)) {
                this.setDefaultPaymentMethod(paymentDetails[0]);
            }
        }));
        this.editCard = undefined;
        this.loading$ = this.userPaymentService.getPaymentMethodsLoading();
        this.userPaymentService.loadPaymentMethods();
    }
    getCardContent({ defaultPayment, accountHolderName, expiryMonth, expiryYear, cardNumber, cardType, }) {
        return combineLatest([
            this.translation.translate('paymentCard.setAsDefault'),
            this.translation.translate('common.delete'),
            this.translation.translate('paymentCard.deleteConfirmation'),
            this.translation.translate('paymentCard.expires', {
                month: expiryMonth,
                year: expiryYear,
            }),
            this.translation.translate('paymentCard.defaultPaymentMethod'),
        ]).pipe(map(([textSetAsDefault, textDelete, textDeleteConfirmation, textExpires, textDefaultPaymentMethod,]) => {
            const actions = [];
            if (!defaultPayment) {
                actions.push({ name: textSetAsDefault, event: 'default' });
            }
            actions.push({ name: textDelete, event: 'edit' });
            const card = {
                role: 'region',
                header: defaultPayment ? textDefaultPaymentMethod : undefined,
                textBold: accountHolderName,
                text: [cardNumber ?? '', textExpires],
                actions,
                deleteMsg: textDeleteConfirmation,
                img: this.getCardIcon(cardType?.code ?? ''),
                label: defaultPayment
                    ? 'paymentCard.defaultPaymentLabel'
                    : 'paymentCard.additionalPaymentLabel',
            };
            return card;
        }));
    }
    deletePaymentMethod(paymentMethod) {
        if (paymentMethod.id) {
            this.userPaymentService.deletePaymentMethod(paymentMethod.id);
            this.editCard = undefined;
        }
    }
    setEdit(paymentMethod) {
        this.editCard = paymentMethod.id;
    }
    cancelCard() {
        this.editCard = undefined;
    }
    setDefaultPaymentMethod(paymentMethod) {
        this.userPaymentService.setPaymentMethodAsDefault(paymentMethod.id ?? '');
        this.globalMessageService?.add({ key: 'paymentMessages.setAsDefaultSuccessfully' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
    }
    getCardIcon(code) {
        let ccIcon;
        if (code === 'visa') {
            ccIcon = this.iconTypes.VISA;
        }
        else if (code === 'master' || code === 'mastercard_eurocard') {
            ccIcon = this.iconTypes.MASTER_CARD;
        }
        else if (code === 'diners') {
            ccIcon = this.iconTypes.DINERS_CLUB;
        }
        else if (code === 'amex') {
            ccIcon = this.iconTypes.AMEX;
        }
        else {
            ccIcon = this.iconTypes.CREDIT_CARD;
        }
        return ccIcon;
    }
}
PaymentMethodsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaymentMethodsComponent, deps: [{ token: i1.UserPaymentService }, { token: i1.TranslationService }, { token: i1.GlobalMessageService }], target: i0.ɵɵFactoryTarget.Component });
PaymentMethodsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PaymentMethodsComponent, selector: "cx-payment-methods", ngImport: i0, template: "<ng-container *ngIf=\"paymentMethods$ | async as paymentMethods\">\n  <div class=\"cx-payment container\">\n    <div class=\"cx-header\">\n      <h2>\n        {{ 'paymentMethods.paymentMethods' | cxTranslate }}\n      </h2>\n    </div>\n\n    <div class=\"cx-body\">\n      <div class=\"cx-msg\">\n        {{\n          'paymentMethods.newPaymentMethodsAreAddedDuringCheckout' | cxTranslate\n        }}\n      </div>\n      <div *ngIf=\"loading$ | async; else cards\"><cx-spinner></cx-spinner></div>\n      <ng-template #cards>\n        <div\n          role=\"status\"\n          [attr.aria-label]=\"'common.loaded' | cxTranslate\"\n        ></div>\n        <div class=\"cx-existing row\">\n          <div\n            class=\"cx-payment-card col-sm-12 col-md-12 col-lg-6\"\n            *ngFor=\"let paymentMethod of paymentMethods; let i = index\"\n          >\n            <div class=\"cx-payment-inner\">\n              <cx-card\n                [index]=\"i\"\n                [border]=\"true\"\n                [fitToContainer]=\"true\"\n                [content]=\"getCardContent(paymentMethod) | async\"\n                (deleteCard)=\"deletePaymentMethod(paymentMethod)\"\n                (setDefaultCard)=\"setDefaultPaymentMethod(paymentMethod)\"\n                (editCard)=\"setEdit(paymentMethod)\"\n                [editMode]=\"editCard === paymentMethod.id\"\n                (cancelCard)=\"cancelCard()\"\n              ></cx-card>\n            </div>\n          </div>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: CardComponent, selector: "cx-card", inputs: ["border", "editMode", "isDefault", "content", "fitToContainer", "truncateText", "charactersLimit", "index"], outputs: ["deleteCard", "setDefaultCard", "sendCard", "editCard", "cancelCard"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaymentMethodsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-payment-methods', template: "<ng-container *ngIf=\"paymentMethods$ | async as paymentMethods\">\n  <div class=\"cx-payment container\">\n    <div class=\"cx-header\">\n      <h2>\n        {{ 'paymentMethods.paymentMethods' | cxTranslate }}\n      </h2>\n    </div>\n\n    <div class=\"cx-body\">\n      <div class=\"cx-msg\">\n        {{\n          'paymentMethods.newPaymentMethodsAreAddedDuringCheckout' | cxTranslate\n        }}\n      </div>\n      <div *ngIf=\"loading$ | async; else cards\"><cx-spinner></cx-spinner></div>\n      <ng-template #cards>\n        <div\n          role=\"status\"\n          [attr.aria-label]=\"'common.loaded' | cxTranslate\"\n        ></div>\n        <div class=\"cx-existing row\">\n          <div\n            class=\"cx-payment-card col-sm-12 col-md-12 col-lg-6\"\n            *ngFor=\"let paymentMethod of paymentMethods; let i = index\"\n          >\n            <div class=\"cx-payment-inner\">\n              <cx-card\n                [index]=\"i\"\n                [border]=\"true\"\n                [fitToContainer]=\"true\"\n                [content]=\"getCardContent(paymentMethod) | async\"\n                (deleteCard)=\"deletePaymentMethod(paymentMethod)\"\n                (setDefaultCard)=\"setDefaultPaymentMethod(paymentMethod)\"\n                (editCard)=\"setEdit(paymentMethod)\"\n                [editMode]=\"editCard === paymentMethod.id\"\n                (cancelCard)=\"cancelCard()\"\n              ></cx-card>\n            </div>\n          </div>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: i1.UserPaymentService }, { type: i1.TranslationService }, { type: i1.GlobalMessageService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PaymentMethodsModule {
}
PaymentMethodsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaymentMethodsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PaymentMethodsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PaymentMethodsModule, declarations: [PaymentMethodsComponent], imports: [CommonModule, CardModule, SpinnerModule, I18nModule], exports: [PaymentMethodsComponent] });
PaymentMethodsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaymentMethodsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                AccountPaymentDetailsComponent: {
                    component: PaymentMethodsComponent,
                    guards: [AuthGuard],
                },
            },
        }),
    ], imports: [CommonModule, CardModule, SpinnerModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PaymentMethodsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, CardModule, SpinnerModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                AccountPaymentDetailsComponent: {
                                    component: PaymentMethodsComponent,
                                    guards: [AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PaymentMethodsComponent],
                    exports: [PaymentMethodsComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageTitleComponent {
    constructor(component, pageMetaService) {
        this.component = component;
        this.pageMetaService = pageMetaService;
    }
    ngOnInit() {
        this.setTitle();
    }
    ngAfterViewInit() {
        this.lastestTitle$ = this.title$;
    }
    setTitle() {
        this.title$ = this.pageMetaService.getMeta().pipe(filter(isNotNullable), map((meta) => (meta.heading || meta.title) ?? ''));
    }
}
PageTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageTitleComponent, deps: [{ token: CmsComponentData }, { token: i1.PageMetaService }], target: i0.ɵɵFactoryTarget.Component });
PageTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: PageTitleComponent, selector: "cx-page-title", ngImport: i0, template: "<h1 class=\"cx-visually-hidden\">{{ title$ | async }}</h1>\n", dependencies: [{ kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageTitleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-page-title', changeDetection: ChangeDetectionStrategy.OnPush, template: "<h1 class=\"cx-visually-hidden\">{{ title$ | async }}</h1>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.PageMetaService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class BreadcrumbComponent extends PageTitleComponent {
    constructor(component, pageMetaService, translation) {
        super(component, pageMetaService);
        this.component = component;
        this.pageMetaService = pageMetaService;
        this.translation = translation;
    }
    ngOnInit() {
        super.ngOnInit();
        this.setCrumbs();
    }
    setCrumbs() {
        this.crumbs$ = combineLatest([
            this.pageMetaService.getMeta(),
            this.translation.translate('common.home'),
        ]).pipe(map(([meta, textHome]) => meta?.breadcrumbs ? meta.breadcrumbs : [{ label: textHome, link: '/' }]));
    }
}
BreadcrumbComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbComponent, deps: [{ token: CmsComponentData }, { token: i1.PageMetaService }, { token: i1.TranslationService }], target: i0.ɵɵFactoryTarget.Component });
BreadcrumbComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: BreadcrumbComponent, selector: "cx-breadcrumb", usesInheritance: true, ngImport: i0, template: "<nav [attr.aria-label]=\"'common.breadcrumbs' | cxTranslate\" tabindex=\"-1\">\n  <ol [attr.aria-label]=\"'common.breadcrumbs' | cxTranslate\">\n    <li *ngFor=\"let crumb of crumbs$ | async\">\n      <a\n        [attr.aria-label]=\"\n          'navigation.navigateTo' | cxTranslate: { nav: crumb.label }\n        \"\n        [routerLink]=\"crumb.link\"\n        [innerHTML]=\"crumb.label\"\n      ></a>\n    </li>\n  </ol>\n</nav>\n<!-- Hidden page title for Screen Reader initialized after view to avoid old values -->\n<span class=\"cx-visually-hidden\" aria-live=\"polite\" aria-atomic=\"true\">\n  {{ lastestTitle$ | async }}\n</span>\n<h1>{{ title$ | async }}</h1>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-breadcrumb', changeDetection: ChangeDetectionStrategy.OnPush, template: "<nav [attr.aria-label]=\"'common.breadcrumbs' | cxTranslate\" tabindex=\"-1\">\n  <ol [attr.aria-label]=\"'common.breadcrumbs' | cxTranslate\">\n    <li *ngFor=\"let crumb of crumbs$ | async\">\n      <a\n        [attr.aria-label]=\"\n          'navigation.navigateTo' | cxTranslate: { nav: crumb.label }\n        \"\n        [routerLink]=\"crumb.link\"\n        [innerHTML]=\"crumb.label\"\n      ></a>\n    </li>\n  </ol>\n</nav>\n<!-- Hidden page title for Screen Reader initialized after view to avoid old values -->\n<span class=\"cx-visually-hidden\" aria-live=\"polite\" aria-atomic=\"true\">\n  {{ lastestTitle$ | async }}\n</span>\n<h1>{{ title$ | async }}</h1>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.PageMetaService }, { type: i1.TranslationService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class BreadcrumbModule {
}
BreadcrumbModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BreadcrumbModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbModule, declarations: [BreadcrumbComponent], imports: [CommonModule, RouterModule, PageMetaModule, I18nModule], exports: [BreadcrumbComponent] });
BreadcrumbModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                BreadcrumbComponent: {
                    component: BreadcrumbComponent,
                },
            },
        }),
    ], imports: [CommonModule, RouterModule, PageMetaModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BreadcrumbModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, PageMetaModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                BreadcrumbComponent: {
                                    component: BreadcrumbComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BreadcrumbComponent],
                    exports: [BreadcrumbComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NavigationService {
    constructor(cmsService, semanticPathService) {
        this.cmsService = cmsService;
        this.semanticPathService = semanticPathService;
    }
    createNavigation(data$) {
        return combineLatest([data$, this.getNavigationNode(data$)]).pipe(map(([data, nav]) => {
            return {
                title: data.name,
                children: [nav],
            };
        }));
    }
    /**
     * returns an observable with the `NavigationNode` for the given `CmsNavigationComponent`.
     * This function will load the navigation underlying entries and children if they haven't been
     * loaded so far.
     */
    getNavigationNode(data$) {
        if (!data$) {
            return of();
        }
        return data$.pipe(filter((data) => !!data), switchMap((data) => {
            const navigation = data.navigationNode ? data.navigationNode : data;
            return this.cmsService
                .getNavigationEntryItems(navigation.uid ?? '')
                .pipe(tap((items) => {
                if (items === undefined) {
                    this.loadNavigationEntryItems(navigation, true);
                    return;
                }
                // we should check whether the existing node items are what expected
                const expectedItems = [];
                this.loadNavigationEntryItems(navigation, false, expectedItems);
                const existingItems = Object.keys(items).map((key) => items[key].uid ?? '');
                const missingItems = expectedItems.filter((it) => it.id && !existingItems.includes(it.id));
                if (missingItems.length > 0) {
                    this.cmsService.loadNavigationItems(navigation.uid ?? '', missingItems);
                }
            }), filter(Boolean), map((items) => this.populateNavigationNode(navigation, items) ?? {}));
        }));
    }
    /**
     * Loads all navigation entry items' type and id. Dispatch action to load all these items
     * @param nodeData
     * @param root
     * @param itemsList
     */
    loadNavigationEntryItems(nodeData, root, itemsList = []) {
        if (nodeData.entries && nodeData.entries.length > 0) {
            nodeData.entries.forEach((entry) => {
                itemsList.push({
                    superType: entry.itemSuperType,
                    id: entry.itemId,
                });
            });
        }
        if (nodeData.children && nodeData.children.length > 0) {
            nodeData.children.forEach((child) => this.loadNavigationEntryItems(child, false, itemsList));
        }
        if (root && nodeData.uid) {
            this.cmsService.loadNavigationItems(nodeData.uid, itemsList);
        }
    }
    /**
     * Create a new node tree for the view
     * @param nodeData
     * @param items
     */
    populateNavigationNode(nodeData, items) {
        const node = {};
        if (nodeData.title) {
            // the node title will be populated by the first entry (if any)
            // if there's no nodeData.title available
            node.title = nodeData.title;
        }
        // populate style classes to apply CMS driven styling
        if (nodeData.styleClasses) {
            node.styleClasses = nodeData.styleClasses;
        }
        // populate style attributes to apply CMS driven styling
        if (nodeData.styleAttributes) {
            node.styleAttributes = nodeData.styleAttributes;
        }
        if (nodeData.entries && nodeData.entries.length > 0) {
            this.populateLink(node, nodeData.entries[0], items);
        }
        if (nodeData.children?.length > 0) {
            const children = nodeData.children
                .map((child) => this.populateNavigationNode(child, items))
                .filter(Boolean);
            if (children.length > 0) {
                node.children = children;
            }
        }
        // return null in case there are no children
        return Object.keys(node).length === 0 ? null : node;
    }
    /**
     * The node link is driven by the first entry.
     */
    populateLink(node, entry, items) {
        const item = items[`${entry.itemId}_${entry.itemSuperType}`];
        // now we only consider CMSLinkComponent
        if (item && entry.itemType === 'CMSLinkComponent') {
            if (!node.title) {
                node.title = item.linkName;
            }
            const url = this.getLink(item);
            // only populate the node link if we have a visible node
            if (node.title && url) {
                node.url = url;
                // the backend provide boolean value for the target
                // in case the link should be opened in a new window
                if (item.target === 'true' || item.target === true) {
                    node.target = '_blank';
                }
            }
            // populate style classes to apply CMS driven styling
            if (item.styleClasses) {
                node.styleClasses = item.styleClasses;
            }
            // populate style attributes to apply CMS driven styling
            if (item.styleAttributes) {
                node.styleAttributes = item.styleAttributes;
            }
        }
    }
    /**
     *
     * Gets the URL or link to a related item (category),
     * also taking into account content pages (contentPageLabelOrId)
     * and product pages (productCode)
     */
    getLink(item) {
        if (item.url) {
            return item.url;
        }
        else if (item.contentPageLabelOrId) {
            return item.contentPageLabelOrId;
        }
        else if (item.categoryCode) {
            return this.semanticPathService.transform({
                cxRoute: 'category',
                params: {
                    code: item.categoryCode,
                    name: item.name,
                },
            });
        }
        else if (item.productCode) {
            return this.semanticPathService.transform({
                cxRoute: 'product',
                params: {
                    code: item.productCode,
                    name: item.name,
                },
            });
        }
    }
}
NavigationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationService, deps: [{ token: i1.CmsService }, { token: i1.SemanticPathService }], target: i0.ɵɵFactoryTarget.Injectable });
NavigationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.CmsService }, { type: i1.SemanticPathService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NavigationUIComponent {
    onResize() {
        this.resize.next();
    }
    constructor(router, renderer, elemRef, hamburgerMenuService, winRef) {
        this.router = router;
        this.renderer = renderer;
        this.elemRef = elemRef;
        this.hamburgerMenuService = hamburgerMenuService;
        this.winRef = winRef;
        /**
         * the icon type that will be used for navigation nodes
         * with children.
         */
        this.iconType = ICON_TYPE;
        /**
         * Indicates whether the navigation should support flyout.
         * If flyout is set to true, the
         * nested child navigation nodes will only appear on hover or focus.
         */
        this.flyout = true;
        this.isOpen = false;
        this.openNodes = [];
        this.subscriptions = new Subscription();
        this.resize = new EventEmitter();
        this.subscriptions.add(this.router.events
            .pipe(filter((event) => event instanceof NavigationEnd))
            .subscribe(() => this.clear()));
        this.subscriptions.add(this.resize.pipe(debounceTime(50)).subscribe(() => {
            this.alignWrappersToRightIfStickOut();
        }));
    }
    /**
     * During initialization of this component, we will check the resetMenuOnClose flag and attach a menu reset listener if needed.
     */
    ngOnInit() {
        if (this.resetMenuOnClose) {
            this.resetOnMenuCollapse();
        }
    }
    /**
     * This method performs the action of resetting the menu (close all sub menus and return to main options)
     * when the menu is closed.
     */
    resetOnMenuCollapse() {
        this.subscriptions.add(this.hamburgerMenuService?.isExpanded
            .pipe(distinctUntilChanged(), filter(Boolean))
            .subscribe(() => {
            this.reinitializeMenu();
        }));
    }
    closeIfClickedTheSameLink(navNode) {
        if (typeof navNode.url === 'string' &&
            this.winRef.nativeWindow?.location.href.includes(navNode.url)) {
            this.elemRef.nativeElement
                .querySelectorAll('li.is-open:not(.back), li.is-opened')
                .forEach((el) => {
                this.renderer.removeClass(el, 'is-open');
                this.renderer.removeClass(el, 'is-opened');
            });
            this.reinitializeMenu();
            this.hamburgerMenuService.toggle();
        }
    }
    /**
     * This method performs the actions required to reset the state of the menu and reset any visual components.
     */
    reinitializeMenu() {
        if (this.openNodes?.length > 0) {
            this.clear();
            this.renderer.removeClass(this.elemRef.nativeElement, 'is-open');
        }
    }
    ariaCollapseNodes() {
        this.openNodes.forEach((parentNode) => {
            Array.from(parentNode.children)
                .filter((childNode) => childNode?.tagName === 'BUTTON')
                .forEach((childNode) => {
                this.renderer.setAttribute(childNode, 'aria-expanded', 'false');
            });
        });
    }
    toggleOpen(event) {
        if (event.type === 'keydown') {
            event.preventDefault();
        }
        this.ariaCollapseNodes();
        const node = event.currentTarget;
        const parentNode = node.parentNode;
        if (this.openNodes.includes(parentNode)) {
            if (event.type === 'keydown') {
                this.back();
            }
            else {
                this.openNodes = this.openNodes.filter((n) => n !== parentNode);
                this.renderer.removeClass(parentNode, 'is-open');
            }
        }
        else {
            this.openNodes.push(parentNode);
            this.renderer.setAttribute(node, 'aria-expanded', 'true');
        }
        this.updateClasses();
        event.stopImmediatePropagation();
        event.stopPropagation();
    }
    back() {
        if (this.openNodes[this.openNodes.length - 1]) {
            this.renderer.removeClass(this.openNodes[this.openNodes.length - 1], 'is-open');
            this.openNodes.pop();
            this.updateClasses();
        }
    }
    clear() {
        this.openNodes = [];
        this.updateClasses();
    }
    onMouseEnter(event) {
        this.alignWrapperToRightIfStickOut(event.currentTarget);
        this.focusAfterPreviousClicked(event);
    }
    getTotalDepth(node, depth = 0) {
        if (node.children && node.children.length > 0) {
            return Math.max(...node.children.map((n) => this.getTotalDepth(n, depth + 1)));
        }
        else {
            return depth;
        }
    }
    getColumnCount(length) {
        return Math.round(length / (this.wrapAfter || length));
    }
    focusAfterPreviousClicked(event) {
        const target = ((event.target || event.relatedTarget));
        if (target.ownerDocument.activeElement?.matches('nav[tabindex]') &&
            target.parentElement?.matches('.flyout')) {
            target.focus();
        }
        return target.ownerDocument;
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    alignWrapperToRightIfStickOut(node) {
        const wrapper = node.querySelector('.wrapper');
        const body = node.closest('body');
        if (wrapper) {
            this.renderer.removeStyle(wrapper, 'margin-left');
            if (wrapper.offsetLeft + wrapper.offsetWidth >
                body.offsetLeft + body.offsetWidth) {
                this.renderer.setStyle(wrapper, 'margin-left', `${node.offsetWidth - wrapper.offsetWidth}px`);
            }
        }
    }
    alignWrappersToRightIfStickOut() {
        const navs = this.elemRef.nativeElement.childNodes;
        Array.from(navs)
            .filter((node) => node.tagName === 'LI')
            .forEach((nav) => this.alignWrapperToRightIfStickOut(nav));
    }
    updateClasses() {
        this.openNodes.forEach((node, i) => {
            if (i + 1 < this.openNodes.length) {
                this.renderer.addClass(node, 'is-opened');
                this.renderer.removeClass(node, 'is-open');
            }
            else {
                this.renderer.removeClass(node, 'is-opened');
                this.renderer.addClass(node, 'is-open');
            }
        });
        this.isOpen = this.openNodes.length > 0;
    }
}
NavigationUIComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationUIComponent, deps: [{ token: i1$2.Router }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: HamburgerMenuService }, { token: i1.WindowRef }], target: i0.ɵɵFactoryTarget.Component });
NavigationUIComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: { node: "node", wrapAfter: "wrapAfter", resetMenuOnClose: "resetMenuOnClose", navAriaLabel: "navAriaLabel", flyout: "flyout", isOpen: "isOpen" }, host: { listeners: { "window:resize": "onResize()" }, properties: { "class.flyout": "this.flyout", "class.is-open": "this.isOpen" } }, ngImport: i0, template: "<nav [attr.aria-label]=\"navAriaLabel\">\n  <ul>\n    <li\n      *ngIf=\"flyout && (node?.children?.length ?? 0) > 1\"\n      class=\"back is-open\"\n    >\n      <button (click)=\"back()\">\n        <cx-icon [type]=\"iconType.CARET_LEFT\"></cx-icon>\n        {{ 'common.back' | cxTranslate }}\n      </button>\n    </li>\n\n    <ng-container *ngFor=\"let child of node?.children\">\n      <ng-container *ngTemplateOutlet=\"nav; context: { node: child, depth: 0 }\">\n      </ng-container>\n    </ng-container>\n  </ul>\n</nav>\n<!-- we generate links in a recursive manner -->\n\n<ng-template #nav let-node=\"node\" let-depth=\"depth\">\n  <li>\n    <cx-generic-link\n      *ngIf=\"\n        node.url && (!node.children || node.children?.length === 0);\n        else heading\n      \"\n      [url]=\"node.url\"\n      [target]=\"node.target\"\n      [style]=\"node.styleAttributes\"\n      [class]=\"node.styleClasses\"\n      (click)=\"closeIfClickedTheSameLink(node)\"\n    >\n      {{ node.title }}\n    </cx-generic-link>\n\n    <ng-template #heading>\n      <ng-container *ngIf=\"flyout && node.children?.length > 0; else title\">\n        <cx-generic-link\n          *ngIf=\"node.url\"\n          [url]=\"node.url\"\n          [target]=\"node.target\"\n          (click)=\"closeIfClickedTheSameLink(node)\"\n        >\n          {{ node.title }}\n        </cx-generic-link>\n        <button\n          [attr.tabindex]=\"depth < 1 ? 0 : -1\"\n          [attr.aria-haspopup]=\"true\"\n          [attr.aria-expanded]=\"false\"\n          [attr.aria-label]=\"node.title\"\n          (click)=\"toggleOpen($any($event))\"\n          (mouseenter)=\"onMouseEnter($event)\"\n          (keydown.space)=\"toggleOpen($any($event))\"\n          (keydown.esc)=\"back()\"\n        >\n          <ng-container *ngIf=\"!node.url\">\n            {{ node.title }}\n          </ng-container>\n          <cx-icon [type]=\"iconType.CARET_DOWN\"></cx-icon>\n        </button>\n      </ng-container>\n      <ng-template #title>\n        <span [attr.tabindex]=\"-1\">\n          {{ node.title }}\n        </span>\n      </ng-template>\n    </ng-template>\n\n    <!-- we add a wrapper to allow for better layout handling in CSS -->\n    <div class=\"wrapper\" *ngIf=\"node.children && node.children.length > 0\">\n      <ul\n        class=\"childs\"\n        [attr.depth]=\"getTotalDepth(node)\"\n        [attr.wrap-after]=\"node.children.length > wrapAfter ? wrapAfter : null\"\n        [attr.columns]=\"getColumnCount(node.children.length)\"\n      >\n        <ng-container *ngFor=\"let child of node.children\">\n          <ng-container\n            *ngTemplateOutlet=\"nav; context: { node: child, depth: depth + 1 }\"\n          >\n          </ng-container>\n        </ng-container>\n      </ul>\n    </div>\n  </li>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "component", type: GenericLinkComponent, selector: "cx-generic-link", inputs: ["url", "target", "id", "class", "style", "title"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationUIComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-navigation-ui', changeDetection: ChangeDetectionStrategy.OnPush, template: "<nav [attr.aria-label]=\"navAriaLabel\">\n  <ul>\n    <li\n      *ngIf=\"flyout && (node?.children?.length ?? 0) > 1\"\n      class=\"back is-open\"\n    >\n      <button (click)=\"back()\">\n        <cx-icon [type]=\"iconType.CARET_LEFT\"></cx-icon>\n        {{ 'common.back' | cxTranslate }}\n      </button>\n    </li>\n\n    <ng-container *ngFor=\"let child of node?.children\">\n      <ng-container *ngTemplateOutlet=\"nav; context: { node: child, depth: 0 }\">\n      </ng-container>\n    </ng-container>\n  </ul>\n</nav>\n<!-- we generate links in a recursive manner -->\n\n<ng-template #nav let-node=\"node\" let-depth=\"depth\">\n  <li>\n    <cx-generic-link\n      *ngIf=\"\n        node.url && (!node.children || node.children?.length === 0);\n        else heading\n      \"\n      [url]=\"node.url\"\n      [target]=\"node.target\"\n      [style]=\"node.styleAttributes\"\n      [class]=\"node.styleClasses\"\n      (click)=\"closeIfClickedTheSameLink(node)\"\n    >\n      {{ node.title }}\n    </cx-generic-link>\n\n    <ng-template #heading>\n      <ng-container *ngIf=\"flyout && node.children?.length > 0; else title\">\n        <cx-generic-link\n          *ngIf=\"node.url\"\n          [url]=\"node.url\"\n          [target]=\"node.target\"\n          (click)=\"closeIfClickedTheSameLink(node)\"\n        >\n          {{ node.title }}\n        </cx-generic-link>\n        <button\n          [attr.tabindex]=\"depth < 1 ? 0 : -1\"\n          [attr.aria-haspopup]=\"true\"\n          [attr.aria-expanded]=\"false\"\n          [attr.aria-label]=\"node.title\"\n          (click)=\"toggleOpen($any($event))\"\n          (mouseenter)=\"onMouseEnter($event)\"\n          (keydown.space)=\"toggleOpen($any($event))\"\n          (keydown.esc)=\"back()\"\n        >\n          <ng-container *ngIf=\"!node.url\">\n            {{ node.title }}\n          </ng-container>\n          <cx-icon [type]=\"iconType.CARET_DOWN\"></cx-icon>\n        </button>\n      </ng-container>\n      <ng-template #title>\n        <span [attr.tabindex]=\"-1\">\n          {{ node.title }}\n        </span>\n      </ng-template>\n    </ng-template>\n\n    <!-- we add a wrapper to allow for better layout handling in CSS -->\n    <div class=\"wrapper\" *ngIf=\"node.children && node.children.length > 0\">\n      <ul\n        class=\"childs\"\n        [attr.depth]=\"getTotalDepth(node)\"\n        [attr.wrap-after]=\"node.children.length > wrapAfter ? wrapAfter : null\"\n        [attr.columns]=\"getColumnCount(node.children.length)\"\n      >\n        <ng-container *ngFor=\"let child of node.children\">\n          <ng-container\n            *ngTemplateOutlet=\"nav; context: { node: child, depth: depth + 1 }\"\n          >\n          </ng-container>\n        </ng-container>\n      </ul>\n    </div>\n  </li>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1$2.Router }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: HamburgerMenuService }, { type: i1.WindowRef }]; }, propDecorators: { node: [{
                type: Input
            }], wrapAfter: [{
                type: Input
            }], resetMenuOnClose: [{
                type: Input
            }], navAriaLabel: [{
                type: Input
            }], flyout: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.flyout']
            }], isOpen: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.is-open']
            }], onResize: [{
                type: HostListener,
                args: ['window:resize']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CategoryNavigationComponent {
    constructor(componentData, service) {
        this.componentData = componentData;
        this.service = service;
        this.node$ = this.service.getNavigationNode(this.componentData.data$);
        this.data$ = this.componentData.data$;
    }
}
CategoryNavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CategoryNavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
CategoryNavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: CategoryNavigationComponent, selector: "cx-category-navigation", ngImport: i0, template: "<cx-navigation-ui\n  *ngIf=\"data$ | async as data\"\n  [node]=\"node$ | async\"\n  [ngClass]=\"data.styleClass ?? ''\"\n  [wrapAfter]=\"+(data.wrapAfter ?? '')\"\n  [resetMenuOnClose]=\"data.resetMenuOnClose\"\n  [navAriaLabel]=\"'navigation.categoryNavLabel' | cxTranslate\"\n></cx-navigation-ui>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "navAriaLabel", "flyout", "isOpen"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CategoryNavigationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-category-navigation', changeDetection: ChangeDetectionStrategy.OnPush, template: "<cx-navigation-ui\n  *ngIf=\"data$ | async as data\"\n  [node]=\"node$ | async\"\n  [ngClass]=\"data.styleClass ?? ''\"\n  [wrapAfter]=\"+(data.wrapAfter ?? '')\"\n  [resetMenuOnClose]=\"data.resetMenuOnClose\"\n  [navAriaLabel]=\"'navigation.categoryNavLabel' | cxTranslate\"\n></cx-navigation-ui>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NavigationComponent {
    constructor(componentData, service) {
        this.componentData = componentData;
        this.service = service;
        this.node$ = this.service.createNavigation(this.componentData.data$);
        this.name$ = this.componentData.data$.pipe(map((d) => d?.navigationNode?.title));
        this.styleClass$ = this.componentData.data$.pipe(map((d) => d?.styleClass));
    }
}
NavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
NavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: NavigationComponent, selector: "cx-navigation", ngImport: i0, template: "<cx-navigation-ui\n  [node]=\"node$ | async\"\n  [ngClass]=\"(styleClass$ | async) ?? ''\"\n  [navAriaLabel]=\"name$ | async\"\n>\n</cx-navigation-ui>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "navAriaLabel", "flyout", "isOpen"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-navigation', changeDetection: ChangeDetectionStrategy.OnPush, template: "<cx-navigation-ui\n  [node]=\"node$ | async\"\n  [ngClass]=\"(styleClass$ | async) ?? ''\"\n  [navAriaLabel]=\"name$ | async\"\n>\n</cx-navigation-ui>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NavigationModule {
}
NavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: NavigationModule, declarations: [NavigationComponent, NavigationUIComponent], imports: [CommonModule,
        RouterModule,
        IconModule,
        GenericLinkModule,
        I18nModule], exports: [NavigationComponent, NavigationUIComponent] });
NavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                NavigationComponent: {
                    component: NavigationComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        RouterModule,
        IconModule,
        GenericLinkModule,
        I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        IconModule,
                        GenericLinkModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                NavigationComponent: {
                                    component: NavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [NavigationComponent, NavigationUIComponent],
                    exports: [NavigationComponent, NavigationUIComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class CategoryNavigationModule {
}
CategoryNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CategoryNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CategoryNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: CategoryNavigationModule, declarations: [CategoryNavigationComponent], imports: [CommonModule, NavigationModule, I18nModule], exports: [CategoryNavigationComponent] });
CategoryNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CategoryNavigationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                CategoryNavigationComponent: {
                    component: CategoryNavigationComponent,
                    data: {
                        resetMenuOnClose: true,
                    },
                },
            },
        }),
    ], imports: [CommonModule, NavigationModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: CategoryNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NavigationModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                CategoryNavigationComponent: {
                                    component: CategoryNavigationComponent,
                                    data: {
                                        resetMenuOnClose: true,
                                    },
                                },
                            },
                        }),
                    ],
                    declarations: [CategoryNavigationComponent],
                    exports: [CategoryNavigationComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FooterNavigationComponent {
    constructor(componentData, service) {
        this.componentData = componentData;
        this.service = service;
        this.node$ = this.service.getNavigationNode(this.componentData.data$);
        this.styleClass$ = this.componentData.data$.pipe(map((d) => d?.styleClass));
    }
}
FooterNavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FooterNavigationComponent, deps: [{ token: CmsComponentData }, { token: NavigationService }], target: i0.ɵɵFactoryTarget.Component });
FooterNavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: FooterNavigationComponent, selector: "cx-footer-navigation", ngImport: i0, template: "<cx-navigation-ui\n  *ngIf=\"node$ | async as node\"\n  [node]=\"node\"\n  [flyout]=\"false\"\n  [ngClass]=\"(styleClass$ | async) ?? ''\"\n  [navAriaLabel]=\"'navigation.footerNavLabel' | cxTranslate\"\n></cx-navigation-ui>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: NavigationUIComponent, selector: "cx-navigation-ui", inputs: ["node", "wrapAfter", "resetMenuOnClose", "navAriaLabel", "flyout", "isOpen"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FooterNavigationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-footer-navigation', changeDetection: ChangeDetectionStrategy.OnPush, template: "<cx-navigation-ui\n  *ngIf=\"node$ | async as node\"\n  [node]=\"node\"\n  [flyout]=\"false\"\n  [ngClass]=\"(styleClass$ | async) ?? ''\"\n  [navAriaLabel]=\"'navigation.footerNavLabel' | cxTranslate\"\n></cx-navigation-ui>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: NavigationService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FooterNavigationModule {
}
FooterNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FooterNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FooterNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: FooterNavigationModule, declarations: [FooterNavigationComponent], imports: [CommonModule,
        RouterModule,
        NavigationModule,
        GenericLinkModule,
        I18nModule], exports: [FooterNavigationComponent] });
FooterNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FooterNavigationModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                FooterNavigationComponent: {
                    component: FooterNavigationComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        RouterModule,
        NavigationModule,
        GenericLinkModule,
        I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FooterNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        NavigationModule,
                        GenericLinkModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                FooterNavigationComponent: {
                                    component: FooterNavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [FooterNavigationComponent],
                    exports: [FooterNavigationComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class PageTitleModule {
}
PageTitleModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageTitleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PageTitleModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: PageTitleModule, declarations: [PageTitleComponent], imports: [CommonModule, RouterModule, PageMetaModule], exports: [PageTitleComponent] });
PageTitleModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageTitleModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                PageTitleComponent: {
                    component: PageTitleComponent,
                },
            },
        }),
    ], imports: [CommonModule, RouterModule, PageMetaModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: PageTitleModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RouterModule, PageMetaModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                PageTitleComponent: {
                                    component: PageTitleComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [PageTitleComponent],
                    exports: [PageTitleComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class HighlightPipe {
    transform(text, match) {
        if (!match) {
            return text;
        }
        return text.replace(match.trim(), `<span class="highlight">${match.trim()}</span>`);
    }
}
HighlightPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HighlightPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
HighlightPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: HighlightPipe, name: "cxHighlight" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HighlightPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'cxHighlight' }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Indicates that the user chose a suggestion
 */
class SearchBoxSuggestionSelectedEvent extends CxEvent {
}
/**
 * Event's type
 */
SearchBoxSuggestionSelectedEvent.type = 'SearchBoxSuggestionSelectedEvent';
/**
 * Indicates that the user chose a product suggestion
 */
class SearchBoxProductSelectedEvent extends CxEvent {
}
/**
 * Event's type
 */
SearchBoxProductSelectedEvent.type = 'SearchBoxProductSelectedEvent';

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const HAS_SEARCH_RESULT_CLASS = 'has-searchbox-results';
class SearchBoxComponentService {
    constructor(searchService, routingService, translationService, winRef, eventService) {
        this.searchService = searchService;
        this.routingService = routingService;
        this.translationService = translationService;
        this.winRef = winRef;
        this.eventService = eventService;
    }
    /**
     * Executes the search for products and suggestions,
     * unless the configuration is setup to not search for
     * products or suggestions.
     */
    search(query, config) {
        if (!query || query === '') {
            this.clearResults();
            return;
        }
        if (config.minCharactersBeforeRequest &&
            query.length < config.minCharactersBeforeRequest) {
            return;
        }
        if (config.displayProducts) {
            this.searchService.search(query, {
                pageSize: config.maxProducts,
            });
        }
        if (config.displaySuggestions) {
            this.searchService.searchSuggestions(query, {
                pageSize: config.maxSuggestions,
            });
        }
    }
    /**
     * Returns an observable with the SearchResults. When there's any
     * result, the body tag will get a classname, so that specific style
     * rules can be applied.
     */
    getResults(config) {
        return combineLatest([
            this.getProductResults(config),
            this.getProductSuggestions(config),
            this.getSearchMessage(config),
        ]).pipe(map(([productResults, suggestions, message]) => {
            return {
                products: productResults ? productResults.products : undefined,
                suggestions,
                message,
            };
        }), tap((results) => this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, this.hasResults(results))));
    }
    /**
     * Clears the searchbox results, so that old values are
     * no longer emited upon next search.
     */
    clearResults() {
        this.searchService.clearResults();
        this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, false);
    }
    hasBodyClass(className) {
        return this.winRef.document.body.classList.contains(className);
    }
    toggleBodyClass(className, add) {
        if (add === undefined) {
            this.winRef.document.body.classList.toggle(className);
        }
        else {
            add
                ? this.winRef.document.body.classList.add(className)
                : this.winRef.document.body.classList.remove(className);
        }
    }
    /**
     * Dispatches a searchbox event for product selected
     *
     * @param eventData data for the "SearchBoxProductSelectedEvent"
     */
    dispatchProductSelectedEvent(eventData) {
        this.eventService.dispatch({
            freeText: eventData.freeText,
            productCode: eventData.productCode,
        }, SearchBoxProductSelectedEvent);
    }
    /**
     * Dispatches a searchbox event for suggestion selected
     *
     * @param eventData data for the "SearchBoxSuggestionSelectedEvent"
     */
    dispatchSuggestionSelectedEvent(eventData) {
        this.eventService.dispatch({
            freeText: eventData.freeText,
            selectedSuggestion: eventData.selectedSuggestion,
            searchSuggestions: eventData.searchSuggestions,
        }, SearchBoxSuggestionSelectedEvent);
    }
    /**
     * For search results model, it returns true when:
     * * there is any product OR
     * * the is any search suggestion OR
     * * there is a message.
     *
     * Otherwise it returns false.
     */
    hasResults(results) {
        return ((!!results.products && results.products.length > 0) ||
            (!!results.suggestions && results.suggestions.length > 0) ||
            !!results.message);
    }
    /**
     * Emits product search results in case when the config property `displayProducts` is true.
     * Otherwise it emits an empty object.
     */
    getProductResults(config) {
        if (config.displayProducts) {
            return this.searchService.getResults();
        }
        else {
            return of({});
        }
    }
    /**
     * Loads suggestions from the backend. In case there's no suggestion
     * available, we try to get an exact match suggestion.
     */
    getProductSuggestions(config) {
        if (!config.displaySuggestions) {
            return of([]);
        }
        else {
            return this.searchService.getSuggestionResults().pipe(map((res) => res.map((suggestion) => suggestion.value).filter(isNotUndefined)), switchMap((suggestions) => {
                if (suggestions.length === 0) {
                    return this.getExactSuggestion(config).pipe(map((match) => (match ? [match] : [])));
                }
                else {
                    return of(suggestions);
                }
            }));
        }
    }
    /**
     * Whenever there is at least 1 product, we simulate
     * a suggestion to provide easy access to the search result page
     */
    getExactSuggestion(config) {
        return this.getProductResults(config).pipe(switchMap((productResult) => {
            return productResult.products && productResult.products.length > 0
                ? this.fetchTranslation('searchBox.help.exactMatch', {
                    term: productResult.freeTextSearch,
                })
                : of(undefined);
        }));
    }
    /**
     * Emits a 'no match' message, in case the product search results and search suggestions are empty.
     * Otherwise it emits null.
     */
    getSearchMessage(config) {
        return combineLatest([
            this.getProductResults(config),
            this.getProductSuggestions(config),
        ]).pipe(switchMap(([productResult, suggestions]) => {
            if (productResult &&
                productResult.products &&
                productResult.products.length === 0 &&
                suggestions &&
                suggestions.length === 0) {
                return this.fetchTranslation('searchBox.help.noMatch');
            }
            else {
                return of(undefined);
            }
        }));
    }
    /**
     * Navigates to the search result page with a given query
     */
    launchSearchPage(query) {
        this.routingService.go({
            cxRoute: 'search',
            params: { query },
        });
    }
    fetchTranslation(translationKey, options) {
        return this.translationService.translate(translationKey, options);
    }
}
SearchBoxComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxComponentService, deps: [{ token: i1.SearchboxService }, { token: i1.RoutingService }, { token: i1.TranslationService }, { token: i1.WindowRef }, { token: i1.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
SearchBoxComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.SearchboxService }, { type: i1.RoutingService }, { type: i1.TranslationService }, { type: i1.WindowRef }, { type: i1.EventService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const DEFAULT_SEARCH_BOX_CONFIG = {
    minCharactersBeforeRequest: 1,
    displayProducts: true,
    displaySuggestions: true,
    maxProducts: 5,
    maxSuggestions: 5,
    displayProductImages: true,
};
const SEARCHBOX_IS_ACTIVE = 'searchbox-is-active';
class SearchBoxComponent {
    /**
     * Sets the search box input field
     */
    set queryText(value) {
        if (value) {
            this.search(value);
        }
    }
    constructor(searchBoxComponentService, componentData, winRef, routingService) {
        this.searchBoxComponentService = searchBoxComponentService;
        this.componentData = componentData;
        this.winRef = winRef;
        this.routingService = routingService;
        this.iconTypes = ICON_TYPE;
        /**
         * In some occasions we need to ignore the close event,
         * for example when we click inside the search result section.
         */
        this.ignoreCloseEvent = false;
        this.chosenWord = '';
        /**
         * Returns the SearchBox configuration. The configuration is driven by multiple
         * layers: default configuration, (optional) backend configuration and (optional)
         * input configuration.
         */
        this.config$ = (this.componentData?.data$ || of({})).pipe(map((config) => {
            const isBool = (obj, prop) => obj[prop] !== 'false' &&
                obj[prop] !== false;
            return {
                ...DEFAULT_SEARCH_BOX_CONFIG,
                ...config,
                displayProducts: isBool(config, 'displayProducts'),
                displayProductImages: isBool(config, 'displayProductImages'),
                displaySuggestions: isBool(config, 'displaySuggestions'),
                // we're merging the (optional) input of this component, but write the merged
                // result back to the input property, as the view logic depends on it.
                ...this.config,
            };
        }), tap((config) => (this.config = config)));
        this.results$ = this.config$.pipe(switchMap((config) => this.searchBoxComponentService.getResults(config)));
    }
    ngOnInit() {
        this.subscription = this.routingService
            .getRouterState()
            .pipe(filter((data) => !data.nextState))
            .subscribe((data) => {
            if (!(data.state.context?.id === 'search' &&
                data.state.context?.type === PageType.CONTENT_PAGE)) {
                this.chosenWord = '';
            }
        });
    }
    /**
     * Closes the searchBox and opens the search result page.
     */
    search(query) {
        this.searchBoxComponentService.search(query, this.config);
        // force the searchBox to open
        this.open();
    }
    /**
     * Opens the type-ahead searchBox
     */
    open() {
        this.searchBoxComponentService.toggleBodyClass(SEARCHBOX_IS_ACTIVE, true);
    }
    /**
     * Dispatch UI events for Suggestion selected
     *
     * @param eventData the data for the event
     */
    dispatchSuggestionEvent(eventData) {
        this.searchBoxComponentService.dispatchSuggestionSelectedEvent(eventData);
    }
    /**
     * Dispatch UI events for Product selected
     *
     * @param eventData the data for the event
     */
    dispatchProductEvent(eventData) {
        this.searchBoxComponentService.dispatchProductSelectedEvent(eventData);
    }
    /**
     * Closes the type-ahead searchBox.
     */
    close(event, force) {
        // Use timeout to detect changes
        setTimeout(() => {
            if ((!this.ignoreCloseEvent && !this.isSearchBoxFocused()) || force) {
                this.blurSearchBox(event);
            }
        });
    }
    blurSearchBox(event) {
        this.searchBoxComponentService.toggleBodyClass(SEARCHBOX_IS_ACTIVE, false);
        if (event && event.target) {
            event.target.blur();
        }
    }
    // Check if focus is on searchbox or result list elements
    isSearchBoxFocused() {
        return (this.getResultElements().includes(this.getFocusedElement()) ||
            this.winRef.document.querySelector('input[aria-label="Search"]') ===
                this.getFocusedElement());
    }
    /**
     * Especially in mobile we do not want the search icon
     * to focus the input again when it's already open.
     * */
    avoidReopen(event) {
        if (this.searchBoxComponentService.hasBodyClass(SEARCHBOX_IS_ACTIVE)) {
            this.close(event);
            event.preventDefault();
        }
    }
    // Return result list as HTMLElement array
    getResultElements() {
        return Array.from(this.winRef.document.querySelectorAll('.products > li a, .suggestions > li a'));
    }
    // Return focused element as HTMLElement
    getFocusedElement() {
        return this.winRef.document.activeElement;
    }
    updateChosenWord(chosenWord) {
        this.chosenWord = chosenWord;
    }
    getFocusedIndex() {
        return this.getResultElements().indexOf(this.getFocusedElement());
    }
    // Focus on previous item in results list
    focusPreviousChild(event) {
        event.preventDefault(); // Negate normal keyscroll
        const [results, focusedIndex] = [
            this.getResultElements(),
            this.getFocusedIndex(),
        ];
        // Focus on last index moving to first
        if (results.length) {
            if (focusedIndex < 1) {
                results[results.length - 1].focus();
            }
            else {
                results[focusedIndex - 1].focus();
            }
        }
    }
    // Focus on next item in results list
    focusNextChild(event) {
        this.open();
        event.preventDefault(); // Negate normal keyscroll
        const [results, focusedIndex] = [
            this.getResultElements(),
            this.getFocusedIndex(),
        ];
        // Focus on first index moving to last
        if (results.length) {
            if (focusedIndex >= results.length - 1) {
                results[0].focus();
            }
            else {
                results[focusedIndex + 1].focus();
            }
        }
    }
    /**
     * Opens the PLP with the given query.
     *
     * TODO: if there's a single product match, we could open the PDP.
     */
    launchSearchResult(event, query) {
        if (!query || query.trim().length === 0) {
            return;
        }
        this.close(event);
        this.searchBoxComponentService.launchSearchPage(query);
    }
    /**
     * Disables closing the search result list.
     */
    disableClose() {
        this.ignoreCloseEvent = true;
    }
    preventDefault(ev) {
        ev.preventDefault();
    }
    /**
     * Clears the search box input field
     */
    clear(el) {
        this.disableClose();
        el.value = '';
        this.searchBoxComponentService.clearResults();
        // Use Timeout to run after blur event to prevent the searchbox from closing on mobile
        setTimeout(() => {
            // Retain focus on input lost by clicking on icon
            el.focus();
            this.ignoreCloseEvent = false;
        });
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
    }
}
SearchBoxComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxComponent, deps: [{ token: SearchBoxComponentService }, { token: CmsComponentData, optional: true }, { token: i1.WindowRef }, { token: i1.RoutingService }], target: i0.ɵɵFactoryTarget.Component });
SearchBoxComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: SearchBoxComponent, selector: "cx-searchbox", inputs: { config: "config", queryText: "queryText" }, ngImport: i0, template: "<div [attr.aria-label]=\"'searchBox.productSearch' | cxTranslate\" role=\"search\">\n  <label class=\"searchbox\" [class.dirty]=\"!!searchInput.value\">\n    <input\n      #searchInput\n      [placeholder]=\"'searchBox.placeholder' | cxTranslate\"\n      autocomplete=\"off\"\n      aria-describedby=\"initialDescription\"\n      aria-controls=\"results\"\n      [attr.aria-label]=\"'searchBox.placeholder' | cxTranslate\"\n      (focus)=\"open()\"\n      (click)=\"open()\"\n      (input)=\"search(searchInput.value)\"\n      (blur)=\"close($any($event))\"\n      (keydown.escape)=\"close($any($event))\"\n      (keydown.enter)=\"\n        close($any($event), true);\n        launchSearchResult($any($event), searchInput.value);\n        updateChosenWord(searchInput.value)\n      \"\n      (keydown.arrowup)=\"focusPreviousChild($any($event))\"\n      (keydown.arrowdown)=\"focusNextChild($any($event))\"\n      value=\"{{ chosenWord }}\"\n    />\n\n    <button\n      [attr.aria-label]=\"'common.reset' | cxTranslate\"\n      (mousedown)=\"clear(searchInput)\"\n      (keydown.enter)=\"clear(searchInput)\"\n      class=\"reset\"\n    >\n      <cx-icon [type]=\"iconTypes.RESET\"></cx-icon>\n    </button>\n\n    <div role=\"presentation\" class=\"search-icon\">\n      <cx-icon [type]=\"iconTypes.SEARCH\"></cx-icon>\n    </div>\n\n    <button\n      [attr.aria-label]=\"'common.search' | cxTranslate\"\n      class=\"search\"\n      (click)=\"open()\"\n    >\n      <cx-icon [type]=\"iconTypes.SEARCH\"></cx-icon>\n    </button>\n  </label>\n</div>\n\n<div\n  *ngIf=\"results$ | async as result\"\n  class=\"results\"\n  id=\"results\"\n  (click)=\"close($any($event), true)\"\n  role=\"dialog\"\n>\n  <div\n    *ngIf=\"result.message\"\n    class=\"message\"\n    [innerHTML]=\"result.message\"\n  ></div>\n\n  <ul\n    class=\"suggestions\"\n    attr.aria-label=\"{{ 'searchBox.ariaLabelSuggestions' | cxTranslate }}\"\n    role=\"listbox\"\n  >\n    <li *ngFor=\"let suggestion of result.suggestions\">\n      <a\n        role=\"option\"\n        [innerHTML]=\"suggestion | cxHighlight: searchInput.value\"\n        [routerLink]=\"\n          {\n            cxRoute: 'search',\n            params: { query: suggestion }\n          } | cxUrl\n        \"\n        (keydown.arrowup)=\"focusPreviousChild($any($event))\"\n        (keydown.arrowdown)=\"focusNextChild($any($event))\"\n        (keydown.enter)=\"close($any($event), true)\"\n        (keydown.escape)=\"close($any($event), true)\"\n        (blur)=\"close($event)\"\n        (mousedown)=\"preventDefault($event)\"\n        (click)=\"\n          dispatchSuggestionEvent({\n            freeText: searchInput.value,\n            selectedSuggestion: suggestion,\n            searchSuggestions: result.suggestions ?? []\n          });\n          updateChosenWord(suggestion)\n        \"\n      >\n      </a>\n    </li>\n  </ul>\n\n  <ul\n    class=\"products\"\n    *ngIf=\"result.products\"\n    attr.aria-label=\"{{ 'searchBox.ariaLabelProducts' | cxTranslate }}\"\n    role=\"listbox\"\n  >\n    <li *ngFor=\"let product of result.products\">\n      <a\n        role=\"option\"\n        [routerLink]=\"\n          {\n            cxRoute: 'product',\n            params: product\n          } | cxUrl\n        \"\n        [class.has-media]=\"config.displayProductImages\"\n        (keydown.arrowup)=\"focusPreviousChild($any($event))\"\n        (keydown.arrowdown)=\"focusNextChild($any($event))\"\n        (keydown.enter)=\"close($any($event), true)\"\n        (keydown.escape)=\"close($any($event), true)\"\n        (blur)=\"close($any($event))\"\n        (mousedown)=\"preventDefault($event)\"\n        (click)=\"\n          dispatchProductEvent({\n            freeText: searchInput.value,\n            productCode: product.code\n          })\n        \"\n      >\n        <cx-media\n          *ngIf=\"config.displayProductImages\"\n          [container]=\"product.images?.PRIMARY\"\n          format=\"thumbnail\"\n          role=\"presentation\"\n        ></cx-media>\n        <div class=\"name\" [innerHTML]=\"product.nameHtml\"></div>\n        <span class=\"price\">{{ product.price?.formattedValue }}</span>\n      </a>\n    </li>\n  </ul>\n  <span id=\"initialDescription\" class=\"cx-visually-hidden\">\n    {{ 'searchBox.initialDescription' | cxTranslate }}\n  </span>\n  <div\n    *ngIf=\"result.suggestions?.length || result.products?.length\"\n    aria-live=\"assertive\"\n    class=\"cx-visually-hidden\"\n  >\n    {{\n      'searchBox.suggestionsResult'\n        | cxTranslate: { count: result.suggestions?.length }\n    }}\n    {{\n      'searchBox.productsResult'\n        | cxTranslate: { count: result.products?.length }\n    }}\n    {{ 'searchBox.initialDescription' | cxTranslate }}\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.UrlPipe, name: "cxUrl" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: HighlightPipe, name: "cxHighlight" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-searchbox', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div [attr.aria-label]=\"'searchBox.productSearch' | cxTranslate\" role=\"search\">\n  <label class=\"searchbox\" [class.dirty]=\"!!searchInput.value\">\n    <input\n      #searchInput\n      [placeholder]=\"'searchBox.placeholder' | cxTranslate\"\n      autocomplete=\"off\"\n      aria-describedby=\"initialDescription\"\n      aria-controls=\"results\"\n      [attr.aria-label]=\"'searchBox.placeholder' | cxTranslate\"\n      (focus)=\"open()\"\n      (click)=\"open()\"\n      (input)=\"search(searchInput.value)\"\n      (blur)=\"close($any($event))\"\n      (keydown.escape)=\"close($any($event))\"\n      (keydown.enter)=\"\n        close($any($event), true);\n        launchSearchResult($any($event), searchInput.value);\n        updateChosenWord(searchInput.value)\n      \"\n      (keydown.arrowup)=\"focusPreviousChild($any($event))\"\n      (keydown.arrowdown)=\"focusNextChild($any($event))\"\n      value=\"{{ chosenWord }}\"\n    />\n\n    <button\n      [attr.aria-label]=\"'common.reset' | cxTranslate\"\n      (mousedown)=\"clear(searchInput)\"\n      (keydown.enter)=\"clear(searchInput)\"\n      class=\"reset\"\n    >\n      <cx-icon [type]=\"iconTypes.RESET\"></cx-icon>\n    </button>\n\n    <div role=\"presentation\" class=\"search-icon\">\n      <cx-icon [type]=\"iconTypes.SEARCH\"></cx-icon>\n    </div>\n\n    <button\n      [attr.aria-label]=\"'common.search' | cxTranslate\"\n      class=\"search\"\n      (click)=\"open()\"\n    >\n      <cx-icon [type]=\"iconTypes.SEARCH\"></cx-icon>\n    </button>\n  </label>\n</div>\n\n<div\n  *ngIf=\"results$ | async as result\"\n  class=\"results\"\n  id=\"results\"\n  (click)=\"close($any($event), true)\"\n  role=\"dialog\"\n>\n  <div\n    *ngIf=\"result.message\"\n    class=\"message\"\n    [innerHTML]=\"result.message\"\n  ></div>\n\n  <ul\n    class=\"suggestions\"\n    attr.aria-label=\"{{ 'searchBox.ariaLabelSuggestions' | cxTranslate }}\"\n    role=\"listbox\"\n  >\n    <li *ngFor=\"let suggestion of result.suggestions\">\n      <a\n        role=\"option\"\n        [innerHTML]=\"suggestion | cxHighlight: searchInput.value\"\n        [routerLink]=\"\n          {\n            cxRoute: 'search',\n            params: { query: suggestion }\n          } | cxUrl\n        \"\n        (keydown.arrowup)=\"focusPreviousChild($any($event))\"\n        (keydown.arrowdown)=\"focusNextChild($any($event))\"\n        (keydown.enter)=\"close($any($event), true)\"\n        (keydown.escape)=\"close($any($event), true)\"\n        (blur)=\"close($event)\"\n        (mousedown)=\"preventDefault($event)\"\n        (click)=\"\n          dispatchSuggestionEvent({\n            freeText: searchInput.value,\n            selectedSuggestion: suggestion,\n            searchSuggestions: result.suggestions ?? []\n          });\n          updateChosenWord(suggestion)\n        \"\n      >\n      </a>\n    </li>\n  </ul>\n\n  <ul\n    class=\"products\"\n    *ngIf=\"result.products\"\n    attr.aria-label=\"{{ 'searchBox.ariaLabelProducts' | cxTranslate }}\"\n    role=\"listbox\"\n  >\n    <li *ngFor=\"let product of result.products\">\n      <a\n        role=\"option\"\n        [routerLink]=\"\n          {\n            cxRoute: 'product',\n            params: product\n          } | cxUrl\n        \"\n        [class.has-media]=\"config.displayProductImages\"\n        (keydown.arrowup)=\"focusPreviousChild($any($event))\"\n        (keydown.arrowdown)=\"focusNextChild($any($event))\"\n        (keydown.enter)=\"close($any($event), true)\"\n        (keydown.escape)=\"close($any($event), true)\"\n        (blur)=\"close($any($event))\"\n        (mousedown)=\"preventDefault($event)\"\n        (click)=\"\n          dispatchProductEvent({\n            freeText: searchInput.value,\n            productCode: product.code\n          })\n        \"\n      >\n        <cx-media\n          *ngIf=\"config.displayProductImages\"\n          [container]=\"product.images?.PRIMARY\"\n          format=\"thumbnail\"\n          role=\"presentation\"\n        ></cx-media>\n        <div class=\"name\" [innerHTML]=\"product.nameHtml\"></div>\n        <span class=\"price\">{{ product.price?.formattedValue }}</span>\n      </a>\n    </li>\n  </ul>\n  <span id=\"initialDescription\" class=\"cx-visually-hidden\">\n    {{ 'searchBox.initialDescription' | cxTranslate }}\n  </span>\n  <div\n    *ngIf=\"result.suggestions?.length || result.products?.length\"\n    aria-live=\"assertive\"\n    class=\"cx-visually-hidden\"\n  >\n    {{\n      'searchBox.suggestionsResult'\n        | cxTranslate: { count: result.suggestions?.length }\n    }}\n    {{\n      'searchBox.productsResult'\n        | cxTranslate: { count: result.products?.length }\n    }}\n    {{ 'searchBox.initialDescription' | cxTranslate }}\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: SearchBoxComponentService }, { type: CmsComponentData, decorators: [{
                    type: Optional
                }] }, { type: i1.WindowRef }, { type: i1.RoutingService }]; }, propDecorators: { config: [{
                type: Input
            }], queryText: [{
                type: Input,
                args: ['queryText']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class SearchBoxModule {
}
SearchBoxModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SearchBoxModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxModule, declarations: [SearchBoxComponent, HighlightPipe], imports: [CommonModule,
        RouterModule,
        MediaModule,
        IconModule,
        UrlModule,
        I18nModule], exports: [SearchBoxComponent, HighlightPipe] });
SearchBoxModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                SearchBoxComponent: {
                    component: SearchBoxComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        RouterModule,
        MediaModule,
        IconModule,
        UrlModule,
        I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: SearchBoxModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        MediaModule,
                        IconModule,
                        UrlModule,
                        I18nModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                SearchBoxComponent: {
                                    component: SearchBoxComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [SearchBoxComponent, HighlightPipe],
                    exports: [SearchBoxComponent, HighlightPipe],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ScrollToTopComponent {
    onScroll() {
        if (this.window) {
            this.display = this.window.scrollY > this.displayThreshold;
        }
    }
    constructor(winRef, componentData, selectFocusUtility) {
        this.winRef = winRef;
        this.componentData = componentData;
        this.selectFocusUtility = selectFocusUtility;
        this.iconTypes = ICON_TYPE;
        this.window = this.winRef.nativeWindow;
        this.scrollBehavior = ScrollBehavior.SMOOTH;
        this.displayThreshold = (this.window?.innerHeight ?? 400) / 2;
    }
    ngOnInit() {
        this.setConfig();
    }
    setConfig() {
        this.componentData.data$.pipe(take(1)).subscribe((data) => {
            this.scrollBehavior = data.scrollBehavior ?? this.scrollBehavior;
            this.displayThreshold = data.displayThreshold ?? this.displayThreshold;
        });
    }
    /**
     * Scroll back to the top of the page and set focus on top most focusable element.
     */
    scrollToTop() {
        // Focus first focusable element within the html body
        this.selectFocusUtility
            .findFirstFocusable(this.winRef.document.body, { autofocus: '' })
            ?.focus();
        this.window?.scrollTo({
            top: 0,
            behavior: this.scrollBehavior,
        });
    }
}
ScrollToTopComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ScrollToTopComponent, deps: [{ token: i1.WindowRef }, { token: CmsComponentData }, { token: SelectFocusUtility }], target: i0.ɵɵFactoryTarget.Component });
ScrollToTopComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ScrollToTopComponent, selector: "cx-scroll-to-top", host: { listeners: { "window:scroll": "onScroll($event)" }, properties: { "class.display": "this.display" } }, ngImport: i0, template: "<button\n  [attr.aria-label]=\"'navigation.scrollToTop' | cxTranslate\"\n  class=\"cx-scroll-to-top-btn\"\n  (click)=\"scrollToTop()\"\n>\n  <span aria-hidden=\"true\">\n    <cx-icon class=\"caret-up-icon\" [type]=\"iconTypes.CARET_UP\"></cx-icon>\n  </span>\n</button>\n", dependencies: [{ kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ScrollToTopComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-scroll-to-top', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  [attr.aria-label]=\"'navigation.scrollToTop' | cxTranslate\"\n  class=\"cx-scroll-to-top-btn\"\n  (click)=\"scrollToTop()\"\n>\n  <span aria-hidden=\"true\">\n    <cx-icon class=\"caret-up-icon\" [type]=\"iconTypes.CARET_UP\"></cx-icon>\n  </span>\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: i1.WindowRef }, { type: CmsComponentData }, { type: SelectFocusUtility }]; }, propDecorators: { display: [{
                type: HostBinding,
                args: ['class.display']
            }], onScroll: [{
                type: HostListener,
                args: ['window:scroll', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ScrollToTopModule {
}
ScrollToTopModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ScrollToTopModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ScrollToTopModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ScrollToTopModule, declarations: [ScrollToTopComponent], imports: [CommonModule, IconModule, I18nModule], exports: [ScrollToTopComponent] });
ScrollToTopModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ScrollToTopModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ScrollToTopComponent: {
                    component: ScrollToTopComponent,
                },
            },
        }),
    ], imports: [CommonModule, IconModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ScrollToTopModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IconModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ScrollToTopComponent: {
                                    component: ScrollToTopComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ScrollToTopComponent],
                    exports: [ScrollToTopComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductCarouselService {
    constructor(productService, semanticPathService) {
        this.productService = productService;
        this.semanticPathService = semanticPathService;
    }
    /**
     * Loads the product data and converts it `CarouselItem`.
     */
    loadProduct(code) {
        return this.productService.get(code).pipe(filter(isNotUndefined), map((product) => this.convertProduct(product)));
    }
    /**
     * Converts the product to a generic CarouselItem
     */
    convertProduct(source, displayTitle = true, displayProductPrices = true) {
        const item = {};
        if (displayTitle) {
            item.title = source.name;
        }
        if (displayProductPrices && source.price && source.price.formattedValue) {
            item.price = source.price.formattedValue;
        }
        if (source.images && source.images.PRIMARY) {
            item.media = {
                container: source.images.PRIMARY,
                format: 'product',
            };
        }
        item.route = this.semanticPathService.transform({
            cxRoute: 'product',
            params: source,
        });
        return item;
    }
}
ProductCarouselService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselService, deps: [{ token: i1.ProductService }, { token: i1.SemanticPathService }], target: i0.ɵɵFactoryTarget.Injectable });
ProductCarouselService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ProductService }, { type: i1.SemanticPathService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The `ProductListComponentService` is used to search products. The service is used
 * on the Product Listing Page, for listing products and the facet navigation.
 *
 * The service exposes the product search results based on the category and search
 * route parameters. The route parameters are used to query products by the help of
 * the `ProductSearchService`.
 */
class ProductListComponentService {
    constructor(productSearchService, routing, activatedRoute, currencyService, languageService, router, config) {
        this.productSearchService = productSearchService;
        this.routing = routing;
        this.activatedRoute = activatedRoute;
        this.currencyService = currencyService;
        this.languageService = languageService;
        this.router = router;
        this.config = config;
        this.RELEVANCE_ALLCATEGORIES = ':relevance:allCategories:';
        /**
         * Emits the search results for the current search query.
         *
         * The `searchResults$` is _not_ concerned with querying, it only observes the
         * `productSearchService.getResults()`
         */
        this.searchResults$ = this.productSearchService
            .getResults()
            .pipe(filter((searchResult) => Object.keys(searchResult).length > 0));
        /**
         * Observes the route and performs a search on each route change.
         *
         * Context changes, such as language and currencies are also taken
         * into account, so that the search is performed again.
         */
        this.searchByRouting$ = combineLatest([
            this.routing.getRouterState().pipe(distinctUntilChanged((x, y) => {
                // router emits new value also when the anticipated `nextState` changes
                // but we want to perform search only when current url changes
                return x.state.url === y.state.url;
            })),
            ...this.siteContext,
        ]).pipe(debounceTime(0), map(([routerState, ..._context]) => routerState.state), tap((state) => {
            const criteria = this.getCriteriaFromRoute(state.params, state.queryParams);
            this.search(criteria);
        }));
        /**
         * This stream is used for the Product Listing and Product Facets.
         *
         * It not only emits search results, but also performs a search on every change
         * of the route (i.e. route params or query params).
         *
         * When a user leaves the PLP route, the PLP component unsubscribes from this stream
         * so no longer the search is performed on route change.
         */
        this.model$ = using(() => this.searchByRouting$.subscribe(), () => this.searchResults$).pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Expose the `SearchCriteria`. The search criteria are driven by the route parameters.
     *
     * This search route configuration is not yet configurable
     * (see https://github.com/SAP/spartacus/issues/7191).
     */
    getCriteriaFromRoute(routeParams, queryParams) {
        return {
            query: queryParams.query || this.getQueryFromRouteParams(routeParams),
            pageSize: queryParams.pageSize || this.config.view?.defaultPageSize,
            currentPage: queryParams.currentPage,
            sortCode: queryParams.sortCode,
        };
    }
    /**
     * Resolves the search query from the given `ProductListRouteParams`.
     */
    getQueryFromRouteParams({ query, categoryCode, brandCode, }) {
        if (query) {
            return query;
        }
        if (categoryCode) {
            return this.RELEVANCE_ALLCATEGORIES + categoryCode;
        }
        // TODO: drop support for brands as they should be treated
        // similarly as any category.
        if (brandCode) {
            return this.RELEVANCE_ALLCATEGORIES + brandCode;
        }
    }
    /**
     * Performs a search based on the given search criteria.
     *
     * The search is delegated to the `ProductSearchService`.
     */
    search(criteria) {
        const currentPage = criteria.currentPage;
        const pageSize = criteria.pageSize;
        const sort = criteria.sortCode;
        this.productSearchService.search(criteria.query, 
        // TODO: consider dropping this complex passing of cleaned object
        Object.assign({}, currentPage && { currentPage }, pageSize && { pageSize }, sort && { sort }));
    }
    /**
     * Get items from a given page without using navigation
     */
    getPageItems(pageNumber) {
        this.routing
            .getRouterState()
            .subscribe((route) => {
            const routeCriteria = this.getCriteriaFromRoute(route.state.params, route.state.queryParams);
            const criteria = {
                ...routeCriteria,
                currentPage: pageNumber,
            };
            this.search(criteria);
        })
            .unsubscribe();
    }
    /**
     * Sort the search results by the given sort code.
     */
    sort(sortCode) {
        this.route({ sortCode });
    }
    /**
     * Routes to the next product listing page, using the given `queryParams`. The
     * `queryParams` support sorting, pagination and querying.
     *
     * The `queryParams` are delegated to the Angular router `NavigationExtras`.
     */
    route(queryParams) {
        this.router.navigate([], {
            queryParams,
            queryParamsHandling: 'merge',
            relativeTo: this.activatedRoute,
        });
    }
    /**
     * The site context is used to update the search query in case of a
     * changing context. The context will typically influence the search data.
     *
     * We keep this private for now, as we're likely refactoring this in the next
     * major version.
     */
    get siteContext() {
        // TODO: we should refactor this so that custom context will be taken
        // into account automatically. Ideally, we drop the specific context
        // from the constructor, and query a ContextService for all contexts.
        return [this.languageService.getActive(), this.currencyService.getActive()];
    }
}
ProductListComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListComponentService, deps: [{ token: i1.ProductSearchService }, { token: i1.RoutingService }, { token: i1$2.ActivatedRoute }, { token: i1.CurrencyService }, { token: i1.LanguageService }, { token: i1$2.Router }, { token: ViewConfig }], target: i0.ɵɵFactoryTarget.Injectable });
ProductListComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListComponentService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ProductSearchService }, { type: i1.RoutingService }, { type: i1$2.ActivatedRoute }, { type: i1.CurrencyService }, { type: i1.LanguageService }, { type: i1$2.Router }, { type: ViewConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var ViewModes;
(function (ViewModes) {
    ViewModes["Grid"] = "grid";
    ViewModes["List"] = "list";
})(ViewModes || (ViewModes = {}));
class ProductViewComponent {
    constructor() {
        this.iconTypes = ICON_TYPE;
        this.modeChange = new EventEmitter();
    }
    get buttonClass() {
        const viewName = this.viewMode?.toLowerCase();
        return `cx-product-${viewName}`;
    }
    /**
     *   Display icons inversely to allow users
     *   to see the view they will navigate to
     */
    get viewMode() {
        if (this.mode === 'list') {
            return this.iconTypes.GRID;
        }
        return this.iconTypes.LIST;
    }
    changeMode() {
        const newMode = this.mode === ViewModes.Grid ? ViewModes.List : ViewModes.Grid;
        this.modeChange.emit(newMode);
    }
}
ProductViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductViewComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ProductViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductViewComponent, selector: "cx-product-view", inputs: { mode: "mode" }, outputs: { modeChange: "modeChange" }, ngImport: i0, template: "<button\n  class=\"btn cx-product-layout\"\n  [ngClass]=\"buttonClass\"\n  (click)=\"changeMode()\"\n  tabindex=\"0\"\n  attr.aria-label=\"{{\n    viewMode === iconTypes.GRID\n      ? ('productView.gridView' | cxTranslate)\n      : viewMode === iconTypes.LIST\n      ? ('productView.listView' | cxTranslate)\n      : null\n  }}\"\n>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.GRID\"\n    [type]=\"iconTypes.GRID\"\n  ></cx-icon>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.LIST\"\n    [type]=\"iconTypes.LIST\"\n  ></cx-icon>\n</button>\n", dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductViewComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-view', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  class=\"btn cx-product-layout\"\n  [ngClass]=\"buttonClass\"\n  (click)=\"changeMode()\"\n  tabindex=\"0\"\n  attr.aria-label=\"{{\n    viewMode === iconTypes.GRID\n      ? ('productView.gridView' | cxTranslate)\n      : viewMode === iconTypes.LIST\n      ? ('productView.listView' | cxTranslate)\n      : null\n  }}\"\n>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.GRID\"\n    [type]=\"iconTypes.GRID\"\n  ></cx-icon>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.LIST\"\n    [type]=\"iconTypes.LIST\"\n  ></cx-icon>\n</button>\n" }]
        }], propDecorators: { mode: [{
                type: Input
            }], modeChange: [{
                type: Output
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var ProductDetailOutlets;
(function (ProductDetailOutlets) {
    ProductDetailOutlets["INTRO"] = "PDP.INTRO";
    ProductDetailOutlets["PRICE"] = "PDP.PRICE";
    ProductDetailOutlets["SHARE"] = "PDP.SHARE";
    ProductDetailOutlets["SUMMARY"] = "PDP.SUMMARY";
})(ProductDetailOutlets || (ProductDetailOutlets = {}));
var ProductListOutlets;
(function (ProductListOutlets) {
    ProductListOutlets["ITEM_ACTIONS"] = "cx-product-list-item.actions";
    ProductListOutlets["ITEM_DETAILS"] = "cx-product-list-item.details";
})(ProductListOutlets || (ProductListOutlets = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Context for `ProductListItemComponent`.
 */
class ProductListItemContext {
}
ProductListItemContext.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListItemContext, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ProductListItemContext.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListItemContext });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListItemContext, decorators: [{
            type: Injectable
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Context source for `ProductListItemComponent`.
 *
 * `ProductListItemContext` should be injected instead in child components.
 */
class ProductListItemContextSource extends ProductListItemContext {
    constructor() {
        super(...arguments);
        this.product$ = new ReplaySubject(1);
    }
}
ProductListItemContextSource.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListItemContextSource, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
ProductListItemContextSource.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListItemContextSource });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListItemContextSource, decorators: [{
            type: Injectable
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductListItemComponent {
    constructor(productListItemContextSource) {
        this.productListItemContextSource = productListItemContextSource;
        this.ProductListOutlets = ProductListOutlets;
    }
    ngOnChanges(changes) {
        if (changes?.product) {
            this.productListItemContextSource.product$.next(this.product);
        }
    }
}
ProductListItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListItemComponent, deps: [{ token: ProductListItemContextSource }], target: i0.ɵɵFactoryTarget.Component });
ProductListItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductListItemComponent, selector: "cx-product-list-item", inputs: { product: "product" }, providers: [
        ProductListItemContextSource,
        {
            provide: ProductListItemContext,
            useExisting: ProductListItemContextSource,
        },
    ], usesOnChanges: true, ngImport: i0, template: "<div class=\"row\">\n  <div class=\"col-12 col-md-4\">\n    <a\n      [attr.aria-label]=\"\n        !product.images?.hasOwnProperty('PRIMARY')\n          ? ('productDetails.noProductImage'\n            | cxTranslate: { product: product.name })\n          : undefined\n      \"\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-image-container\"\n    >\n      <cx-media\n        class=\"cx-product-image\"\n        [container]=\"product.images?.PRIMARY\"\n        format=\"product\"\n        [alt]=\"product.name || product.summary\"\n      ></cx-media>\n    </a>\n  </div>\n  <div class=\"col-12 col-md-8\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-name\"\n    >\n      <h2 [innerHtml]=\"product.nameHtml\"></h2>\n    </a>\n\n    <ng-template [cxOutlet]=\"ProductListOutlets.ITEM_DETAILS\">\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        [rating]=\"product?.averageRating\"\n      ></cx-star-rating>\n      <div *ngIf=\"!product.averageRating\" class=\"cx-product-no-review\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n      <div\n        class=\"cx-product-price\"\n        [attr.aria-label]=\"'productDetails.productPrice' | cxTranslate\"\n      >\n        {{ product.price?.formattedValue }}\n      </div>\n    </ng-template>\n\n    <div class=\"row\">\n      <div class=\"col-12 col-md-7 col-xl-7\">\n        <p class=\"cx-product-summary\" [innerHtml]=\"product.summary\">\n          {{ product.summary }}\n        </p>\n      </div>\n      <div class=\"col-12 col-md-5 col-xl-5\">\n        <ng-template [cxOutlet]=\"ProductListOutlets.ITEM_ACTIONS\">\n          <ng-container cxInnerComponentsHost></ng-container>\n        </ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }, { kind: "directive", type: InnerComponentsHostDirective, selector: "[cxInnerComponentsHost]" }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.UrlPipe, name: "cxUrl" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-list-item', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        ProductListItemContextSource,
                        {
                            provide: ProductListItemContext,
                            useExisting: ProductListItemContextSource,
                        },
                    ], template: "<div class=\"row\">\n  <div class=\"col-12 col-md-4\">\n    <a\n      [attr.aria-label]=\"\n        !product.images?.hasOwnProperty('PRIMARY')\n          ? ('productDetails.noProductImage'\n            | cxTranslate: { product: product.name })\n          : undefined\n      \"\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-image-container\"\n    >\n      <cx-media\n        class=\"cx-product-image\"\n        [container]=\"product.images?.PRIMARY\"\n        format=\"product\"\n        [alt]=\"product.name || product.summary\"\n      ></cx-media>\n    </a>\n  </div>\n  <div class=\"col-12 col-md-8\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-name\"\n    >\n      <h2 [innerHtml]=\"product.nameHtml\"></h2>\n    </a>\n\n    <ng-template [cxOutlet]=\"ProductListOutlets.ITEM_DETAILS\">\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        [rating]=\"product?.averageRating\"\n      ></cx-star-rating>\n      <div *ngIf=\"!product.averageRating\" class=\"cx-product-no-review\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n      <div\n        class=\"cx-product-price\"\n        [attr.aria-label]=\"'productDetails.productPrice' | cxTranslate\"\n      >\n        {{ product.price?.formattedValue }}\n      </div>\n    </ng-template>\n\n    <div class=\"row\">\n      <div class=\"col-12 col-md-7 col-xl-7\">\n        <p class=\"cx-product-summary\" [innerHtml]=\"product.summary\">\n          {{ product.summary }}\n        </p>\n      </div>\n      <div class=\"col-12 col-md-5 col-xl-5\">\n        <ng-template [cxOutlet]=\"ProductListOutlets.ITEM_ACTIONS\">\n          <ng-container cxInnerComponentsHost></ng-container>\n        </ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: ProductListItemContextSource }]; }, propDecorators: { product: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductGridItemComponent {
    constructor(productListItemContextSource) {
        this.productListItemContextSource = productListItemContextSource;
        this.ProductListOutlets = ProductListOutlets;
    }
    ngOnChanges(changes) {
        if (changes?.product) {
            this.productListItemContextSource.product$.next(this.product);
        }
    }
}
ProductGridItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductGridItemComponent, deps: [{ token: ProductListItemContextSource }], target: i0.ɵɵFactoryTarget.Component });
ProductGridItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: { product: "product" }, providers: [
        ProductListItemContextSource,
        {
            provide: ProductListItemContext,
            useExisting: ProductListItemContextSource,
        },
    ], usesOnChanges: true, ngImport: i0, template: "<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-image-container\"\n  tabindex=\"-1\"\n>\n  <cx-media\n    class=\"cx-product-image\"\n    [container]=\"product.images?.PRIMARY\"\n    format=\"product\"\n    [alt]=\"product.summary\"\n  ></cx-media>\n</a>\n<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-name\"\n  [innerHTML]=\"product.nameHtml\"\n></a>\n\n<ng-template [cxOutlet]=\"ProductListOutlets.ITEM_DETAILS\">\n  <div class=\"cx-product-rating\">\n    <cx-star-rating\n      *ngIf=\"product.averageRating\"\n      [rating]=\"product?.averageRating\"\n    ></cx-star-rating>\n    <div *ngIf=\"!product.averageRating\">\n      {{ 'productDetails.noReviews' | cxTranslate }}\n    </div>\n  </div>\n  <div class=\"cx-product-price-container\">\n    <div\n      class=\"cx-product-price\"\n      [attr.aria-label]=\"'productDetails.productPrice' | cxTranslate\"\n    >\n      {{ product.price?.formattedValue }}\n    </div>\n  </div>\n</ng-template>\n\n<ng-template [cxOutlet]=\"ProductListOutlets.ITEM_ACTIONS\">\n  <ng-container cxInnerComponentsHost></ng-container>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }, { kind: "directive", type: InnerComponentsHostDirective, selector: "[cxInnerComponentsHost]" }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.UrlPipe, name: "cxUrl" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductGridItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-grid-item', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        ProductListItemContextSource,
                        {
                            provide: ProductListItemContext,
                            useExisting: ProductListItemContextSource,
                        },
                    ], template: "<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-image-container\"\n  tabindex=\"-1\"\n>\n  <cx-media\n    class=\"cx-product-image\"\n    [container]=\"product.images?.PRIMARY\"\n    format=\"product\"\n    [alt]=\"product.summary\"\n  ></cx-media>\n</a>\n<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-name\"\n  [innerHTML]=\"product.nameHtml\"\n></a>\n\n<ng-template [cxOutlet]=\"ProductListOutlets.ITEM_DETAILS\">\n  <div class=\"cx-product-rating\">\n    <cx-star-rating\n      *ngIf=\"product.averageRating\"\n      [rating]=\"product?.averageRating\"\n    ></cx-star-rating>\n    <div *ngIf=\"!product.averageRating\">\n      {{ 'productDetails.noReviews' | cxTranslate }}\n    </div>\n  </div>\n  <div class=\"cx-product-price-container\">\n    <div\n      class=\"cx-product-price\"\n      [attr.aria-label]=\"'productDetails.productPrice' | cxTranslate\"\n    >\n      {{ product.price?.formattedValue }}\n    </div>\n  </div>\n</ng-template>\n\n<ng-template [cxOutlet]=\"ProductListOutlets.ITEM_ACTIONS\">\n  <ng-container cxInnerComponentsHost></ng-container>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: ProductListItemContextSource }]; }, propDecorators: { product: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductScrollComponent {
    set setConfig(inputConfig) {
        this.setComponentConfigurations(inputConfig);
    }
    set setModel(inputModel) {
        this.infiniteScrollOperations(inputModel);
    }
    set setViewMode(inputViewMode) {
        this.inputViewMode = inputViewMode;
        //If viewMode is already set (meaning it is not the first load)
        //Reset the product list
        if (this.viewMode) {
            this.resetListOnViewModeChange();
        }
        else {
            //If viewMode is not set (meaning it is the first load)
            //Set the viewMode
            this.viewMode = inputViewMode;
        }
    }
    constructor(productListComponentService, ref) {
        this.productListComponentService = productListComponentService;
        this.ref = ref;
        this.subscription = new Subscription();
        this.ViewModes = ViewModes;
        this.appendProducts = false;
        this.resetList = false;
        this.isMaxProducts = false;
        this.isLastPage = false;
        this.isEmpty = false;
    }
    scrollPage(pageNumber) {
        this.appendProducts = true;
        this.ref.markForCheck();
        this.productListComponentService.getPageItems(pageNumber);
    }
    loadNextPage(pageNumber) {
        this.isMaxProducts = false;
        this.scrollPage(pageNumber);
    }
    scrollToTop() {
        window.scroll(0, 0);
    }
    setComponentConfigurations(scrollConfig) {
        const isButton = scrollConfig.view?.infiniteScroll?.showMoreButton;
        const configProductLimit = scrollConfig.view?.infiniteScroll?.productLimit;
        //Display "show more" button every time when button configuration is true
        //Otherwise, only display "show more" when the configuration product limit is reached
        this.productLimit = isButton ? 1 : configProductLimit;
    }
    infiniteScrollOperations(inputModel) {
        if (this.appendProducts) {
            this.model = {
                ...inputModel,
                products: this.model.products?.concat(inputModel.products ?? []),
            };
        }
        else {
            this.model = inputModel;
            this.maxProducts = this.productLimit;
        }
        this.setConditions();
        this.ref.markForCheck();
    }
    resetListOnViewModeChange() {
        this.scrollToTop();
        this.resetList = true;
        this.productListComponentService.getPageItems(0);
    }
    //Set booleans after model has been retrieved
    setConditions() {
        this.isEmpty = !this.model.products || this.model.products.length === 0;
        this.isLastPage =
            this.model.pagination?.currentPage ===
                (this.model.pagination?.totalPages ?? 0) - 1;
        if (this.model.products) {
            this.isMaxProducts =
                this.productLimit !== undefined &&
                    this.productLimit !== 0 &&
                    this.model.products.length >= (this.maxProducts ?? 0);
            //Add the productLimit to the current number of products to determine the next max number of products
            if (this.isMaxProducts) {
                this.maxProducts =
                    this.model.products.length + (this.productLimit ?? 0);
            }
        }
        //Only change viewMode once the new model is set
        //This prevents flickering issues
        if (this.viewMode !== this.inputViewMode) {
            this.viewMode = this.inputViewMode;
        }
        this.resetList = false;
        this.appendProducts = false;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ProductScrollComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductScrollComponent, deps: [{ token: ProductListComponentService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ProductScrollComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductScrollComponent, selector: "cx-product-scroll", inputs: { setConfig: ["scrollConfig", "setConfig"], setModel: ["model", "setModel"], setViewMode: ["inputViewMode", "setViewMode"] }, ngImport: i0, template: "<ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"5\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage((model?.pagination?.currentPage ?? 0) + 1)\"\n  >\n    <div class=\"row\">\n      <cx-product-grid-item\n        *ngFor=\"let product of model?.products\"\n        [product]=\"product\"\n        class=\"col-12 col-sm-6 col-md-4\"\n      ></cx-product-grid-item>\n    </div>\n    <div\n      [className]=\"\n        !isLastPage && (model?.pagination?.currentPage ?? 0) > 0\n          ? 'cx-double-btn-container grid-btn-padding'\n          : 'cx-single-btn-container grid-btn-padding'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) &&\n          (model?.pagination?.currentPage ?? 0) > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-secondary\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage((model?.pagination?.currentPage ?? 0) + 1)\"\n        class=\"btn btn-block btn-secondary align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"viewMode === ViewModes.List\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"3\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage((model?.pagination?.currentPage ?? 0) + 1)\"\n  >\n    <cx-product-list-item\n      *ngFor=\"let product of model?.products\"\n      [product]=\"product\"\n      class=\"cx-product-search-list\"\n    ></cx-product-list-item>\n    <div\n      [className]=\"\n        !isLastPage && (model?.pagination?.currentPage ?? 0) > 0\n          ? 'cx-double-btn-container'\n          : 'cx-single-btn-container'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) &&\n          (model?.pagination?.currentPage ?? 0) > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-secondary\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage((model?.pagination?.currentPage ?? 0) + 1)\"\n        class=\"btn btn-block btn-secondary align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3$2.InfiniteScrollDirective, selector: "[infiniteScroll], [infinite-scroll], [data-infinite-scroll]", inputs: ["infiniteScrollDistance", "infiniteScrollUpDistance", "infiniteScrollThrottle", "infiniteScrollDisabled", "infiniteScrollContainer", "scrollWindow", "immediateCheck", "horizontal", "alwaysCallback", "fromRoot"], outputs: ["scrolled", "scrolledUp"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "component", type: ProductListItemComponent, selector: "cx-product-list-item", inputs: ["product"] }, { kind: "component", type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: ["product"] }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductScrollComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-scroll', template: "<ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"5\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage((model?.pagination?.currentPage ?? 0) + 1)\"\n  >\n    <div class=\"row\">\n      <cx-product-grid-item\n        *ngFor=\"let product of model?.products\"\n        [product]=\"product\"\n        class=\"col-12 col-sm-6 col-md-4\"\n      ></cx-product-grid-item>\n    </div>\n    <div\n      [className]=\"\n        !isLastPage && (model?.pagination?.currentPage ?? 0) > 0\n          ? 'cx-double-btn-container grid-btn-padding'\n          : 'cx-single-btn-container grid-btn-padding'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) &&\n          (model?.pagination?.currentPage ?? 0) > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-secondary\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage((model?.pagination?.currentPage ?? 0) + 1)\"\n        class=\"btn btn-block btn-secondary align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"viewMode === ViewModes.List\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"3\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage((model?.pagination?.currentPage ?? 0) + 1)\"\n  >\n    <cx-product-list-item\n      *ngFor=\"let product of model?.products\"\n      [product]=\"product\"\n      class=\"cx-product-search-list\"\n    ></cx-product-list-item>\n    <div\n      [className]=\"\n        !isLastPage && (model?.pagination?.currentPage ?? 0) > 0\n          ? 'cx-double-btn-container'\n          : 'cx-single-btn-container'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) &&\n          (model?.pagination?.currentPage ?? 0) > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-secondary\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage((model?.pagination?.currentPage ?? 0) + 1)\"\n        class=\"btn btn-block btn-secondary align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: ProductListComponentService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { setConfig: [{
                type: Input,
                args: ['scrollConfig']
            }], setModel: [{
                type: Input,
                args: ['model']
            }], setViewMode: [{
                type: Input,
                args: ['inputViewMode']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductListComponent {
    constructor(pageLayoutService, productListComponentService, globalMessageService, scrollConfig) {
        this.pageLayoutService = pageLayoutService;
        this.productListComponentService = productListComponentService;
        this.globalMessageService = globalMessageService;
        this.scrollConfig = scrollConfig;
        this.subscription = new Subscription();
        this.model$ = this.productListComponentService.model$;
        this.viewMode$ = new BehaviorSubject(ViewModes.Grid);
        this.ViewModes = ViewModes;
    }
    ngOnInit() {
        this.isInfiniteScroll = this.scrollConfig.view?.infiniteScroll?.active;
        this.subscription.add(this.pageLayoutService.templateName$
            .pipe(take(1))
            .subscribe((template) => {
            this.viewMode$.next(template === 'ProductGridPageTemplate'
                ? ViewModes.Grid
                : ViewModes.List);
        }));
        this.subscription.add(combineLatest([this.model$, this.viewMode$])
            .pipe(skip(1), filter(([model, mode]) => !!model && !!mode))
            .subscribe(() => this.globalMessageService.add({ key: 'sorting.pageViewUpdated' }, GlobalMessageType.MSG_TYPE_ASSISTIVE, 500)));
    }
    sortList(sortCode) {
        this.productListComponentService.sort(sortCode);
    }
    setViewMode(mode) {
        this.viewMode$.next(mode);
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ProductListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListComponent, deps: [{ token: PageLayoutService }, { token: ProductListComponentService }, { token: i1.GlobalMessageService }, { token: ViewConfig }], target: i0.ɵɵFactoryTarget.Component });
ProductListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductListComponent, selector: "cx-product-list", ngImport: i0, template: "<div class=\"cx-page\" *ngIf=\"model$ | async as model\">\n  <section\n    tabindex=\"-1\"\n    class=\"cx-page-section\"\n    [attr.aria-label]=\"'productList.productListResults' | cxTranslate\"\n  >\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-12 col-lg-12\" *ngIf=\"viewMode$ | async as viewMode\">\n          <div class=\"cx-sorting top\">\n            <div class=\"row\">\n              <label\n                class=\"form-group cx-sort-dropdown col-12 col-lg-4 mr-auto\"\n              >\n                <span>{{ 'productList.sortBy' | cxTranslate }}</span>\n                <cx-sorting\n                  [sortOptions]=\"model.sorts\"\n                  (sortListEvent)=\"sortList($event)\"\n                  [selectedOption]=\"model.pagination?.sort\"\n                  [ariaLabel]=\"'productList.sortResults' | cxTranslate\"\n                  ariaControls=\"product-results-list\"\n                  placeholder=\"{{ 'productList.sortBy' | cxTranslate }}\"\n                ></cx-sorting>\n              </label>\n              <div *ngIf=\"!isInfiniteScroll\" class=\"col-auto\">\n                <div\n                  class=\"cx-pagination\"\n                  [attr.aria-label]=\"\n                    'productList.productSearchPagination' | cxTranslate\n                  \"\n                >\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n          <div id=\"product-results-list\" class=\"cx-product-container\">\n            <!-- Product list when using pagination -->\n            <ng-container *ngIf=\"!isInfiniteScroll; else infiniteScroll\">\n              <ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n                <div class=\"row\">\n                  <cx-product-grid-item\n                    *ngFor=\"let product of model?.products\"\n                    [product]=\"product\"\n                    class=\"col-12 col-sm-6 col-md-4\"\n                  ></cx-product-grid-item>\n                </div>\n              </ng-container>\n\n              <ng-container *ngIf=\"viewMode === ViewModes.List\">\n                <cx-product-list-item\n                  *ngFor=\"let product of model?.products\"\n                  [product]=\"product\"\n                  class=\"cx-product-search-list\"\n                ></cx-product-list-item>\n              </ng-container>\n            </ng-container>\n\n            <!-- Product list when using infinite scroll -->\n            <ng-template #infiniteScroll>\n              <cx-product-scroll\n                [scrollConfig]=\"scrollConfig\"\n                [model]=\"model\"\n                [inputViewMode]=\"viewMode\"\n              ></cx-product-scroll>\n            </ng-template>\n          </div>\n          <div class=\"cx-sorting bottom\">\n            <div class=\"row\">\n              <label\n                class=\"form-group cx-sort-dropdown col-12 col-lg-4 mr-auto\"\n              >\n                <span>{{ 'productList.sortBy' | cxTranslate }}</span>\n                <cx-sorting\n                  [sortOptions]=\"model.sorts\"\n                  (sortListEvent)=\"sortList($event)\"\n                  [selectedOption]=\"model.pagination?.sort\"\n                  [ariaLabel]=\"'productList.sortResults' | cxTranslate\"\n                  ariaControls=\"product-results-list\"\n                  placeholder=\"{{ 'productList.sortBy' | cxTranslate }}\"\n                ></cx-sorting>\n              </label>\n              <div\n                *ngIf=\"!isInfiniteScroll\"\n                class=\"col-auto\"\n                [attr.aria-label]=\"\n                  'productList.productSearchPagination' | cxTranslate\n                \"\n              >\n                <div class=\"cx-pagination\">\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </section>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: SortingComponent, selector: "cx-sorting", inputs: ["sortOptions", "ariaControls", "ariaLabel", "selectedOption", "placeholder", "sortLabels"], outputs: ["sortListEvent"] }, { kind: "component", type: PaginationComponent, selector: "cx-pagination", inputs: ["pageRoute", "queryParam", "defaultPage", "pagination"], outputs: ["viewPageEvent"] }, { kind: "component", type: ProductListItemComponent, selector: "cx-product-list-item", inputs: ["product"] }, { kind: "component", type: ProductGridItemComponent, selector: "cx-product-grid-item", inputs: ["product"] }, { kind: "component", type: ProductViewComponent, selector: "cx-product-view", inputs: ["mode"], outputs: ["modeChange"] }, { kind: "component", type: ProductScrollComponent, selector: "cx-product-scroll", inputs: ["scrollConfig", "model", "inputViewMode"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-list', template: "<div class=\"cx-page\" *ngIf=\"model$ | async as model\">\n  <section\n    tabindex=\"-1\"\n    class=\"cx-page-section\"\n    [attr.aria-label]=\"'productList.productListResults' | cxTranslate\"\n  >\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-12 col-lg-12\" *ngIf=\"viewMode$ | async as viewMode\">\n          <div class=\"cx-sorting top\">\n            <div class=\"row\">\n              <label\n                class=\"form-group cx-sort-dropdown col-12 col-lg-4 mr-auto\"\n              >\n                <span>{{ 'productList.sortBy' | cxTranslate }}</span>\n                <cx-sorting\n                  [sortOptions]=\"model.sorts\"\n                  (sortListEvent)=\"sortList($event)\"\n                  [selectedOption]=\"model.pagination?.sort\"\n                  [ariaLabel]=\"'productList.sortResults' | cxTranslate\"\n                  ariaControls=\"product-results-list\"\n                  placeholder=\"{{ 'productList.sortBy' | cxTranslate }}\"\n                ></cx-sorting>\n              </label>\n              <div *ngIf=\"!isInfiniteScroll\" class=\"col-auto\">\n                <div\n                  class=\"cx-pagination\"\n                  [attr.aria-label]=\"\n                    'productList.productSearchPagination' | cxTranslate\n                  \"\n                >\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n          <div id=\"product-results-list\" class=\"cx-product-container\">\n            <!-- Product list when using pagination -->\n            <ng-container *ngIf=\"!isInfiniteScroll; else infiniteScroll\">\n              <ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n                <div class=\"row\">\n                  <cx-product-grid-item\n                    *ngFor=\"let product of model?.products\"\n                    [product]=\"product\"\n                    class=\"col-12 col-sm-6 col-md-4\"\n                  ></cx-product-grid-item>\n                </div>\n              </ng-container>\n\n              <ng-container *ngIf=\"viewMode === ViewModes.List\">\n                <cx-product-list-item\n                  *ngFor=\"let product of model?.products\"\n                  [product]=\"product\"\n                  class=\"cx-product-search-list\"\n                ></cx-product-list-item>\n              </ng-container>\n            </ng-container>\n\n            <!-- Product list when using infinite scroll -->\n            <ng-template #infiniteScroll>\n              <cx-product-scroll\n                [scrollConfig]=\"scrollConfig\"\n                [model]=\"model\"\n                [inputViewMode]=\"viewMode\"\n              ></cx-product-scroll>\n            </ng-template>\n          </div>\n          <div class=\"cx-sorting bottom\">\n            <div class=\"row\">\n              <label\n                class=\"form-group cx-sort-dropdown col-12 col-lg-4 mr-auto\"\n              >\n                <span>{{ 'productList.sortBy' | cxTranslate }}</span>\n                <cx-sorting\n                  [sortOptions]=\"model.sorts\"\n                  (sortListEvent)=\"sortList($event)\"\n                  [selectedOption]=\"model.pagination?.sort\"\n                  [ariaLabel]=\"'productList.sortResults' | cxTranslate\"\n                  ariaControls=\"product-results-list\"\n                  placeholder=\"{{ 'productList.sortBy' | cxTranslate }}\"\n                ></cx-sorting>\n              </label>\n              <div\n                *ngIf=\"!isInfiniteScroll\"\n                class=\"col-auto\"\n                [attr.aria-label]=\"\n                  'productList.productSearchPagination' | cxTranslate\n                \"\n              >\n                <div class=\"cx-pagination\">\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </section>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: PageLayoutService }, { type: ProductListComponentService }, { type: i1.GlobalMessageService }, { type: ViewConfig }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var FacetGroupCollapsedState;
(function (FacetGroupCollapsedState) {
    FacetGroupCollapsedState["EXPANDED"] = "EXPANDED";
    FacetGroupCollapsedState["COLLAPSED"] = "COLLAPSED";
})(FacetGroupCollapsedState || (FacetGroupCollapsedState = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Provides access to all the facets and active facets for the Product Listing Page.
 */
class ProductFacetService {
    constructor(routing, productListComponentService) {
        this.routing = routing;
        this.productListComponentService = productListComponentService;
        this.routeState$ = this.routing
            .getRouterState()
            .pipe(pluck('state'));
        /**
         * Returns the search results for the current page.
         */
        this.searchResult$ = this.routeState$.pipe(switchMap((state) => this.productListComponentService.model$.pipe(filter((page) => this.filterForPage(state, page)), map((page) => ({
            ...page,
            breadcrumbs: this.filterBreadcrumbs(page?.breadcrumbs ?? [], state.params),
        })))));
        /**
         * Observes the facets and active facets for the given page. The facet data
         * is provided in a `FacetList`.
         */
        this.facetList$ = this.searchResult$.pipe(map((result) => ({
            facets: result.facets,
            activeFacets: result.breadcrumbs,
        })));
    }
    /**
     * Filters the current result by verifying if the result is related to the page.
     * This is done to avoid a combination of the next page and the current search results.
     */
    filterForPage(state, page) {
        if (!page.currentQuery?.query?.value) {
            return false;
        }
        if (state.context.type === PageType.CATEGORY_PAGE) {
            return (page.currentQuery.query.value.indexOf(`allCategories:${state.context.id}`) > -1);
        }
        if (state.context.type === PageType.CONTENT_PAGE &&
            state.context.id === 'search') {
            return page.freeTextSearch === state.params.query.split(':')[0];
        }
        return false;
    }
    /**
     * Filter breadcrumbs which are not actively selected but coming from
     * the route navigation.
     *
     * The breadcrumbs might include the active category page code, which is not actively
     * selected by the user.
     */
    filterBreadcrumbs(breadcrumbs, params) {
        return breadcrumbs
            ? breadcrumbs.filter((breadcrumb) => !(breadcrumb.facetCode === 'allCategories' &&
                (breadcrumb.facetValueCode === params.categoryCode ||
                    breadcrumb.facetValueCode === params.brandCode)))
            : [];
    }
}
ProductFacetService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetService, deps: [{ token: i1.RoutingService }, { token: ProductListComponentService }], target: i0.ɵɵFactoryTarget.Injectable });
ProductFacetService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RoutingService }, { type: ProductListComponentService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Provides access to the facets as well as their UI state. The UI state
 * represents user related changes on the facets, such as expanding or
 * collapsing a facet group or expanding the number of _visible_ facet values.
 */
class FacetService {
    constructor(productFacetService) {
        this.productFacetService = productFacetService;
        /**
         * An internal map where we keep the UI state of the facets.
         */
        this.facetState = new Map();
        this.codec = new HttpUrlEncodingCodec();
        /**
         * Observes the facets for the given page and configures the initial UI state.
         *
         * Facets are configured on each emission so that we keep the facet UI state.
         * This is mainly done to keep the state during usage of the facet, but also
         * benefitial when the facets are rebuild while using them.
         */
        this.facetList$ = this.productFacetService.facetList$.pipe(tap((facetList) => {
            facetList.facets?.forEach((facet) => this.initialize(facet));
        }));
    }
    /**
     * Returns the observed UI state for the facet.
     *
     * The state is initialized using the `initialize` method.
     */
    getState(facet) {
        this.initialize(facet);
        return facet.name ? this.facetState.get(facet.name) ?? of({}) : of({});
    }
    /**
     * Returns the UI state for the facet.
     *
     * The state is initialized using the `initialize` method.
     */
    getStateSnapshot(facet) {
        return this.getState(facet).value;
    }
    /**
     * Toggles the facet expanded state. If the expanded state becomes false,
     * the visible values will decrease to the top values only.
     *
     * If the optional value argument is provided the expanded state will be set
     * to this value, regardless of the current `expanded` state.
     */
    toggle(facet, isExpanded) {
        const state = this.getStateSnapshot(facet);
        const toggledState = {
            toggled: isExpanded
                ? FacetGroupCollapsedState.COLLAPSED
                : FacetGroupCollapsedState.EXPANDED,
        };
        if (toggledState.toggled === FacetGroupCollapsedState.COLLAPSED) {
            toggledState.maxVisible = state.topVisible;
        }
        this.updateState(facet, toggledState);
    }
    /**
     * Increases the visible values to the maximum values of the facet.
     */
    increaseVisibleValues(facet) {
        this.updateState(facet, { maxVisible: facet.values?.length });
    }
    /**
     * Decreases the visible values to the topValueCount.
     *
     * The topValueCount defaults to 6, but can be controlled in
     * the backend as well.
     */
    decreaseVisibleValues(facet) {
        this.updateState(facet, { maxVisible: facet.topValueCount });
    }
    /**
     * Persists the facet state and initializes the default values for the top
     * and max visible values.
     */
    initialize(facet) {
        const topFacets = facet.topValueCount && facet.topValueCount > 0
            ? facet.topValueCount
            : facet.values?.length || 0;
        if (facet.name && !this.hasState(facet)) {
            this.facetState.set(facet.name, new BehaviorSubject({
                topVisible: topFacets,
                maxVisible: topFacets,
            }));
        }
    }
    /**
     * Updates the state of the facet in the local facet map.
     */
    updateState(facet, property) {
        const state = { ...this.getStateSnapshot(facet), ...property };
        if (facet.name) {
            this.facetState.get(facet.name)?.next(state);
        }
    }
    hasState(facet) {
        if (facet.name) {
            return this.facetState.has(facet.name);
        }
        return false;
    }
    getLinkParams(query) {
        return {
            // to avoid encoding issues with facets that have space (' ') in their name,
            // we replace the decoded '+' back to empty space ' '.
            // For more, see https://github.com/SAP/spartacus/issues/7348
            query: this.codec
                .decodeValue(this.decodeUriComponentSafe(query))
                .replace(/\+/g, ' '),
        };
    }
    decodeUriComponentSafe(query) {
        return query.replace(/%(?![0-9a-fA-F]{2})/g, '%25');
    }
}
FacetService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetService, deps: [{ token: ProductFacetService }], target: i0.ɵɵFactoryTarget.Injectable });
FacetService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ProductFacetService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Active facets render the applied facet values as a list of focusable buttons
 * which can be used to remove the applied facet value.
 */
class ActiveFacetsComponent {
    constructor(facetService) {
        this.facetService = facetService;
        this.role = 'group';
        this.labelledby = 'cx-active-facets-groupName';
        /** Active facets which are applied to the product results. */
        this.facetList$ = this.facetService.facetList$;
        /** Configurable icon which is used for the active facet close button */
        this.closeIcon = ICON_TYPE.CLOSE;
    }
    getLinkParams(facet) {
        return this.facetService.getLinkParams(facet.removeQuery?.query?.value ?? '');
    }
    /**
     * The focus key is used to persist the focus on the facet when the DOM is being
     * recreated. We only apply the focus key for the given _active_ facet when there
     * the original facets is not available. This happens for non multi-valued facets.
     *
     * With this approach, the we keep the focus, either at the facet list or on the
     * active facets.
     */
    getFocusKey(facetList, facet) {
        return facetList.facets?.find((f) => f.values?.find((val) => val.name === facet.facetValueName))
            ? ''
            : facet.facetValueName;
    }
    /**
     * Purpose of this function is to allow keyboard users to click on a filter they
     * wish to remove by pressing spacebar. Event not handled natively by <a> elements.
     *
     * @param event spacebar keydown
     */
    removeFilterWithSpacebar(event) {
        event?.preventDefault(); // Avoid spacebar scroll
        event?.target?.dispatchEvent(new MouseEvent('click', { cancelable: true }));
    }
}
ActiveFacetsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ActiveFacetsComponent, deps: [{ token: FacetService }], target: i0.ɵɵFactoryTarget.Component });
ActiveFacetsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ActiveFacetsComponent, selector: "cx-active-facets", inputs: { closeIcon: "closeIcon" }, host: { properties: { "attr.role": "this.role", "attr.aria-labelledby": "this.labelledby" } }, ngImport: i0, template: "<ng-container *ngIf=\"facetList$ | async as facetList\">\n  <div\n    id=\"cx-active-facets-groupName\"\n    *ngIf=\"facetList.activeFacets && facetList.activeFacets.length > 0\"\n  >\n    {{ 'productList.appliedFilter' | cxTranslate }}\n  </div>\n\n  <a\n    *ngFor=\"let facet of facetList?.activeFacets\"\n    routerLink=\"./\"\n    [queryParams]=\"getLinkParams(facet)\"\n    [cxFocus]=\"{ key: getFocusKey(facetList, facet) }\"\n    role=\"button\"\n    (keydown.space)=\"removeFilterWithSpacebar($event)\"\n    [attr.aria-label]=\"\n      'productList.activeFilter' | cxTranslate: { filter: facet.facetValueName }\n    \"\n  >\n    <span>{{ facet.facetValueName }}</span>\n    <cx-icon aria-hidden=\"true\" [type]=\"closeIcon\"></cx-icon>\n  </a>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.Default });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ActiveFacetsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-active-facets', changeDetection: ChangeDetectionStrategy.Default, template: "<ng-container *ngIf=\"facetList$ | async as facetList\">\n  <div\n    id=\"cx-active-facets-groupName\"\n    *ngIf=\"facetList.activeFacets && facetList.activeFacets.length > 0\"\n  >\n    {{ 'productList.appliedFilter' | cxTranslate }}\n  </div>\n\n  <a\n    *ngFor=\"let facet of facetList?.activeFacets\"\n    routerLink=\"./\"\n    [queryParams]=\"getLinkParams(facet)\"\n    [cxFocus]=\"{ key: getFocusKey(facetList, facet) }\"\n    role=\"button\"\n    (keydown.space)=\"removeFilterWithSpacebar($event)\"\n    [attr.aria-label]=\"\n      'productList.activeFilter' | cxTranslate: { filter: facet.facetValueName }\n    \"\n  >\n    <span>{{ facet.facetValueName }}</span>\n    <cx-icon aria-hidden=\"true\" [type]=\"closeIcon\"></cx-icon>\n  </a>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: FacetService }]; }, propDecorators: { role: [{
                type: HostBinding,
                args: ['attr.role']
            }], labelledby: [{
                type: HostBinding,
                args: ['attr.aria-labelledby']
            }], closeIcon: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ActiveFacetsModule {
}
ActiveFacetsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ActiveFacetsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ActiveFacetsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ActiveFacetsModule, declarations: [ActiveFacetsComponent], imports: [CommonModule,
        RouterModule,
        I18nModule,
        IconModule,
        KeyboardFocusModule], exports: [ActiveFacetsComponent] });
ActiveFacetsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ActiveFacetsModule, imports: [CommonModule,
        RouterModule,
        I18nModule,
        IconModule,
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ActiveFacetsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        I18nModule,
                        IconModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [ActiveFacetsComponent],
                    exports: [ActiveFacetsComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FacetComponent {
    set facet(value) {
        this._facet = value;
        this.isMultiSelect = !!value.multiSelect;
        this.state$ = this.facetService.getState(value);
    }
    get facet() {
        return this._facet;
    }
    constructor(facetService, elementRef, cd) {
        this.facetService = facetService;
        this.elementRef = elementRef;
        this.cd = cd;
        /** configurable icon that is used to collapse the facet group  */
        this.expandIcon = ICON_TYPE.EXPAND;
        this.collapseIcon = ICON_TYPE.COLLAPSE;
    }
    /**
     * Handles clicking the heading of the facet group, which means toggling
     * the visibility of the group (collapse / expand) and optionally focusing
     * the group.
     */
    toggleGroup(event) {
        const host = this.elementRef.nativeElement;
        const isLocked = this.keyboardFocus?.isLocked;
        this.facetService.toggle(this.facet, this.isExpanded);
        if (!isLocked || this.isExpanded) {
            host.focus();
            // we stop propagating the event as otherwise the focus on the host will trigger
            // an unlock event from the LockFocus directive.
            event.stopPropagation();
        }
    }
    get isExpanded() {
        return this.values?.first?.nativeElement.offsetParent !== null;
    }
    openLink(event) {
        event.target.click();
        event.preventDefault();
    }
    /**
     * Increases the number of visible values for the facet. This is delegated
     * to `facetService.increaseVisibleValues`.
     */
    increaseVisibleValues() {
        this.facetService.increaseVisibleValues(this.facet);
    }
    /**
     * Decreases the number of visible values for the facet. This is delegated
     * to `facetService.decreaseVisibleValues`.
     */
    decreaseVisibleValues() {
        this.facetService.decreaseVisibleValues(this.facet);
    }
    getLinkParams(value) {
        return this.facetService.getLinkParams(value.query?.query?.value ?? '');
    }
}
FacetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetComponent, deps: [{ token: FacetService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FacetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: FacetComponent, selector: "cx-facet", inputs: { expandIcon: "expandIcon", collapseIcon: "collapseIcon", facet: "facet" }, host: { properties: { "class.multi-select": "this.isMultiSelect" } }, viewQueries: [{ propertyName: "keyboardFocus", first: true, predicate: FocusDirective, descendants: true }, { propertyName: "values", predicate: ["facetValue"], descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"state$ | async as state\">\n  <button\n    class=\"heading\"\n    (click)=\"toggleGroup($event)\"\n    [attr.aria-expanded]=\"isExpanded\"\n    [attr.aria-label]=\"\n      'productFacetNavigation.filterBy.name' | cxTranslate: { name: facet.name }\n    \"\n  >\n    {{ facet.name }}\n    <cx-icon class=\"collapse-icon\" [type]=\"collapseIcon\"></cx-icon>\n    <cx-icon class=\"expand-icon\" [type]=\"expandIcon\"></cx-icon>\n  </button>\n\n  <div>\n    <a\n      *ngFor=\"let value of facet.values | slice: 0:state.topVisible\"\n      #facetValue\n      routerLink=\"./\"\n      [queryParams]=\"getLinkParams(value)\"\n      class=\"value\"\n      [class.selected]=\"value.selected\"\n      [cxFocus]=\"{ key: value.name }\"\n      (keydown.space)=\"openLink($any($event))\"\n      [attr.role]=\"facet.multiSelect ? 'checkbox' : null\"\n      [attr.aria-checked]=\"facet.multiSelect ? value.selected : null\"\n      attr.aria-label=\"{{\n        'productFacetNavigation.ariaLabelItemsAvailable'\n          | cxTranslate: { name: value.name, count: value.count }\n      }}\"\n    >\n      <span aria-hidden=\"true\"\n        >{{ value.name\n        }}<span aria-hidden=\"true\" class=\"count\">{{ value.count }}</span></span\n      >\n    </a>\n\n    <div class=\"more\">\n      <a\n        *ngFor=\"\n          let value of facet.values\n            | slice: state.topVisible ?? 0:state.maxVisible\n        \"\n        #facetValue\n        routerLink=\"./\"\n        [queryParams]=\"getLinkParams(value)\"\n        class=\"value\"\n        [class.selected]=\"value.selected\"\n        [cxFocus]=\"{ key: value.name }\"\n        (keydown.space)=\"openLink($any($event))\"\n      >\n        <span\n          >{{ value.name }}<span class=\"count\">{{ value.count }}</span></span\n        >\n      </a>\n\n      <button\n        *ngIf=\"\n          state.maxVisible &&\n          state.topVisible &&\n          state.maxVisible > state.topVisible\n        \"\n        (click)=\"decreaseVisibleValues()\"\n        [cxAtMessage]=\"\n          'productFacetNavigation.decreaseOptionsVisibility' | cxTranslate\n        \"\n        aria-expanded=\"true\"\n        attr.aria-label=\"{{\n          'productFacetNavigation.ariaLabelShowLess' | cxTranslate\n        }}\"\n        class=\"cx-action-link\"\n        [cxFocus]=\"{ key: 'moreorless' }\"\n      >\n        {{ 'productList.showLess' | cxTranslate }}\n      </button>\n\n      <button\n        *ngIf=\"\n          state.maxVisible &&\n          facet.values &&\n          state.maxVisible > 0 &&\n          state.maxVisible < facet.values.length\n        \"\n        (click)=\"increaseVisibleValues()\"\n        [cxAtMessage]=\"\n          'productFacetNavigation.increaseOptionsVisibility' | cxTranslate\n        \"\n        aria-expanded=\"false\"\n        attr.aria-label=\"{{\n          'productFacetNavigation.ariaLabelShowMore' | cxTranslate\n        }}\"\n        class=\"cx-action-link\"\n        [cxFocus]=\"{ key: 'moreorless' }\"\n      >\n        {{ 'productList.showMore' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: AtMessageDirective, selector: "[cxAtMessage]", inputs: ["cxAtMessage"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i3.SlicePipe, name: "slice" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-facet', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"state$ | async as state\">\n  <button\n    class=\"heading\"\n    (click)=\"toggleGroup($event)\"\n    [attr.aria-expanded]=\"isExpanded\"\n    [attr.aria-label]=\"\n      'productFacetNavigation.filterBy.name' | cxTranslate: { name: facet.name }\n    \"\n  >\n    {{ facet.name }}\n    <cx-icon class=\"collapse-icon\" [type]=\"collapseIcon\"></cx-icon>\n    <cx-icon class=\"expand-icon\" [type]=\"expandIcon\"></cx-icon>\n  </button>\n\n  <div>\n    <a\n      *ngFor=\"let value of facet.values | slice: 0:state.topVisible\"\n      #facetValue\n      routerLink=\"./\"\n      [queryParams]=\"getLinkParams(value)\"\n      class=\"value\"\n      [class.selected]=\"value.selected\"\n      [cxFocus]=\"{ key: value.name }\"\n      (keydown.space)=\"openLink($any($event))\"\n      [attr.role]=\"facet.multiSelect ? 'checkbox' : null\"\n      [attr.aria-checked]=\"facet.multiSelect ? value.selected : null\"\n      attr.aria-label=\"{{\n        'productFacetNavigation.ariaLabelItemsAvailable'\n          | cxTranslate: { name: value.name, count: value.count }\n      }}\"\n    >\n      <span aria-hidden=\"true\"\n        >{{ value.name\n        }}<span aria-hidden=\"true\" class=\"count\">{{ value.count }}</span></span\n      >\n    </a>\n\n    <div class=\"more\">\n      <a\n        *ngFor=\"\n          let value of facet.values\n            | slice: state.topVisible ?? 0:state.maxVisible\n        \"\n        #facetValue\n        routerLink=\"./\"\n        [queryParams]=\"getLinkParams(value)\"\n        class=\"value\"\n        [class.selected]=\"value.selected\"\n        [cxFocus]=\"{ key: value.name }\"\n        (keydown.space)=\"openLink($any($event))\"\n      >\n        <span\n          >{{ value.name }}<span class=\"count\">{{ value.count }}</span></span\n        >\n      </a>\n\n      <button\n        *ngIf=\"\n          state.maxVisible &&\n          state.topVisible &&\n          state.maxVisible > state.topVisible\n        \"\n        (click)=\"decreaseVisibleValues()\"\n        [cxAtMessage]=\"\n          'productFacetNavigation.decreaseOptionsVisibility' | cxTranslate\n        \"\n        aria-expanded=\"true\"\n        attr.aria-label=\"{{\n          'productFacetNavigation.ariaLabelShowLess' | cxTranslate\n        }}\"\n        class=\"cx-action-link\"\n        [cxFocus]=\"{ key: 'moreorless' }\"\n      >\n        {{ 'productList.showLess' | cxTranslate }}\n      </button>\n\n      <button\n        *ngIf=\"\n          state.maxVisible &&\n          facet.values &&\n          state.maxVisible > 0 &&\n          state.maxVisible < facet.values.length\n        \"\n        (click)=\"increaseVisibleValues()\"\n        [cxAtMessage]=\"\n          'productFacetNavigation.increaseOptionsVisibility' | cxTranslate\n        \"\n        aria-expanded=\"false\"\n        attr.aria-label=\"{{\n          'productFacetNavigation.ariaLabelShowMore' | cxTranslate\n        }}\"\n        class=\"cx-action-link\"\n        [cxFocus]=\"{ key: 'moreorless' }\"\n      >\n        {{ 'productList.showMore' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: FacetService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { expandIcon: [{
                type: Input
            }], collapseIcon: [{
                type: Input
            }], isMultiSelect: [{
                type: HostBinding,
                args: ['class.multi-select']
            }], values: [{
                type: ViewChildren,
                args: ['facetValue']
            }], keyboardFocus: [{
                type: ViewChild,
                args: [FocusDirective]
            }], facet: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FacetListComponent {
    /**
     * Indicates that the facet navigation is rendered in dialog.
     */
    set isDialog(value) {
        this._isDialog = value;
        if (value) {
            this.renderer.addClass(document.body, 'modal-open');
        }
    }
    get isDialog() {
        return this._isDialog;
    }
    handleClick() {
        this.close();
    }
    constructor(facetService, elementRef, renderer) {
        this.facetService = facetService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        /** Emits when the list must close */
        this.closeList = new EventEmitter();
        /** The list of all facet and values related to the products in the list */
        this.facetList$ = this.facetService.facetList$;
        this.iconTypes = ICON_TYPE;
        this.dialogFocusConfig = {
            trap: true,
            block: true,
            focusOnEscape: true,
            autofocus: 'cx-facet',
        };
    }
    /**
     * Toggles the facet group in case it is not expanded.
     */
    expandFacetGroup(facet, ref) {
        if (!ref.isExpanded) {
            this.facetService.toggle(facet, ref.isExpanded);
        }
    }
    /**
     * Indicates that the facet group has been expanded.
     */
    isExpanded(facet) {
        return this.facetService
            .getState(facet)
            .pipe(map((value) => value.toggled === FacetGroupCollapsedState.EXPANDED));
    }
    /**
     * Indicates that the facet group has been collapsed.
     */
    isCollapsed(facet) {
        return this.facetService
            .getState(facet)
            .pipe(map((value) => value.toggled === FacetGroupCollapsedState.COLLAPSED));
    }
    close(event) {
        this.renderer.removeClass(document.body, 'modal-open');
        this.closeList.emit(event);
    }
    block(event) {
        event?.stopPropagation();
    }
}
FacetListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetListComponent, deps: [{ token: FacetService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
FacetListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: FacetListComponent, selector: "cx-facet-list", inputs: { isDialog: "isDialog" }, outputs: { closeList: "closeList" }, host: { listeners: { "click": "handleClick()" } }, ngImport: i0, template: "<section\n  class=\"inner\"\n  *ngIf=\"(facetList$ | async)?.facets as facets\"\n  [attr.aria-label]=\"'productFacetNavigation.filterBy.facet' | cxTranslate\"\n  [cxFocus]=\"isDialog ? dialogFocusConfig : {}\"\n  [tabindex]=\"-1\"\n  (esc)=\"close($event)\"\n  (click)=\"block($event)\"\n>\n  <div class=\"list-header\">\n    <h4>\n      {{ 'productList.filterBy.label' | cxTranslate }}\n    </h4>\n    <button\n      type=\"button\"\n      class=\"close\"\n      [attr.aria-label]=\"'common.close' | cxTranslate\"\n      (click)=\"close()\"\n    >\n      <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n\n  <!--\n      Here we'd like to introduce configurable facet components,\n      either by using specific configuration or generic sproutlets\n  -->\n  <cx-facet\n    *ngFor=\"let facet of facets\"\n    #facetRef\n    [facet]=\"facet\"\n    [class.expanded]=\"isExpanded(facet) | async\"\n    [class.collapsed]=\"isCollapsed(facet) | async\"\n    role=\"group\"\n    attr.aria-label=\"{{\n      'productFacetNavigation.ariaLabelItemsAvailable'\n        | cxTranslate\n          : {\n              name: facet.name,\n              count: facet?.values?.length\n            }\n    }}\"\n  ></cx-facet>\n</section>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "component", type: FacetComponent, selector: "cx-facet", inputs: ["expandIcon", "collapseIcon", "facet"] }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-facet-list', changeDetection: ChangeDetectionStrategy.OnPush, template: "<section\n  class=\"inner\"\n  *ngIf=\"(facetList$ | async)?.facets as facets\"\n  [attr.aria-label]=\"'productFacetNavigation.filterBy.facet' | cxTranslate\"\n  [cxFocus]=\"isDialog ? dialogFocusConfig : {}\"\n  [tabindex]=\"-1\"\n  (esc)=\"close($event)\"\n  (click)=\"block($event)\"\n>\n  <div class=\"list-header\">\n    <h4>\n      {{ 'productList.filterBy.label' | cxTranslate }}\n    </h4>\n    <button\n      type=\"button\"\n      class=\"close\"\n      [attr.aria-label]=\"'common.close' | cxTranslate\"\n      (click)=\"close()\"\n    >\n      <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n\n  <!--\n      Here we'd like to introduce configurable facet components,\n      either by using specific configuration or generic sproutlets\n  -->\n  <cx-facet\n    *ngFor=\"let facet of facets\"\n    #facetRef\n    [facet]=\"facet\"\n    [class.expanded]=\"isExpanded(facet) | async\"\n    [class.collapsed]=\"isCollapsed(facet) | async\"\n    role=\"group\"\n    attr.aria-label=\"{{\n      'productFacetNavigation.ariaLabelItemsAvailable'\n        | cxTranslate\n          : {\n              name: facet.name,\n              count: facet?.values?.length\n            }\n    }}\"\n  ></cx-facet>\n</section>\n" }]
        }], ctorParameters: function () { return [{ type: FacetService }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { isDialog: [{
                type: Input
            }], closeList: [{
                type: Output
            }], handleClick: [{
                type: HostListener,
                args: ['click']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FacetModule {
}
FacetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FacetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: FacetModule, declarations: [FacetComponent], imports: [AtMessageModule,
        CommonModule,
        I18nModule,
        IconModule,
        KeyboardFocusModule,
        RouterModule,
        UrlModule], exports: [FacetComponent] });
FacetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetModule, imports: [AtMessageModule,
        CommonModule,
        I18nModule,
        IconModule,
        KeyboardFocusModule,
        RouterModule,
        UrlModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AtMessageModule,
                        CommonModule,
                        I18nModule,
                        IconModule,
                        KeyboardFocusModule,
                        RouterModule,
                        UrlModule,
                    ],
                    declarations: [FacetComponent],
                    exports: [FacetComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class FacetListModule {
}
FacetListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FacetListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: FacetListModule, declarations: [FacetListComponent], imports: [CommonModule,
        I18nModule,
        IconModule,
        FacetModule,
        KeyboardFocusModule], exports: [FacetListComponent] });
FacetListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetListModule, imports: [CommonModule,
        I18nModule,
        IconModule,
        FacetModule,
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: FacetListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        I18nModule,
                        IconModule,
                        FacetModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [FacetListComponent],
                    exports: [FacetListComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductFacetNavigationComponent {
    constructor(breakpointService) {
        this.breakpointService = breakpointService;
        this.iconTypes = ICON_TYPE;
        /**
         * We delay the removal of DOM so that animations can finish playing before the
         * DOM is removed. Removing the DOM, as hidding is not enough to stop elements
         * to be focused.
         */
        this.CLOSE_DELAY = 300;
        this.open$ = new BehaviorSubject(false);
        /**
         * Emits the open state that indicates whether the facet list should be rendered.
         * This is either done instantly, or after the user triggers this by using the trigger
         * button. This driven by the visiibility of the trigger, so that the CSS drives
         * the behaviour. This can differ per breakpoint.
         *
         * There's a configurable delay for the closed state, so that the DOM is not removed
         * before some CSS animations are done.
         */
        this.isOpen$ = this.breakpointService.breakpoint$.pipe(
        // deffer emitting a new value to the next micro-task to ensure that the `hasTrigger`
        // method represents the actual UI state.
        observeOn(asapScheduler), switchMap(() => (this.hasTrigger ? this.open$ : of(true))), delayWhen((launched) => interval(launched ? 0 : this.CLOSE_DELAY)));
        /**
         * Emits the active state that indicates whether the facet list is activated. Activation
         * is related to the css, so that a animation or transition can visualize opening/closing
         * the list (i.e. dialog).
         */
        this.isActive$ = this.open$.pipe(
        // deffer emitting a new value to the next micro-task to ensure the active class is
        //  applied after the DOM is created
        observeOn(asapScheduler));
    }
    launch() {
        this.open$.next(true);
    }
    close() {
        this.open$.next(false);
        this.trigger.nativeElement.focus();
    }
    /**
     * Indicates that the facet navigation should be open explicitely by a trigger.
     * This is fully controlled by CSS, where the trigger button can be hidden
     * (display:none) for certain screen sizes.
     */
    get hasTrigger() {
        return this.trigger.nativeElement.offsetParent !== null;
    }
}
ProductFacetNavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetNavigationComponent, deps: [{ token: BreakpointService }], target: i0.ɵɵFactoryTarget.Component });
ProductFacetNavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductFacetNavigationComponent, selector: "cx-product-facet-navigation", viewQueries: [{ propertyName: "trigger", first: true, predicate: ["trigger"], descendants: true }], ngImport: i0, template: "<button\n  #trigger\n  class=\"btn btn-secondary btn-block dialog-trigger\"\n  (click)=\"launch()\"\n>\n  <cx-icon [type]=\"iconTypes.FILTER\"></cx-icon>\n  {{ 'productList.filterBy.label' | cxTranslate }}\n</button>\n\n<cx-active-facets></cx-active-facets>\n\n<cx-facet-list\n  *ngIf=\"isOpen$ | async\"\n  [isDialog]=\"hasTrigger\"\n  (closeList)=\"close()\"\n  [class.active]=\"isActive$ | async\"\n  [class.dialog]=\"hasTrigger\"\n></cx-facet-list>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: FacetListComponent, selector: "cx-facet-list", inputs: ["isDialog"], outputs: ["closeList"] }, { kind: "component", type: ActiveFacetsComponent, selector: "cx-active-facets", inputs: ["closeIcon"] }, { kind: "component", type: IconComponent, selector: "cx-icon,[cxIcon]", inputs: ["cxIcon", "type"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetNavigationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-facet-navigation', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  #trigger\n  class=\"btn btn-secondary btn-block dialog-trigger\"\n  (click)=\"launch()\"\n>\n  <cx-icon [type]=\"iconTypes.FILTER\"></cx-icon>\n  {{ 'productList.filterBy.label' | cxTranslate }}\n</button>\n\n<cx-active-facets></cx-active-facets>\n\n<cx-facet-list\n  *ngIf=\"isOpen$ | async\"\n  [isDialog]=\"hasTrigger\"\n  (closeList)=\"close()\"\n  [class.active]=\"isActive$ | async\"\n  [class.dialog]=\"hasTrigger\"\n></cx-facet-list>\n" }]
        }], ctorParameters: function () { return [{ type: BreakpointService }]; }, propDecorators: { trigger: [{
                type: ViewChild,
                args: ['trigger']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductFacetNavigationModule {
}
ProductFacetNavigationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetNavigationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductFacetNavigationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetNavigationModule, declarations: [ProductFacetNavigationComponent], imports: [CommonModule,
        FacetListModule,
        ActiveFacetsModule,
        IconModule,
        I18nModule, i1.ConfigModule], exports: [ProductFacetNavigationComponent] });
ProductFacetNavigationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetNavigationModule, imports: [CommonModule,
        FacetListModule,
        ActiveFacetsModule,
        IconModule,
        I18nModule,
        ConfigModule.withConfig({
            cmsComponents: {
                ProductRefinementComponent: {
                    component: ProductFacetNavigationComponent,
                },
            },
        })] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductFacetNavigationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FacetListModule,
                        ActiveFacetsModule,
                        IconModule,
                        I18nModule,
                        ConfigModule.withConfig({
                            cmsComponents: {
                                ProductRefinementComponent: {
                                    component: ProductFacetNavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductFacetNavigationComponent],
                    exports: [ProductFacetNavigationComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultViewConfig = {
    view: {
        defaultPageSize: 12,
        infiniteScroll: {
            active: false,
            productLimit: 0,
            showMoreButton: false,
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductListModule {
}
ProductListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductListModule, declarations: [ProductListComponent,
        ProductListItemComponent,
        ProductGridItemComponent,
        ProductViewComponent,
        ProductScrollComponent], imports: [AtMessageModule,
        CommonModule,
        FeaturesConfigModule,
        I18nModule,
        IconModule,
        InfiniteScrollModule,
        ItemCounterModule,
        ListNavigationModule,
        MediaModule,
        OutletModule,
        PageComponentModule,
        RouterModule,
        SpinnerModule,
        StarRatingModule,
        UrlModule], exports: [ProductListComponent,
        ProductListItemComponent,
        ProductGridItemComponent,
        ProductViewComponent,
        ProductScrollComponent] });
ProductListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListModule, providers: [
        provideDefaultConfig(defaultViewConfig),
        provideDefaultConfig({
            cmsComponents: {
                CMSProductListComponent: {
                    component: ProductListComponent,
                    data: {
                        composition: {
                            inner: ['ProductAddToCartComponent'],
                        },
                    },
                },
                ProductGridComponent: {
                    component: ProductListComponent,
                    data: {
                        composition: {
                            inner: ['ProductAddToCartComponent'],
                        },
                    },
                },
                SearchResultsListComponent: {
                    component: ProductListComponent,
                    data: {
                        composition: {
                            inner: ['ProductAddToCartComponent'],
                        },
                    },
                },
            },
        }),
    ], imports: [AtMessageModule,
        CommonModule,
        FeaturesConfigModule,
        I18nModule,
        IconModule,
        InfiniteScrollModule,
        ItemCounterModule,
        ListNavigationModule,
        MediaModule,
        OutletModule,
        PageComponentModule,
        RouterModule,
        SpinnerModule,
        StarRatingModule,
        UrlModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AtMessageModule,
                        CommonModule,
                        FeaturesConfigModule,
                        I18nModule,
                        IconModule,
                        InfiniteScrollModule,
                        ItemCounterModule,
                        ListNavigationModule,
                        MediaModule,
                        OutletModule,
                        PageComponentModule,
                        RouterModule,
                        SpinnerModule,
                        StarRatingModule,
                        UrlModule,
                    ],
                    providers: [
                        provideDefaultConfig(defaultViewConfig),
                        provideDefaultConfig({
                            cmsComponents: {
                                CMSProductListComponent: {
                                    component: ProductListComponent,
                                    data: {
                                        composition: {
                                            inner: ['ProductAddToCartComponent'],
                                        },
                                    },
                                },
                                ProductGridComponent: {
                                    component: ProductListComponent,
                                    data: {
                                        composition: {
                                            inner: ['ProductAddToCartComponent'],
                                        },
                                    },
                                },
                                SearchResultsListComponent: {
                                    component: ProductListComponent,
                                    data: {
                                        composition: {
                                            inner: ['ProductAddToCartComponent'],
                                        },
                                    },
                                },
                            },
                        }),
                    ],
                    declarations: [
                        ProductListComponent,
                        ProductListItemComponent,
                        ProductGridItemComponent,
                        ProductViewComponent,
                        ProductScrollComponent,
                    ],
                    exports: [
                        ProductListComponent,
                        ProductListItemComponent,
                        ProductGridItemComponent,
                        ProductViewComponent,
                        ProductScrollComponent,
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductCarouselItemComponent {
    constructor(productListItemContextSource) {
        this.productListItemContextSource = productListItemContextSource;
    }
    ngOnChanges(changes) {
        if (changes?.item) {
            this.productListItemContextSource.product$.next(this.item);
        }
    }
}
ProductCarouselItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselItemComponent, deps: [{ token: ProductListItemContextSource }], target: i0.ɵɵFactoryTarget.Component });
ProductCarouselItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductCarouselItemComponent, selector: "cx-product-carousel-item", inputs: { item: "item" }, providers: [
        ProductListItemContextSource,
        {
            provide: ProductListItemContext,
            useExisting: ProductListItemContextSource,
        },
    ], usesOnChanges: true, ngImport: i0, template: "<a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n  <cx-media\n    [container]=\"item.images?.PRIMARY\"\n    format=\"product\"\n    [alt]=\"item.name ?? ''\"\n  ></cx-media>\n  <h3 class=\"cx-product-name\">\n    {{ item.name }}\n  </h3>\n  <div class=\"price\">\n    {{ item.price?.formattedValue }}\n  </div>\n</a>\n<div class=\"actions\">\n  <ng-container cxInnerComponentsHost></ng-container>\n</div>\n", dependencies: [{ kind: "component", type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: InnerComponentsHostDirective, selector: "[cxInnerComponentsHost]" }, { kind: "pipe", type: i1.UrlPipe, name: "cxUrl" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-carousel-item', providers: [
                        ProductListItemContextSource,
                        {
                            provide: ProductListItemContext,
                            useExisting: ProductListItemContextSource,
                        },
                    ], changeDetection: ChangeDetectionStrategy.OnPush, template: "<a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n  <cx-media\n    [container]=\"item.images?.PRIMARY\"\n    format=\"product\"\n    [alt]=\"item.name ?? ''\"\n  ></cx-media>\n  <h3 class=\"cx-product-name\">\n    {{ item.name }}\n  </h3>\n  <div class=\"price\">\n    {{ item.price?.formattedValue }}\n  </div>\n</a>\n<div class=\"actions\">\n  <ng-container cxInnerComponentsHost></ng-container>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: ProductListItemContextSource }]; }, propDecorators: { item: [{
                type: Input
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductCarouselComponent {
    constructor(componentData, productService) {
        this.componentData = componentData;
        this.productService = productService;
        this.PRODUCT_SCOPE = [
            "list" /* ProductScope.LIST */,
            "price" /* ProductScope.PRICE */,
            "stock" /* ProductScope.STOCK */,
        ];
        this.componentData$ = this.componentData.data$.pipe(filter((data) => Boolean(data)));
        /**
         * returns an Observable string for the title.
         */
        this.title$ = this.componentData$.pipe(map((data) => data.title));
        /**
         * Observable that holds an Array of Observables. This is done, so that
         * the component UI could consider to lazy load the UI components when they're
         * in the viewpoint.
         */
        this.items$ = this.componentData$.pipe(map((data) => data.productCodes?.trim().split(' ') ?? []), map((codes) => codes.map((code) => this.productService.get(code, [...this.PRODUCT_SCOPE]))));
    }
}
ProductCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselComponent, deps: [{ token: CmsComponentData }, { token: i1.ProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductCarouselComponent, selector: "cx-product-carousel", ngImport: i0, template: "<cx-carousel\n  *ngIf=\"items$ | async as items\"\n  role=\"region\"\n  [attr.aria-label]=\"\n    'productCarousel.carouselLabel' | cxTranslate: { title: title$ | async }\n  \"\n  [items]=\"items\"\n  [title]=\"title$ | async\"\n  [template]=\"carouselItem\"\n  itemWidth=\"285px\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <cx-product-carousel-item [item]=\"item\"></cx-product-carousel-item>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }, { kind: "component", type: ProductCarouselItemComponent, selector: "cx-product-carousel-item", inputs: ["item"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-carousel', changeDetection: ChangeDetectionStrategy.OnPush, template: "<cx-carousel\n  *ngIf=\"items$ | async as items\"\n  role=\"region\"\n  [attr.aria-label]=\"\n    'productCarousel.carouselLabel' | cxTranslate: { title: title$ | async }\n  \"\n  [items]=\"items\"\n  [title]=\"title$ | async\"\n  [template]=\"carouselItem\"\n  itemWidth=\"285px\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <cx-product-carousel-item [item]=\"item\"></cx-product-carousel-item>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: i1.ProductService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductCarouselModule {
}
ProductCarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductCarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselModule, declarations: [ProductCarouselComponent, ProductCarouselItemComponent], imports: [CommonModule,
        CarouselModule,
        MediaModule,
        RouterModule,
        UrlModule,
        I18nModule,
        PageComponentModule], exports: [ProductCarouselComponent, ProductCarouselItemComponent] });
ProductCarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductCarouselComponent: {
                    component: ProductCarouselComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        CarouselModule,
        MediaModule,
        RouterModule,
        UrlModule,
        I18nModule,
        PageComponentModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductCarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        CarouselModule,
                        MediaModule,
                        RouterModule,
                        UrlModule,
                        I18nModule,
                        PageComponentModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductCarouselComponent: {
                                    component: ProductCarouselComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductCarouselComponent, ProductCarouselItemComponent],
                    exports: [ProductCarouselComponent, ProductCarouselItemComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductReferencesComponent {
    constructor(cmsComponentData, currentProductService, productReferenceService) {
        this.cmsComponentData = cmsComponentData;
        this.currentProductService = currentProductService;
        this.productReferenceService = productReferenceService;
        /**
         * Observable with an Array of Observables. This is done so that
         * the component UI could consider to lazy load the UI components when they're
         * in the viewpoint.
         */
        this.items$ = this.productCode$.pipe(withLatestFrom(this.componentData$), tap(([productCode, data]) => this.productReferenceService.loadProductReferences(productCode, data.productReferenceTypes)), switchMap(([productCode, data]) => this.getProductReferences(productCode, data.productReferenceTypes ?? '')));
    }
    get componentData$() {
        return this.cmsComponentData.data$.pipe(filter((data) => Boolean(data)));
    }
    /**
     * Returns an Observable String for the product code
     */
    get productCode$() {
        return this.currentProductService.getProduct().pipe(filter(isNotNullable), map((product) => product.code ?? ''), tap((_) => this.productReferenceService.cleanReferences()));
    }
    /**
     * Returns an Observable String for the title
     */
    get title$() {
        return this.componentData$.pipe(map((data) => data?.title));
    }
    /**
     * Returns an observable for product references
     */
    getProductReferences(code, referenceType) {
        return this.productReferenceService
            .getProductReferences(code, referenceType)
            .pipe(filter((references) => Boolean(references)), map((references) => references.map((reference) => of(reference.target))));
    }
}
ProductReferencesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReferencesComponent, deps: [{ token: CmsComponentData }, { token: CurrentProductService }, { token: i1.ProductReferenceService }], target: i0.ɵɵFactoryTarget.Component });
ProductReferencesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductReferencesComponent, selector: "cx-product-references", ngImport: i0, template: "<cx-carousel\n  *ngIf=\"items$ | async as items\"\n  [title]=\"title$ | async\"\n  [items]=\"items\"\n  [template]=\"carouselItem\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n    <cx-media [container]=\"item.images?.PRIMARY\" format=\"product\"></cx-media>\n    <h4>{{ item.name }}</h4>\n    <div class=\"price\">{{ item.price?.formattedValue }}</div>\n  </a>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }, { kind: "component", type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.UrlPipe, name: "cxUrl" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReferencesComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-references', changeDetection: ChangeDetectionStrategy.OnPush, template: "<cx-carousel\n  *ngIf=\"items$ | async as items\"\n  [title]=\"title$ | async\"\n  [items]=\"items\"\n  [template]=\"carouselItem\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n    <cx-media [container]=\"item.images?.PRIMARY\" format=\"product\"></cx-media>\n    <h4>{{ item.name }}</h4>\n    <div class=\"price\">{{ item.price?.formattedValue }}</div>\n  </a>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CmsComponentData }, { type: CurrentProductService }, { type: i1.ProductReferenceService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductReferencesModule {
}
ProductReferencesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReferencesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductReferencesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductReferencesModule, declarations: [ProductReferencesComponent], imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule], exports: [ProductReferencesComponent] });
ProductReferencesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReferencesModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductReferencesComponent: {
                    component: ProductReferencesComponent,
                },
            },
        }),
    ], imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReferencesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, CarouselModule, MediaModule, RouterModule, UrlModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductReferencesComponent: {
                                    component: ProductReferencesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductReferencesComponent],
                    exports: [ProductReferencesComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductImagesComponent {
    constructor(currentProductService) {
        this.currentProductService = currentProductService;
        this.mainMediaContainer = new BehaviorSubject(null);
        this.product$ = this.currentProductService
            .getProduct()
            .pipe(filter(isNotNullable), distinctUntilChanged(), tap((p) => {
            this.mainMediaContainer.next(p.images?.PRIMARY ? p.images.PRIMARY : {});
        }));
        this.thumbs$ = this.product$.pipe(map((p) => this.createThumbs(p)));
        this.mainImage$ = combineLatest([
            this.product$,
            this.mainMediaContainer,
        ]).pipe(map(([, container]) => container));
    }
    openImage(item) {
        this.mainMediaContainer.next(item);
    }
    isActive(thumbnail) {
        return this.mainMediaContainer.pipe(filter(Boolean), map((container) => {
            return (container.zoom &&
                container.zoom.url &&
                thumbnail.zoom &&
                thumbnail.zoom.url &&
                container.zoom.url === thumbnail.zoom.url);
        }));
    }
    /** find the index of the main media in the list of media */
    getActive(thumbs) {
        return this.mainMediaContainer.pipe(filter(Boolean), map((container) => {
            const current = thumbs.find((t) => t.media &&
                container.zoom &&
                t.media.container &&
                t.media.container.zoom &&
                t.media.container.zoom.url === container.zoom.url);
            return thumbs.indexOf(current);
        }));
    }
    /**
     * Return an array of CarouselItems for the product thumbnails.
     * In case there are less then 2 thumbs, we return null.
     */
    createThumbs(product) {
        if (!product.images ||
            !product.images.GALLERY ||
            product.images.GALLERY.length < 2) {
            return [];
        }
        return product.images.GALLERY.map((c) => of({ container: c }));
    }
}
ProductImagesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductImagesComponent, deps: [{ token: CurrentProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductImagesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductImagesComponent, selector: "cx-product-images", ngImport: i0, template: "<ng-container *ngIf=\"mainImage$ | async as main\">\n  <cx-media [container]=\"main\"></cx-media>\n</ng-container>\n\n<ng-container *ngIf=\"thumbs$ | async as thumbs\">\n  <cx-carousel\n    *ngIf=\"thumbs.length\"\n    class=\"thumbs\"\n    [items]=\"thumbs\"\n    itemWidth=\"120px\"\n    [hideIndicators]=\"false\"\n    [template]=\"thumb\"\n  ></cx-carousel>\n</ng-container>\n\n<ng-template #thumb let-item=\"item\">\n  <cx-media\n    [container]=\"item.container\"\n    tabindex=\"0\"\n    (focus)=\"openImage(item.container)\"\n    [class.is-active]=\"isActive(item.container) | async\"\n    format=\"product\"\n  >\n  </cx-media>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: MediaComponent, selector: "cx-media", inputs: ["container", "format", "alt", "role", "loading"], outputs: ["loaded"] }, { kind: "component", type: CarouselComponent, selector: "cx-carousel", inputs: ["title", "items", "template", "itemWidth", "hideIndicators", "indicatorIcon", "previousIcon", "nextIcon"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductImagesComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-images', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"mainImage$ | async as main\">\n  <cx-media [container]=\"main\"></cx-media>\n</ng-container>\n\n<ng-container *ngIf=\"thumbs$ | async as thumbs\">\n  <cx-carousel\n    *ngIf=\"thumbs.length\"\n    class=\"thumbs\"\n    [items]=\"thumbs\"\n    itemWidth=\"120px\"\n    [hideIndicators]=\"false\"\n    [template]=\"thumb\"\n  ></cx-carousel>\n</ng-container>\n\n<ng-template #thumb let-item=\"item\">\n  <cx-media\n    [container]=\"item.container\"\n    tabindex=\"0\"\n    (focus)=\"openImage(item.container)\"\n    [class.is-active]=\"isActive(item.container) | async\"\n    format=\"product\"\n  >\n  </cx-media>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductImagesModule {
}
ProductImagesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductImagesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductImagesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductImagesModule, declarations: [ProductImagesComponent], imports: [CommonModule,
        RouterModule,
        MediaModule,
        OutletModule,
        CarouselModule], exports: [ProductImagesComponent] });
ProductImagesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductImagesModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductImagesComponent: {
                    component: ProductImagesComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        RouterModule,
        MediaModule,
        OutletModule,
        CarouselModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductImagesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        MediaModule,
                        OutletModule,
                        CarouselModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductImagesComponent: {
                                    component: ProductImagesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductImagesComponent],
                    exports: [ProductImagesComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductIntroComponent {
    constructor(currentProductService, translationService, winRef, eventService) {
        this.currentProductService = currentProductService;
        this.translationService = translationService;
        this.winRef = winRef;
        this.eventService = eventService;
        this.product$ = this.currentProductService.getProduct();
        /**
         * Observable that checks the reviews component availability on the page.
         */
        this.areReviewsAvailable$ = merge(
        // Check if reviews component is already defined:
        defer(() => of(!!this.getReviewsComponent())), 
        // Observe EventService for reviews availability:
        this.eventService.get(ComponentCreateEvent).pipe(filter((event) => event.id === this.reviewsComponentId), mapTo(true)), this.eventService.get(ComponentDestroyEvent).pipe(filter((event) => event.id === this.reviewsComponentId), mapTo(false)));
        this.reviewsComponentId = 'ProductReviewsTabComponent';
        this.reviewsTranslationKey = `TabPanelContainer.tabs.${this.reviewsComponentId}`;
    }
    /**
     * Scroll to views component on page and click "Reviews" tab
     */
    showReviews() {
        // Use translated label for Reviews tab reference
        this.translationService
            .translate(this.reviewsTranslationKey)
            .subscribe((reviewsTabLabel) => {
            const tabsComponent = this.getTabsComponent();
            const reviewsTab = tabsComponent && this.getTabByLabel(reviewsTabLabel, tabsComponent);
            if (reviewsTab) {
                this.clickTabIfInactive(reviewsTab);
                setTimeout(() => {
                    reviewsTab.scrollIntoView({ behavior: 'smooth' });
                    reviewsTab.focus({ preventScroll: true });
                });
            }
        })
            .unsubscribe();
    }
    // NOTE: Does not currently exists as its own component
    // but part of tabs component. This is likely to change in refactor.
    /**
     * Get Reviews Component if exists on page
     */
    getReviewsComponent() {
        return this.winRef.document.querySelector('cx-product-reviews');
    }
    /**
     * Get Tabs Component if exists on page
     */
    getTabsComponent() {
        return this.winRef.document.querySelector('cx-tab-paragraph-container');
    }
    /**
     * Click to activate tab if not already active
     *
     * @param tab tab to click if needed
     */
    clickTabIfInactive(tab) {
        if (!tab.classList.contains('active') ||
            tab.classList.contains('toggled')) {
            tab.click();
        }
    }
    /**
     * Get Tab by label if exists on page
     *
     * @param label label of searched tab
     * @param tabsComponent component containing tabs
     */
    getTabByLabel(label, tabsComponent) {
        // NOTE: Reads through button tags to click on correct tab
        // There may be a better way of doing this now/after refactor
        const tabElements = tabsComponent.getElementsByTagName('button');
        // Look through button tab elements until finding tab with label
        return Array.from(tabElements).find((buttonElement) => buttonElement.innerHTML.includes(label));
    }
}
ProductIntroComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductIntroComponent, deps: [{ token: CurrentProductService }, { token: i1.TranslationService }, { token: i1.WindowRef }, { token: i1.EventService }], target: i0.ɵɵFactoryTarget.Component });
ProductIntroComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductIntroComponent, selector: "cx-product-intro", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"rating\" *ngIf=\"product?.averageRating\">\n    <cx-star-rating [rating]=\"product?.averageRating ?? 0\"></cx-star-rating>\n\n    <div class=\"count\">({{ product?.numberOfReviews }})</div>\n\n    <button\n      *ngIf=\"areReviewsAvailable$ | async\"\n      class=\"btn btn-link cx-action-link\"\n      (click)=\"showReviews()\"\n      [attr.aria-label]=\"\n        'productSummary.showReviewsDetailed'\n          | cxTranslate\n            : {\n                rating: product?.averageRating | number: '1.0-1',\n                count: product?.numberOfReviews\n              }\n      \"\n    >\n      {{ 'productSummary.showReviews' | cxTranslate }}\n    </button>\n  </div>\n  <div class=\"rating\" *ngIf=\"!product?.averageRating\">\n    {{ 'productDetails.noReviews' | cxTranslate }}\n  </div>\n  <div class=\"code\">\n    {{ 'productSummary.id' | cxTranslate }} {{ product?.code }}\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i3.DecimalPipe, name: "number" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductIntroComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-intro', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"rating\" *ngIf=\"product?.averageRating\">\n    <cx-star-rating [rating]=\"product?.averageRating ?? 0\"></cx-star-rating>\n\n    <div class=\"count\">({{ product?.numberOfReviews }})</div>\n\n    <button\n      *ngIf=\"areReviewsAvailable$ | async\"\n      class=\"btn btn-link cx-action-link\"\n      (click)=\"showReviews()\"\n      [attr.aria-label]=\"\n        'productSummary.showReviewsDetailed'\n          | cxTranslate\n            : {\n                rating: product?.averageRating | number: '1.0-1',\n                count: product?.numberOfReviews\n              }\n      \"\n    >\n      {{ 'productSummary.showReviews' | cxTranslate }}\n    </button>\n  </div>\n  <div class=\"rating\" *ngIf=\"!product?.averageRating\">\n    {{ 'productDetails.noReviews' | cxTranslate }}\n  </div>\n  <div class=\"code\">\n    {{ 'productSummary.id' | cxTranslate }} {{ product?.code }}\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: i1.TranslationService }, { type: i1.WindowRef }, { type: i1.EventService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductIntroModule {
}
ProductIntroModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductIntroModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductIntroModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductIntroModule, declarations: [ProductIntroComponent], imports: [CommonModule, I18nModule, StarRatingModule], exports: [ProductIntroComponent] });
ProductIntroModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductIntroModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductIntroComponent: {
                    component: ProductIntroComponent,
                },
            },
        }),
    ], imports: [CommonModule, I18nModule, StarRatingModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductIntroModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule, StarRatingModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductIntroComponent: {
                                    component: ProductIntroComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductIntroComponent],
                    exports: [ProductIntroComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductSummaryComponent {
    constructor(currentProductService) {
        this.currentProductService = currentProductService;
        this.outlets = ProductDetailOutlets;
        this.product$ = this.currentProductService.getProduct([
            "details" /* ProductScope.DETAILS */,
            "price" /* ProductScope.PRICE */,
        ]);
    }
}
ProductSummaryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductSummaryComponent, deps: [{ token: CurrentProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductSummaryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductSummaryComponent, selector: "cx-product-summary", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <ng-template\n    [cxOutlet]=\"outlets.PRICE\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <div\n      [attr.aria-label]=\"'productSummary.newItemPrice' | cxTranslate\"\n      class=\"price\"\n    >\n      {{ product?.price?.formattedValue }}\n    </div>\n  </ng-template>\n\n  <ng-template\n    [cxOutlet]=\"outlets.SUMMARY\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <p [innerHTML]=\"product?.summary\" class=\"summary\"></p>\n  </ng-template>\n\n  <!-- @TODO: Temp. Comment out share link while not in use by CMS -->\n  <!-- <ng-container *cxOutlet=\"outlets.SHARE\">\n        <div>\n          <a href=\"#\" class=\"share btn-link\">\n            {{ 'productSummary.share' | cxTranslate }}\n          </a>\n        </div>\n      </ng-container> -->\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductSummaryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-summary', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <ng-template\n    [cxOutlet]=\"outlets.PRICE\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <div\n      [attr.aria-label]=\"'productSummary.newItemPrice' | cxTranslate\"\n      class=\"price\"\n    >\n      {{ product?.price?.formattedValue }}\n    </div>\n  </ng-template>\n\n  <ng-template\n    [cxOutlet]=\"outlets.SUMMARY\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <p [innerHTML]=\"product?.summary\" class=\"summary\"></p>\n  </ng-template>\n\n  <!-- @TODO: Temp. Comment out share link while not in use by CMS -->\n  <!-- <ng-container *cxOutlet=\"outlets.SHARE\">\n        <div>\n          <a href=\"#\" class=\"share btn-link\">\n            {{ 'productSummary.share' | cxTranslate }}\n          </a>\n        </div>\n      </ng-container> -->\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductSummaryModule {
}
ProductSummaryModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductSummaryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductSummaryModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductSummaryModule, declarations: [ProductSummaryComponent], imports: [CommonModule, OutletModule, I18nModule], exports: [ProductSummaryComponent] });
ProductSummaryModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductSummaryModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductSummaryComponent: {
                    component: ProductSummaryComponent,
                },
            },
        }),
    ], imports: [CommonModule, OutletModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductSummaryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OutletModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductSummaryComponent: {
                                    component: ProductSummaryComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductSummaryComponent],
                    exports: [ProductSummaryComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductAttributesComponent {
    constructor(currentProductService) {
        this.currentProductService = currentProductService;
        this.product$ = this.currentProductService.getProduct("attributes" /* ProductScope.ATTRIBUTES */);
    }
}
ProductAttributesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductAttributesComponent, deps: [{ token: CurrentProductService }], target: i0.ɵɵFactoryTarget.Component });
ProductAttributesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductAttributesComponent, selector: "cx-product-attributes", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\">\n    <h2>{{ 'productDetails.specification' | cxTranslate }}</h2>\n    <table *ngFor=\"let class of product?.classifications\">\n      <th>\n        <h2>{{ class.name }}</h2>\n      </th>\n      <tr *ngFor=\"let feature of class.features\">\n        <td>{{ feature.name }}</td>\n        <td>\n          <ul>\n            <li *ngFor=\"let featureValue of feature?.featureValues\">\n              {{ featureValue?.value }}\n              <span\n                *ngIf=\"\n                  feature.featureUnit &&\n                  feature.featureUnit.symbol &&\n                  feature.featureUnit.symbol.length > 0 &&\n                  feature.featureUnit?.unitType !== '300'\n                \"\n              >\n                {{ feature.featureUnit?.symbol }}\n              </span>\n            </li>\n          </ul>\n        </td>\n      </tr>\n    </table>\n  </div>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductAttributesComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-attributes', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\">\n    <h2>{{ 'productDetails.specification' | cxTranslate }}</h2>\n    <table *ngFor=\"let class of product?.classifications\">\n      <th>\n        <h2>{{ class.name }}</h2>\n      </th>\n      <tr *ngFor=\"let feature of class.features\">\n        <td>{{ feature.name }}</td>\n        <td>\n          <ul>\n            <li *ngFor=\"let featureValue of feature?.featureValues\">\n              {{ featureValue?.value }}\n              <span\n                *ngIf=\"\n                  feature.featureUnit &&\n                  feature.featureUnit.symbol &&\n                  feature.featureUnit.symbol.length > 0 &&\n                  feature.featureUnit?.unitType !== '300'\n                \"\n              >\n                {{ feature.featureUnit?.symbol }}\n              </span>\n            </li>\n          </ul>\n        </td>\n      </tr>\n    </table>\n  </div>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductAttributesModule {
}
ProductAttributesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductAttributesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductAttributesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductAttributesModule, declarations: [ProductAttributesComponent], imports: [CommonModule, I18nModule], exports: [ProductAttributesComponent] });
ProductAttributesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductAttributesModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductSpecsTabComponent: {
                    component: ProductAttributesComponent,
                },
            },
        }),
    ], imports: [CommonModule, I18nModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductAttributesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, I18nModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductSpecsTabComponent: {
                                    component: ProductAttributesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductAttributesComponent],
                    exports: [ProductAttributesComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductDetailsTabComponent {
    constructor(currentProductService, componentData, cmsService) {
        this.currentProductService = currentProductService;
        this.componentData = componentData;
        this.cmsService = cmsService;
        this.children$ = this.componentData.data$.pipe(switchMap((data) => combineLatest((data?.children ?? '').split(' ').map((component) => this.cmsService.getComponentData(component).pipe(distinctUntilChanged(), map((child) => {
            if (!child) {
                return undefined;
            }
            if (!child.flexType) {
                child = {
                    ...child,
                    flexType: child.typeCode,
                };
            }
            return child;
        }))))));
    }
    ngOnInit() {
        this.product$ = this.currentProductService.getProduct();
    }
}
ProductDetailsTabComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsTabComponent, deps: [{ token: CurrentProductService }, { token: CmsComponentData }, { token: i1.CmsService }], target: i0.ɵɵFactoryTarget.Component });
ProductDetailsTabComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductDetailsTabComponent, selector: "cx-product-details-tab", ngImport: i0, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\" [innerHTML]=\"product?.description\"></div>\n</ng-container>\n<ng-container *ngIf=\"children$ | async as children\">\n  <ng-container *ngFor=\"let child of children\">\n    <ng-container *ngIf=\"child\">\n      <ng-template [cxOutlet]=\"child.flexType\" [cxOutletContext]=\"{}\">\n        <div class=\"container\">\n          <ng-container [cxComponentWrapper]=\"child\"></ng-container>\n        </div>\n      </ng-template>\n    </ng-container>\n  </ng-container>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: ComponentWrapperDirective, selector: "[cxComponentWrapper]", inputs: ["cxComponentWrapper"], outputs: ["cxComponentRef"] }, { kind: "directive", type: OutletDirective, selector: "[cxOutlet]", inputs: ["cxOutlet", "cxOutletContext", "cxOutletDefer", "cxComponentRef"], outputs: ["loaded", "cxComponentRefChange"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsTabComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-details-tab', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\" [innerHTML]=\"product?.description\"></div>\n</ng-container>\n<ng-container *ngIf=\"children$ | async as children\">\n  <ng-container *ngFor=\"let child of children\">\n    <ng-container *ngIf=\"child\">\n      <ng-template [cxOutlet]=\"child.flexType\" [cxOutletContext]=\"{}\">\n        <div class=\"container\">\n          <ng-container [cxComponentWrapper]=\"child\"></ng-container>\n        </div>\n      </ng-template>\n    </ng-container>\n  </ng-container>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: CmsComponentData }, { type: i1.CmsService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductDetailsTabModule {
}
ProductDetailsTabModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsTabModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductDetailsTabModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsTabModule, declarations: [ProductDetailsTabComponent], imports: [CommonModule, PageComponentModule, OutletModule], exports: [ProductDetailsTabComponent] });
ProductDetailsTabModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsTabModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductDetailsTabComponent: {
                    component: ProductDetailsTabComponent,
                },
            },
        }),
    ], imports: [CommonModule, PageComponentModule, OutletModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsTabModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, PageComponentModule, OutletModule],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductDetailsTabComponent: {
                                    component: ProductDetailsTabComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductDetailsTabComponent],
                    exports: [ProductDetailsTabComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductReviewsComponent {
    constructor(reviewService, currentProductService, fb, cd) {
        this.reviewService = reviewService;
        this.currentProductService = currentProductService;
        this.fb = fb;
        this.cd = cd;
        this.isWritingReview = false;
        // TODO: configurable
        this.initialMaxListItems = 5;
        this.product$ = this.currentProductService.getProduct();
        this.reviews$ = this.product$.pipe(filter(isNotNullable), map((p) => p.code ?? ''), distinctUntilChanged(), switchMap((productCode) => this.reviewService.getByProductCode(productCode)), tap(() => {
            this.resetReviewForm();
            this.maxListItems = this.initialMaxListItems;
        }));
    }
    initiateWriteReview() {
        this.isWritingReview = true;
        this.cd.detectChanges();
        if (this.titleInput && this.titleInput.nativeElement) {
            this.titleInput.nativeElement.focus();
        }
    }
    cancelWriteReview() {
        this.isWritingReview = false;
        this.resetReviewForm();
        this.cd.detectChanges();
        if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
            this.writeReviewButton.nativeElement.focus();
        }
    }
    setRating(rating) {
        this.reviewForm.controls.rating.setValue(rating);
    }
    submitReview(product) {
        if (this.reviewForm.valid) {
            this.addReview(product);
        }
        else {
            this.reviewForm.markAllAsTouched();
        }
    }
    addReview(product) {
        const reviewFormControls = this.reviewForm.controls;
        const review = {
            headline: reviewFormControls.title.value,
            comment: reviewFormControls.comment.value,
            rating: reviewFormControls.rating.value,
            alias: reviewFormControls.reviewerName.value,
        };
        this.reviewService.add(product.code ?? '', review);
        this.isWritingReview = false;
        this.resetReviewForm();
        this.cd.detectChanges();
        if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
            this.writeReviewButton.nativeElement.focus();
        }
    }
    resetReviewForm() {
        this.reviewForm = this.fb.group({
            title: ['', Validators.required],
            comment: ['', Validators.required],
            rating: [null, CustomFormValidators.starRatingEmpty],
            reviewerName: '',
        });
    }
}
ProductReviewsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReviewsComponent, deps: [{ token: i1.ProductReviewService }, { token: CurrentProductService }, { token: i3$1.UntypedFormBuilder }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ProductReviewsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: ProductReviewsComponent, selector: "cx-product-reviews", viewQueries: [{ propertyName: "titleInput", first: true, predicate: ["titleInput"], descendants: true }, { propertyName: "writeReviewButton", first: true, predicate: ["writeReviewButton"], descendants: true }], ngImport: i0, template: "<div class=\"container\" *ngIf=\"product$ | async as product\">\n  <h2>\n    {{ 'productDetails.reviews' | cxTranslate }} ({{ product.numberOfReviews }})\n  </h2>\n  <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n    <div class=\"header\">\n      <h3>{{ 'productReview.overallRating' | cxTranslate }}</h3>\n      <button\n        #writeReviewButton\n        class=\"btn btn-primary\"\n        (click)=\"initiateWriteReview()\"\n      >\n        {{ 'productReview.writeReview' | cxTranslate }}\n      </button>\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        class=\"rating\"\n        [rating]=\"product.averageRating\"\n      ></cx-star-rating>\n      <div class=\"rating\" *ngIf=\"!product.averageRating\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n      <ng-container *ngIf=\"reviews$ | async as reviews\">\n        <div\n          class=\"review\"\n          tabindex=\"0\"\n          *ngFor=\"let review of reviews | slice: 0:maxListItems\"\n        >\n          <div class=\"title\">{{ review.headline }}</div>\n          <cx-star-rating [rating]=\"review.rating ?? 0\"></cx-star-rating>\n          <div class=\"name\">\n            {{ review.alias ? review.alias : review.principal?.name }}\n          </div>\n          <div class=\"date\">{{ review.date | cxDate }}</div>\n          <div class=\"text\">{{ review.comment }}</div>\n        </div>\n        <div *ngIf=\"reviews.length > initialMaxListItems\">\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = reviews.length\"\n            *ngIf=\"maxListItems === initialMaxListItems\"\n          >\n            {{ 'productReview.more' | cxTranslate }}\n          </button>\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = initialMaxListItems\"\n            *ngIf=\"maxListItems !== initialMaxListItems\"\n          >\n            {{ 'productReview.less' | cxTranslate }}\n          </button>\n        </div>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #writeReview>\n    <form (ngSubmit)=\"submitReview(product)\" [formGroup]=\"reviewForm\">\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewTitle' | cxTranslate\n          }}</span>\n          <input\n            required=\"true\"\n            #titleInput\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"title\"\n          />\n          <cx-form-errors [control]=\"reviewForm.get('title')\"></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.writeYourComments' | cxTranslate\n          }}</span>\n          <textarea\n            required=\"true\"\n            class=\"form-control\"\n            rows=\"3\"\n            formControlName=\"comment\"\n          ></textarea>\n          <cx-form-errors\n            [control]=\"reviewForm.get('comment')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.rating' | cxTranslate\n          }}</span>\n          <input\n            required=\"true\"\n            type=\"number\"\n            formControlName=\"rating\"\n            class=\"rating-input\"\n          />\n          <cx-star-rating\n            tabindex=\"0\"\n            [attr.aria-label]=\"'productReview.ratingRequired' | cxTranslate\"\n            (change)=\"setRating($event)\"\n            [disabled]=\"false\"\n          ></cx-star-rating>\n          <cx-form-errors [control]=\"reviewForm.get('rating')\"></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewerName' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"reviewerName\"\n          />\n        </label>\n      </div>\n      <div class=\"form-group row\">\n        <div class=\"col-12 col-md-4\">\n          <button\n            type=\"button\"\n            class=\"btn btn-block btn-secondary\"\n            (click)=\"cancelWriteReview()\"\n          >\n            {{ 'common.cancel' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-12 col-md-4\">\n          <button type=\"submit\" class=\"btn btn-block btn-primary\">\n            {{ 'common.submit' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </form>\n  </ng-template>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i3$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i3$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i3$1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i3$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i3$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: StarRatingComponent, selector: "cx-star-rating", inputs: ["disabled", "rating"], outputs: ["change"] }, { kind: "component", type: FormErrorsComponent, selector: "cx-form-errors", inputs: ["prefix", "translationParams", "control"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i3.SlicePipe, name: "slice" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.CxDatePipe, name: "cxDate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReviewsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-product-reviews', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"container\" *ngIf=\"product$ | async as product\">\n  <h2>\n    {{ 'productDetails.reviews' | cxTranslate }} ({{ product.numberOfReviews }})\n  </h2>\n  <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n    <div class=\"header\">\n      <h3>{{ 'productReview.overallRating' | cxTranslate }}</h3>\n      <button\n        #writeReviewButton\n        class=\"btn btn-primary\"\n        (click)=\"initiateWriteReview()\"\n      >\n        {{ 'productReview.writeReview' | cxTranslate }}\n      </button>\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        class=\"rating\"\n        [rating]=\"product.averageRating\"\n      ></cx-star-rating>\n      <div class=\"rating\" *ngIf=\"!product.averageRating\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n      <ng-container *ngIf=\"reviews$ | async as reviews\">\n        <div\n          class=\"review\"\n          tabindex=\"0\"\n          *ngFor=\"let review of reviews | slice: 0:maxListItems\"\n        >\n          <div class=\"title\">{{ review.headline }}</div>\n          <cx-star-rating [rating]=\"review.rating ?? 0\"></cx-star-rating>\n          <div class=\"name\">\n            {{ review.alias ? review.alias : review.principal?.name }}\n          </div>\n          <div class=\"date\">{{ review.date | cxDate }}</div>\n          <div class=\"text\">{{ review.comment }}</div>\n        </div>\n        <div *ngIf=\"reviews.length > initialMaxListItems\">\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = reviews.length\"\n            *ngIf=\"maxListItems === initialMaxListItems\"\n          >\n            {{ 'productReview.more' | cxTranslate }}\n          </button>\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = initialMaxListItems\"\n            *ngIf=\"maxListItems !== initialMaxListItems\"\n          >\n            {{ 'productReview.less' | cxTranslate }}\n          </button>\n        </div>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #writeReview>\n    <form (ngSubmit)=\"submitReview(product)\" [formGroup]=\"reviewForm\">\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewTitle' | cxTranslate\n          }}</span>\n          <input\n            required=\"true\"\n            #titleInput\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"title\"\n          />\n          <cx-form-errors [control]=\"reviewForm.get('title')\"></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.writeYourComments' | cxTranslate\n          }}</span>\n          <textarea\n            required=\"true\"\n            class=\"form-control\"\n            rows=\"3\"\n            formControlName=\"comment\"\n          ></textarea>\n          <cx-form-errors\n            [control]=\"reviewForm.get('comment')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.rating' | cxTranslate\n          }}</span>\n          <input\n            required=\"true\"\n            type=\"number\"\n            formControlName=\"rating\"\n            class=\"rating-input\"\n          />\n          <cx-star-rating\n            tabindex=\"0\"\n            [attr.aria-label]=\"'productReview.ratingRequired' | cxTranslate\"\n            (change)=\"setRating($event)\"\n            [disabled]=\"false\"\n          ></cx-star-rating>\n          <cx-form-errors [control]=\"reviewForm.get('rating')\"></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewerName' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"reviewerName\"\n          />\n        </label>\n      </div>\n      <div class=\"form-group row\">\n        <div class=\"col-12 col-md-4\">\n          <button\n            type=\"button\"\n            class=\"btn btn-block btn-secondary\"\n            (click)=\"cancelWriteReview()\"\n          >\n            {{ 'common.cancel' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-12 col-md-4\">\n          <button type=\"submit\" class=\"btn btn-block btn-primary\">\n            {{ 'common.submit' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </form>\n  </ng-template>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.ProductReviewService }, { type: CurrentProductService }, { type: i3$1.UntypedFormBuilder }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { titleInput: [{
                type: ViewChild,
                args: ['titleInput', { static: false }]
            }], writeReviewButton: [{
                type: ViewChild,
                args: ['writeReviewButton', { static: false }]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductReviewsModule {
}
ProductReviewsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReviewsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductReviewsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductReviewsModule, declarations: [ProductReviewsComponent], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule,
        I18nModule,
        StarRatingModule,
        FormErrorsModule], exports: [ProductReviewsComponent] });
ProductReviewsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReviewsModule, providers: [
        provideDefaultConfig({
            cmsComponents: {
                ProductReviewsTabComponent: {
                    component: ProductReviewsComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule,
        I18nModule,
        StarRatingModule,
        FormErrorsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductReviewsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        FormsModule,
                        I18nModule,
                        StarRatingModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        provideDefaultConfig({
                            cmsComponents: {
                                ProductReviewsTabComponent: {
                                    component: ProductReviewsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductReviewsComponent],
                    exports: [ProductReviewsComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductTabsModule {
}
ProductTabsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductTabsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductTabsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductTabsModule, imports: [ProductAttributesModule,
        ProductDetailsTabModule,
        ProductReviewsModule] });
ProductTabsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductTabsModule, imports: [ProductAttributesModule,
        ProductDetailsTabModule,
        ProductReviewsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductTabsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ProductAttributesModule,
                        ProductDetailsTabModule,
                        ProductReviewsModule,
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class StockNotificationDialogComponent {
    handleClick(event) {
        if (event.target.tagName === this.el.nativeElement.tagName) {
            this.close('Cross click');
        }
    }
    constructor(interestsService, launchDialogService, el) {
        this.interestsService = interestsService;
        this.launchDialogService = launchDialogService;
        this.el = el;
        this.subscription = new Subscription();
        this.enabledPrefs = [];
        this.focusConfig = {
            trap: true,
            block: true,
            autofocus: 'button',
            focusOnEscape: true,
        };
    }
    close(reason) {
        this.launchDialogService.closeDialog(reason);
    }
    ngOnInit() {
        this.subscription.add(this.launchDialogService.data$.subscribe((data) => {
            this.init(data.subscribeSuccess$, data.enabledPrefs);
        }));
    }
    init(subscribeSuccess$, enabledPrefs) {
        this.subscribeSuccess$ = subscribeSuccess$;
        this.enabledPrefs = enabledPrefs;
    }
    ngOnDestroy() {
        if (this.subscribeSuccess$) {
            this.subscribeSuccess$
                .subscribe((success) => {
                if (success) {
                    this.interestsService.resetAddInterestState();
                }
            })
                .unsubscribe();
        }
        this.subscription.unsubscribe();
    }
}
StockNotificationDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StockNotificationDialogComponent, deps: [{ token: i1.UserInterestsService }, { token: LaunchDialogService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
StockNotificationDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: StockNotificationDialogComponent, selector: "cx-stock-notification-dialog", host: { listeners: { "click": "handleClick($event)" } }, ngImport: i0, template: "<div\n  class=\"cx-stock-notification-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-stock-notification-container\">\n    <div class=\"cx-dialog-header cx-modal-header\">\n      <div class=\"cx-dialog-title modal-title\">\n        {{ 'stockNotification.subscriptionDialog.header' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        class=\"close\"\n        tabindex=\"-1\"\n        (click)=\"close('Button clicked')\"\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n\n    <ng-container *ngIf=\"subscribeSuccess$ | async; else loading\">\n      <div\n        role=\"status\"\n        [attr.aria-label]=\"'common.loaded' | cxTranslate\"\n      ></div>\n      <div class=\"cx-dialog-body modal-body\">\n        <div class=\"cx-stock-notification-content\">\n          <p class=\"cx-stock-notification-text\">\n            {{\n              'stockNotification.subscriptionDialog.notifiedPrefix'\n                | cxTranslate\n            }}\n          </p>\n          <p *ngFor=\"let preference of enabledPrefs\" class=\"channels\">\n            <span>{{ preference.channel }}</span\n            ><span *ngIf=\"preference.value\">{{ ': ' + preference.value }}</span>\n          </p>\n          <p class=\"cx-stock-notification-text\">\n            {{\n              'stockNotification.subscriptionDialog.notifiedSuffix'\n                | cxTranslate\n            }}\n          </p>\n          <p class=\"cx-stock-notification-text\">\n            {{\n              'stockNotification.subscriptionDialog.manageChannelsPrefix'\n                | cxTranslate\n            }}\n            <a\n              (click)=\"close('Link clicked')\"\n              [routerLink]=\"{ cxRoute: 'notificationPreference' } | cxUrl\"\n              class=\"link-prefs cx-stock-notification-link\"\n            >\n              {{\n                'stockNotification.subscriptionDialog.manageChannelsLink'\n                  | cxTranslate\n              }}</a\n            >\n            {{\n              'stockNotification.subscriptionDialog.manageChannelsSuffix'\n                | cxTranslate\n            }}\n          </p>\n\n          <p class=\"cx-stock-notification-text\">\n            {{\n              'stockNotification.subscriptionDialog.manageSubscriptionsPrefix'\n                | cxTranslate\n            }}\n            <a\n              (click)=\"close('Link clicked')\"\n              [routerLink]=\"{ cxRoute: 'myInterests' } | cxUrl\"\n              class=\"link-interests cx-stock-notification-link\"\n            >\n              {{\n                'stockNotification.subscriptionDialog.manageSubscriptionsLink'\n                  | cxTranslate\n              }}</a\n            >\n            {{\n              'stockNotification.subscriptionDialog.manageSubscriptionsSuffix'\n                | cxTranslate\n            }}\n          </p>\n        </div>\n      </div>\n      <div class=\"cx-modal-footer\">\n        <div class=\"row\">\n          <div\n            class=\"\n              cx-dialog-actions\n              col-sm-12 col-md-4\n              offset-md-8\n              col-lg-3\n              offset-lg-9\n            \"\n          >\n            <button\n              class=\"btn btn-primary btn-block btn-ok\"\n              type=\"button\"\n              (click)=\"close('Button clicked')\"\n            >\n              {{ 'stockNotification.subscriptionDialog.okBtn' | cxTranslate }}\n            </button>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n\n  <ng-template #loading>\n    <div class=\"cx-dialog-body modal-body\">\n      <p>\n        {{ 'stockNotification.subscriptionDialog.subscribing' | cxTranslate }}\n      </p>\n      <div class=\"cx-dialog-row\">\n        <div class=\"col-sm-12\">\n          <cx-spinner></cx-spinner>\n        </div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n", dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "directive", type: FocusDirective, selector: "[cxFocus]", inputs: ["cxFocus"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.UrlPipe, name: "cxUrl" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StockNotificationDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-stock-notification-dialog', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n  class=\"cx-stock-notification-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-stock-notification-container\">\n    <div class=\"cx-dialog-header cx-modal-header\">\n      <div class=\"cx-dialog-title modal-title\">\n        {{ 'stockNotification.subscriptionDialog.header' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        [attr.aria-label]=\"'common.close' | cxTranslate\"\n        class=\"close\"\n        tabindex=\"-1\"\n        (click)=\"close('Button clicked')\"\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n\n    <ng-container *ngIf=\"subscribeSuccess$ | async; else loading\">\n      <div\n        role=\"status\"\n        [attr.aria-label]=\"'common.loaded' | cxTranslate\"\n      ></div>\n      <div class=\"cx-dialog-body modal-body\">\n        <div class=\"cx-stock-notification-content\">\n          <p class=\"cx-stock-notification-text\">\n            {{\n              'stockNotification.subscriptionDialog.notifiedPrefix'\n                | cxTranslate\n            }}\n          </p>\n          <p *ngFor=\"let preference of enabledPrefs\" class=\"channels\">\n            <span>{{ preference.channel }}</span\n            ><span *ngIf=\"preference.value\">{{ ': ' + preference.value }}</span>\n          </p>\n          <p class=\"cx-stock-notification-text\">\n            {{\n              'stockNotification.subscriptionDialog.notifiedSuffix'\n                | cxTranslate\n            }}\n          </p>\n          <p class=\"cx-stock-notification-text\">\n            {{\n              'stockNotification.subscriptionDialog.manageChannelsPrefix'\n                | cxTranslate\n            }}\n            <a\n              (click)=\"close('Link clicked')\"\n              [routerLink]=\"{ cxRoute: 'notificationPreference' } | cxUrl\"\n              class=\"link-prefs cx-stock-notification-link\"\n            >\n              {{\n                'stockNotification.subscriptionDialog.manageChannelsLink'\n                  | cxTranslate\n              }}</a\n            >\n            {{\n              'stockNotification.subscriptionDialog.manageChannelsSuffix'\n                | cxTranslate\n            }}\n          </p>\n\n          <p class=\"cx-stock-notification-text\">\n            {{\n              'stockNotification.subscriptionDialog.manageSubscriptionsPrefix'\n                | cxTranslate\n            }}\n            <a\n              (click)=\"close('Link clicked')\"\n              [routerLink]=\"{ cxRoute: 'myInterests' } | cxUrl\"\n              class=\"link-interests cx-stock-notification-link\"\n            >\n              {{\n                'stockNotification.subscriptionDialog.manageSubscriptionsLink'\n                  | cxTranslate\n              }}</a\n            >\n            {{\n              'stockNotification.subscriptionDialog.manageSubscriptionsSuffix'\n                | cxTranslate\n            }}\n          </p>\n        </div>\n      </div>\n      <div class=\"cx-modal-footer\">\n        <div class=\"row\">\n          <div\n            class=\"\n              cx-dialog-actions\n              col-sm-12 col-md-4\n              offset-md-8\n              col-lg-3\n              offset-lg-9\n            \"\n          >\n            <button\n              class=\"btn btn-primary btn-block btn-ok\"\n              type=\"button\"\n              (click)=\"close('Button clicked')\"\n            >\n              {{ 'stockNotification.subscriptionDialog.okBtn' | cxTranslate }}\n            </button>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n\n  <ng-template #loading>\n    <div class=\"cx-dialog-body modal-body\">\n      <p>\n        {{ 'stockNotification.subscriptionDialog.subscribing' | cxTranslate }}\n      </p>\n      <div class=\"cx-dialog-row\">\n        <div class=\"col-sm-12\">\n          <cx-spinner></cx-spinner>\n        </div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.UserInterestsService }, { type: LaunchDialogService }, { type: i0.ElementRef }]; }, propDecorators: { handleClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class StockNotificationComponent {
    constructor(currentProductService, globalMessageService, translationService, interestsService, notificationPrefService, userIdService, launchDialogService, vcr) {
        this.currentProductService = currentProductService;
        this.globalMessageService = globalMessageService;
        this.translationService = translationService;
        this.interestsService = interestsService;
        this.notificationPrefService = notificationPrefService;
        this.userIdService = userIdService;
        this.launchDialogService = launchDialogService;
        this.vcr = vcr;
        this.anonymous = true;
        this.enabledPrefs = [];
        this.subscriptions = new Subscription();
    }
    ngOnInit() {
        this.outOfStock$ = combineLatest([
            this.currentProductService.getProduct().pipe(filter(isNotNullable)),
            this.userIdService.getUserId(),
        ]).pipe(tap(([product, userId]) => {
            this.productCode = product.code ?? '';
            if (userId !== OCC_USER_ID_ANONYMOUS) {
                this.anonymous = false;
                this.notificationPrefService.loadPreferences();
                this.interestsService.loadProductInterests(undefined, undefined, undefined, product.code, NotificationType.BACK_IN_STOCK);
            }
        }), map(([product]) => !!product.stock && product.stock.stockLevelStatus === 'outOfStock'));
        this.hasProductInterests$ = this.interestsService
            .getProductInterests()
            .pipe(map((interests) => !!interests.results && interests.results.length === 1));
        this.subscribeSuccess$ =
            this.interestsService.getAddProductInterestSuccess();
        this.isRemoveInterestLoading$ =
            this.interestsService.getRemoveProdutInterestLoading();
        this.prefsEnabled$ = this.notificationPrefService
            .getEnabledPreferences()
            .pipe(tap((prefs) => (this.enabledPrefs = prefs)), map((prefs) => prefs.length > 0));
        this.subscriptions.add(this.interestsService.getAddProductInterestError().subscribe((error) => {
            if (error) {
                this.onInterestAddingError();
            }
        }));
        this.subscriptions.add(this.interestsService
            .getRemoveProdutInterestSuccess()
            .subscribe((success) => {
            if (success) {
                this.onInterestRemovingSuccess();
            }
        }));
    }
    subscribe() {
        this.openDialog();
        this.interestsService.addProductInterest(this.productCode, NotificationType.BACK_IN_STOCK);
    }
    unsubscribe() {
        this.interestsService.removeProdutInterest({
            product: {
                code: this.productCode,
            },
            productInterestEntry: [
                {
                    interestType: NotificationType.BACK_IN_STOCK,
                },
            ],
        }, true);
    }
    onInterestRemovingSuccess() {
        this.subscriptions.add(this.translationService
            .translate('stockNotification.unsubscribeSuccess')
            .pipe(first())
            .subscribe((text) => this.globalMessageService.add(text, GlobalMessageType.MSG_TYPE_INFO)));
        this.interestsService.resetRemoveInterestState();
    }
    onInterestAddingError() {
        this.launchDialogService.closeDialog('Interests error');
        this.interestsService.resetAddInterestState();
    }
    openDialog() {
        const modalInstanceData = {
            subscribeSuccess$: this.subscribeSuccess$,
            enabledPrefs: this.enabledPrefs,
        };
        const dialog = this.launchDialogService.openDialog("STOCK_NOTIFICATION" /* LAUNCH_CALLER.STOCK_NOTIFICATION */, this.element, this.vcr, modalInstanceData);
        if (dialog) {
            dialog.pipe(take(1)).subscribe();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.interestsService.clearProductInterests();
        this.notificationPrefService.clearPreferences();
    }
}
StockNotificationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StockNotificationComponent, deps: [{ token: CurrentProductService }, { token: i1.GlobalMessageService }, { token: i1.TranslationService }, { token: i1.UserInterestsService }, { token: i1.UserNotificationPreferenceService }, { token: i1.UserIdService }, { token: LaunchDialogService }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component });
StockNotificationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: StockNotificationComponent, selector: "cx-stock-notification", viewQueries: [{ propertyName: "element", first: true, predicate: ["element"], descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"outOfStock$ | async\">\n  <ng-container *ngIf=\"!(hasProductInterests$ | async); else stopNotify\">\n    <ng-container *ngIf=\"prefsEnabled$ | async; else disableNotify\">\n      <div class=\"stock-notification-notes\">\n        <p>{{ 'stockNotification.getNotified' | cxTranslate }}</p>\n      </div>\n      <button\n        class=\"btn btn-primary btn-block btn-notify\"\n        type=\"button\"\n        (click)=\"subscribe()\"\n      >\n        {{ 'stockNotification.notifyMe' | cxTranslate }}\n      </button>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n<ng-template #disableNotify>\n  <div class=\"stock-notification-notes\" id=\"outOfStockMessage\">\n    <p>\n      <ng-container *ngIf=\"anonymous; else loggedIn\">\n        <a [routerLink]=\"{ cxRoute: 'login' } | cxUrl\">\n          {{ 'miniLogin.signInRegister' | cxTranslate }}</a\n        >\n        {{ 'stockNotification.getNotifySuffix' | cxTranslate }}<br />\n      </ng-container>\n      <ng-template #loggedIn>\n        {{ 'stockNotification.getNotify' | cxTranslate }}<br />\n        {{ 'stockNotification.activateChannelsPrefix' | cxTranslate }}\n        <a [routerLink]=\"{ cxRoute: 'notificationPreference' } | cxUrl\">{{\n          'stockNotification.channelsLink' | cxTranslate\n        }}</a\n        >{{ 'stockNotification.activateChannelsSuffix' | cxTranslate }}\n      </ng-template>\n    </p>\n  </div>\n  <button\n    class=\"btn btn-primary btn-block btn-notify\"\n    type=\"button\"\n    [attr.disabled]=\"anonymous ? true : null\"\n    aria-describedby=\"outOfStockMessage\"\n    (click)=\"subscribe()\"\n  >\n    {{ 'stockNotification.notifyMe' | cxTranslate }}\n  </button>\n</ng-template>\n\n<ng-template #stopNotify>\n  <ng-container *ngIf=\"!(isRemoveInterestLoading$ | async); else loading\">\n    <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n    <div class=\"stock-notification-notes\">\n      <p>{{ 'stockNotification.notified' | cxTranslate }}</p>\n    </div>\n    <button\n      class=\"btn btn-primary btn-block btn-stop-notify\"\n      type=\"button\"\n      (click)=\"unsubscribe()\"\n    >\n      {{ 'stockNotification.stopNotify' | cxTranslate }}\n    </button>\n  </ng-container>\n</ng-template>\n\n<ng-template #loading>\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"cx-dialog-row\">\n      <div class=\"col-sm-12\">\n        <cx-spinner></cx-spinner>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$2.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: SpinnerComponent, selector: "cx-spinner" }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.TranslatePipe, name: "cxTranslate" }, { kind: "pipe", type: i1.UrlPipe, name: "cxUrl" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StockNotificationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cx-stock-notification', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"outOfStock$ | async\">\n  <ng-container *ngIf=\"!(hasProductInterests$ | async); else stopNotify\">\n    <ng-container *ngIf=\"prefsEnabled$ | async; else disableNotify\">\n      <div class=\"stock-notification-notes\">\n        <p>{{ 'stockNotification.getNotified' | cxTranslate }}</p>\n      </div>\n      <button\n        class=\"btn btn-primary btn-block btn-notify\"\n        type=\"button\"\n        (click)=\"subscribe()\"\n      >\n        {{ 'stockNotification.notifyMe' | cxTranslate }}\n      </button>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n<ng-template #disableNotify>\n  <div class=\"stock-notification-notes\" id=\"outOfStockMessage\">\n    <p>\n      <ng-container *ngIf=\"anonymous; else loggedIn\">\n        <a [routerLink]=\"{ cxRoute: 'login' } | cxUrl\">\n          {{ 'miniLogin.signInRegister' | cxTranslate }}</a\n        >\n        {{ 'stockNotification.getNotifySuffix' | cxTranslate }}<br />\n      </ng-container>\n      <ng-template #loggedIn>\n        {{ 'stockNotification.getNotify' | cxTranslate }}<br />\n        {{ 'stockNotification.activateChannelsPrefix' | cxTranslate }}\n        <a [routerLink]=\"{ cxRoute: 'notificationPreference' } | cxUrl\">{{\n          'stockNotification.channelsLink' | cxTranslate\n        }}</a\n        >{{ 'stockNotification.activateChannelsSuffix' | cxTranslate }}\n      </ng-template>\n    </p>\n  </div>\n  <button\n    class=\"btn btn-primary btn-block btn-notify\"\n    type=\"button\"\n    [attr.disabled]=\"anonymous ? true : null\"\n    aria-describedby=\"outOfStockMessage\"\n    (click)=\"subscribe()\"\n  >\n    {{ 'stockNotification.notifyMe' | cxTranslate }}\n  </button>\n</ng-template>\n\n<ng-template #stopNotify>\n  <ng-container *ngIf=\"!(isRemoveInterestLoading$ | async); else loading\">\n    <div role=\"status\" [attr.aria-label]=\"'common.loaded' | cxTranslate\"></div>\n    <div class=\"stock-notification-notes\">\n      <p>{{ 'stockNotification.notified' | cxTranslate }}</p>\n    </div>\n    <button\n      class=\"btn btn-primary btn-block btn-stop-notify\"\n      type=\"button\"\n      (click)=\"unsubscribe()\"\n    >\n      {{ 'stockNotification.stopNotify' | cxTranslate }}\n    </button>\n  </ng-container>\n</ng-template>\n\n<ng-template #loading>\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"cx-dialog-row\">\n      <div class=\"col-sm-12\">\n        <cx-spinner></cx-spinner>\n      </div>\n    </div>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: CurrentProductService }, { type: i1.GlobalMessageService }, { type: i1.TranslationService }, { type: i1.UserInterestsService }, { type: i1.UserNotificationPreferenceService }, { type: i1.UserIdService }, { type: LaunchDialogService }, { type: i0.ViewContainerRef }]; }, propDecorators: { element: [{
                type: ViewChild,
                args: ['element']
            }] } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultStockNotificationLayoutConfig = {
    launch: {
        STOCK_NOTIFICATION: {
            inlineRoot: true,
            component: StockNotificationDialogComponent,
            dialogType: DIALOG_TYPE.DIALOG,
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class StockNotificationModule {
}
StockNotificationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StockNotificationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
StockNotificationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: StockNotificationModule, declarations: [StockNotificationComponent, StockNotificationDialogComponent], imports: [CommonModule,
        RouterModule,
        I18nModule,
        SpinnerModule,
        UrlModule,
        KeyboardFocusModule], exports: [StockNotificationComponent, StockNotificationDialogComponent] });
StockNotificationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StockNotificationModule, providers: [
        provideDefaultConfig(defaultStockNotificationLayoutConfig),
        provideDefaultConfig({
            cmsComponents: {
                StockNotificationComponent: {
                    component: StockNotificationComponent,
                },
            },
        }),
    ], imports: [CommonModule,
        RouterModule,
        I18nModule,
        SpinnerModule,
        UrlModule,
        KeyboardFocusModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: StockNotificationModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [StockNotificationComponent, StockNotificationDialogComponent],
                    imports: [
                        CommonModule,
                        RouterModule,
                        I18nModule,
                        SpinnerModule,
                        UrlModule,
                        KeyboardFocusModule,
                    ],
                    providers: [
                        provideDefaultConfig(defaultStockNotificationLayoutConfig),
                        provideDefaultConfig({
                            cmsComponents: {
                                StockNotificationComponent: {
                                    component: StockNotificationComponent,
                                },
                            },
                        }),
                    ],
                    exports: [StockNotificationComponent, StockNotificationDialogComponent],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Guards the _login_ route.
 *
 * Takes care of routing the user to a auth server login page (if implicit or code flow is used).
 * In case of Resource Owner Password Flow just renders the page as normal CMS page.
 */
class LoginGuard {
    constructor(authService, authConfigService, cmsPageGuard) {
        this.authService = authService;
        this.authConfigService = authConfigService;
        this.cmsPageGuard = cmsPageGuard;
    }
    canActivate(route, state) {
        return this.authService.isUserLoggedIn().pipe(take(1), switchMap((isUserLoggedIn) => {
            if (this.authConfigService.getOAuthFlow() ===
                OAuthFlow.ResourceOwnerPasswordFlow ||
                isUserLoggedIn) {
                return this.cmsPageGuard.canActivate(route, state);
            }
            else {
                // This method can trigger redirect to OAuth server that's why we don't return anything in this case
                const redirected = this.authService.loginWithRedirect();
                if (!redirected) {
                    return of(false);
                }
                return EMPTY;
            }
        }));
    }
}
LoginGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LoginGuard, deps: [{ token: i1.AuthService }, { token: i1.AuthConfigService }, { token: CmsPageGuard }], target: i0.ɵɵFactoryTarget.Injectable });
LoginGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LoginGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LoginGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.AuthService }, { type: i1.AuthConfigService }, { type: CmsPageGuard }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * This module enables to quickly switch from Resource Owner Password Flow
 * to Implicit Flow or Authorization Code Flow. The `login` route in this case will be
 * responsible for initalizing the redirect to OAuth server to login.
 *
 * Instead of manually invoking OAuth redirect you only have to redirect to `login` page.
 */
class LoginRouteModule {
}
LoginRouteModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LoginRouteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LoginRouteModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: LoginRouteModule, imports: [PageLayoutModule, i1$2.RouterModule] });
LoginRouteModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LoginRouteModule, imports: [PageLayoutModule,
        RouterModule.forChild([
            {
                // @ts-ignore
                path: null,
                canActivate: [LoginGuard],
                component: PageLayoutComponent,
                data: { cxRoute: 'login' },
            },
        ])] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LoginRouteModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        PageLayoutModule,
                        RouterModule.forChild([
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [LoginGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'login' },
                            },
                        ]),
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Guards the _logout_ route.
 *
 * Takes care of routing the user to a logout page (if available) or redirects to
 * the homepage. If the homepage is protected, the user is redirected
 * to the login route instead.
 */
class LogoutGuard {
    constructor(auth, cms, semanticPathService, protectedRoutes, router) {
        this.auth = auth;
        this.cms = cms;
        this.semanticPathService = semanticPathService;
        this.protectedRoutes = protectedRoutes;
        this.router = router;
    }
    canActivate() {
        /**
         * First we want to complete logout process before redirecting to logout page
         * We want to avoid errors like `token is no longer valid`
         */
        return from(this.logout()).pipe(switchMap(() => {
            return this.cms
                .hasPage({
                id: this.semanticPathService.get('logout') ?? '',
                type: PageType.CONTENT_PAGE,
            })
                .pipe(map((hasPage) => {
                if (!hasPage) {
                    return this.getRedirectUrl();
                }
                // TODO(#9385): Use CMS page guard here.
                return hasPage;
            }));
        }));
    }
    logout() {
        return this.auth.coreLogout();
    }
    /**
     * Whenever there is no specific "logout" page configured in the CMS,
     * we redirect after the user is logged out.
     *
     * The user gets redirected to the homepage, unless the homepage is protected
     * (in case of a closed shop). We'll redirect to the login page instead.
     */
    getRedirectUrl() {
        const cxRoute = this.protectedRoutes.shouldProtect ? 'login' : 'home';
        return this.router.parseUrl(this.semanticPathService.get(cxRoute) ?? '');
    }
}
LogoutGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LogoutGuard, deps: [{ token: i1.AuthService }, { token: i1.CmsService }, { token: i1.SemanticPathService }, { token: i1.ProtectedRoutesService }, { token: i1$2.Router }], target: i0.ɵɵFactoryTarget.Injectable });
LogoutGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LogoutGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LogoutGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.AuthService }, { type: i1.CmsService }, { type: i1.SemanticPathService }, { type: i1.ProtectedRoutesService }, { type: i1$2.Router }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class LogoutModule {
}
LogoutModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LogoutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LogoutModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: LogoutModule, imports: [PageLayoutModule, i1$2.RouterModule] });
LogoutModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LogoutModule, imports: [PageLayoutModule,
        RouterModule.forChild([
            {
                // @ts-ignore
                path: null,
                canActivate: [LogoutGuard, CmsPageGuard],
                component: PageLayoutComponent,
                data: { cxRoute: 'logout' },
            },
        ])] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: LogoutModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        PageLayoutModule,
                        RouterModule.forChild([
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [LogoutGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'logout' },
                            },
                        ]),
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class UserComponentModule {
}
UserComponentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: UserComponentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
UserComponentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: UserComponentModule, imports: [LogoutModule,
        LoginRouteModule,
        ReactiveFormsModule,
        RouterModule,
        UrlModule] });
UserComponentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: UserComponentModule, imports: [LogoutModule,
        LoginRouteModule,
        ReactiveFormsModule,
        RouterModule,
        UrlModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: UserComponentModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        LogoutModule,
                        LoginRouteModule,
                        ReactiveFormsModule,
                        RouterModule,
                        UrlModule,
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
function getProductDetailsUrlMatcherFactory(service, defaultMatcherFactory) {
    const factory = (route) => {
        const defaultMatcher = defaultMatcherFactory(route);
        const suffixPDPMatcher = getSuffixUrlMatcher({
            marker: 'p',
            paramName: 'productCode',
        });
        return service.getCombined([defaultMatcher, suffixPDPMatcher]);
    };
    return factory;
}
/**
 * Injection token with url matcher factory for PDP.
 * The provided url matcher matches both:
 * - the configured `paths` from routing config and
 * - custom pattern  `** / p / :productCode`
 *
 * If the this matcher doesn't fit the requirements, it can be replaced with the DEFAULT_URL_MATCHER
 * or additional matchers can be added for a specific route.
 *
 * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
 */
const PRODUCT_DETAILS_URL_MATCHER = new InjectionToken('PRODUCT_DETAILS_URL_MATCHER', {
    providedIn: 'root',
    factory: () => getProductDetailsUrlMatcherFactory(inject(UrlMatcherService), inject(DEFAULT_URL_MATCHER)),
});

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductDetailsPageModule {
}
ProductDetailsPageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsPageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductDetailsPageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsPageModule, imports: [i1$2.RouterModule] });
ProductDetailsPageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsPageModule, providers: [
        provideDefaultConfig({
            routing: {
                routes: {
                    product: {
                        matchers: [PRODUCT_DETAILS_URL_MATCHER],
                    },
                },
            },
        }),
    ], imports: [RouterModule.forChild([
            {
                // @ts-ignore
                path: null,
                canActivate: [CmsPageGuard],
                component: PageLayoutComponent,
                data: { cxRoute: 'product' },
            },
        ])] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductDetailsPageModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        RouterModule.forChild([
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'product' },
                            },
                        ]),
                    ],
                    providers: [
                        provideDefaultConfig({
                            routing: {
                                routes: {
                                    product: {
                                        matchers: [PRODUCT_DETAILS_URL_MATCHER],
                                    },
                                },
                            },
                        }),
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
function getProductListingUrlMatcherFactory(service, defaultMatcherFactory) {
    const factory = (route) => {
        const defaultMatcher = defaultMatcherFactory(route);
        const suffixPLPMatcher = getSuffixUrlMatcher({
            marker: 'c',
            paramName: 'categoryCode',
        });
        return service.getCombined([defaultMatcher, suffixPLPMatcher]);
    };
    return factory;
}
/**
 * Injection token with url matcher factory for PLP.
 * The provided url matcher matches both:
 * - the configured `paths` from routing config and
 * - custom pattern  `** / c / :categoryCode`
 *
 * If the this matcher doesn't fit the requirements, it can be replaced with the DEFAULT_URL_MATCHER
 * or additional matchers can be added for a specific route.
 *
 * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
 */
const PRODUCT_LISTING_URL_MATCHER = new InjectionToken('PRODUCT_LISTING_URL_MATCHER', {
    providedIn: 'root',
    factory: () => getProductListingUrlMatcherFactory(inject(UrlMatcherService), inject(DEFAULT_URL_MATCHER)),
});

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductListingPageModule {
}
ProductListingPageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListingPageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductListingPageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductListingPageModule, imports: [i1$2.RouterModule] });
ProductListingPageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListingPageModule, providers: [
        provideDefaultConfig({
            routing: {
                routes: {
                    category: {
                        matchers: [PRODUCT_LISTING_URL_MATCHER],
                    },
                },
            },
        }),
    ], imports: [RouterModule.forChild([
            {
                // @ts-ignore
                path: null,
                canActivate: [CmsPageGuard],
                component: PageLayoutComponent,
                data: { pageLabel: 'search', cxRoute: 'search' },
            },
            {
                // @ts-ignore
                path: null,
                canActivate: [CmsPageGuard],
                component: PageLayoutComponent,
                data: { cxRoute: 'brand' },
            },
            {
                // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
                // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
                // @ts-ignore
                path: null,
                canActivate: [CmsPageGuard],
                component: PageLayoutComponent,
                data: { cxRoute: 'category' },
            },
        ])] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductListingPageModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        RouterModule.forChild([
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { pageLabel: 'search', cxRoute: 'search' },
                            },
                            {
                                // @ts-ignore
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'brand' },
                            },
                            {
                                // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
                                // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
                                // @ts-ignore
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: { cxRoute: 'category' },
                            },
                        ]),
                    ],
                    providers: [
                        provideDefaultConfig({
                            routing: {
                                routes: {
                                    category: {
                                        matchers: [PRODUCT_LISTING_URL_MATCHER],
                                    },
                                },
                            },
                        }),
                    ],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Resolves the context for the specific route, based on the property `data.cxContext`
 * defined in the Angular Route.
 */
class RoutingContextService {
    constructor(activatedRoutesService, injector) {
        this.activatedRoutesService = activatedRoutesService;
        this.injector = injector;
        /**
         * Combined context token mapping consisting of all mappings defined in currently
         * Activated Angular Routes.
         *
         * The context token mapping is read from each Route's property `data.cxContext`.
         */
        this.contextTokenMapping$ = this.activatedRoutesService.routes$.pipe(map((routes) => this.getRoutesContextTokenMapping(routes)), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    /**
     * Returns the merged context token mapping, consisting of mappings
     * defined in all Activated Angular Routes.
     */
    getRoutesContextTokenMapping(routes) {
        return Object.assign({}, ...routes.map((route) => route?.data?.cxContext));
    }
    /**
     * Resolves the specified `contextToken` from `cxContext` data parameter of the activated Angular Routes.
     * @param contextToken
     *
     * @returns instance from the root injector if defined, otherwise `undefined`.
     */
    get(contextToken) {
        return this.contextTokenMapping$.pipe(switchMap((contextMapping) => {
            const providerToken = contextMapping?.[contextToken];
            return !!providerToken
                ? this.injector.get(providerToken)
                : of(undefined);
        }));
    }
}
RoutingContextService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingContextService, deps: [{ token: i1.ActivatedRoutesService }, { token: i1.UnifiedInjector }], target: i0.ɵɵFactoryTarget.Injectable });
RoutingContextService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingContextService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: RoutingContextService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ActivatedRoutesService }, { type: i1.UnifiedInjector }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Generic service for resolving the context for the UI components.
 */
class ContextService {
    constructor(routingContextService) {
        this.routingContextService = routingContextService;
    }
    /**
     * Returns the context for the given token.
     */
    get(contextToken) {
        return this.resolveContext(contextToken).pipe(distinctUntilChanged(), shareReplay({ refCount: true, bufferSize: 1 }));
    }
    /**
     * Resolves the context for the given token.
     */
    resolveContext(contextToken) {
        return this.routingContextService.get(contextToken);
    }
}
ContextService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ContextService, deps: [{ token: RoutingContextService }], target: i0.ɵɵFactoryTarget.Injectable });
ContextService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ContextService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ContextService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: RoutingContextService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Indicates that a user navigated to an arbitrary page.
 */
class NavigationEvent extends CxEvent {
}
/**
 * Event's type
 */
NavigationEvent.type = 'NavigationEvent';

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Indicates that a user visited an arbitrary page.
 */
class PageEvent extends CxEvent {
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Indicates that a user visited a home page.
 */
class HomePageEvent extends PageEvent {
}
/** event's type */
HomePageEvent.type = 'HomePageEvent';

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class HomePageEventBuilder {
    constructor(eventService) {
        this.eventService = eventService;
        this.register();
    }
    register() {
        this.eventService.register(HomePageEvent, this.buildHomePageEvent());
    }
    buildHomePageEvent() {
        return this.eventService.get(NavigationEvent).pipe(filter((navigationEvent) => navigationEvent.semanticRoute === 'home'), map((navigationEvent) => createFrom(HomePageEvent, {
            navigation: navigationEvent,
        })));
    }
}
HomePageEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HomePageEventBuilder, deps: [{ token: i1.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
HomePageEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HomePageEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HomePageEventBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.EventService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class HomePageEventModule {
    constructor(_homePageEventBuilder) {
        // Intentional empty constructor
    }
}
HomePageEventModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HomePageEventModule, deps: [{ token: HomePageEventBuilder }], target: i0.ɵɵFactoryTarget.NgModule });
HomePageEventModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: HomePageEventModule });
HomePageEventModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HomePageEventModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: HomePageEventModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: HomePageEventBuilder }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * A builder for the NavigationEvent
 */
class NavigationEventBuilder {
    constructor(actions, eventService) {
        this.actions = actions;
        this.eventService = eventService;
        this.register();
    }
    /**
     * Registers events
     */
    register() {
        this.eventService.register(NavigationEvent, this.buildNavigationEvent());
    }
    /**
     * Builds the navigation events
     */
    buildNavigationEvent() {
        return this.getNavigatedEvent().pipe(map((state) => createFrom(NavigationEvent, {
            context: state.context,
            semanticRoute: state.semanticRoute,
            url: state.url,
            params: state.params,
        })));
    }
    getNavigatedEvent() {
        return this.actions.pipe(ofType(ROUTER_NAVIGATED), map((event) => event.payload.routerState));
    }
}
NavigationEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationEventBuilder, deps: [{ token: i1$4.ActionsSubject }, { token: i1.EventService }], target: i0.ɵɵFactoryTarget.Injectable });
NavigationEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationEventBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$4.ActionsSubject }, { type: i1.EventService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class NavigationEventModule {
    constructor(_navigationEventBuilder) {
        // Intentional empty constructor
    }
}
NavigationEventModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationEventModule, deps: [{ token: NavigationEventBuilder }], target: i0.ɵɵFactoryTarget.NgModule });
NavigationEventModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: NavigationEventModule });
NavigationEventModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationEventModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NavigationEventModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: NavigationEventBuilder }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Indicates that a user visited a product details page.
 */
class ProductDetailsPageEvent extends PageEvent {
}
/** event's type */
ProductDetailsPageEvent.type = 'ProductDetailsPageEvent';
/**
 * Indicates that a user visited a category page.
 */
class CategoryPageResultsEvent extends PageEvent {
}
/** event's type */
CategoryPageResultsEvent.type = 'CategoryPageResultsEvent';
/**
 * Indicates that the a user visited the search results page,
 * and that the search results have been retrieved.
 */
class SearchPageResultsEvent extends PageEvent {
}
/** event's type */
SearchPageResultsEvent.type = 'SearchPageResultsEvent';

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductPageEventBuilder {
    constructor(eventService, productService, productSearchService) {
        this.eventService = eventService;
        this.productService = productService;
        this.productSearchService = productSearchService;
        this.register();
    }
    register() {
        this.eventService.register(SearchPageResultsEvent, this.buildSearchPageResultsEvent());
        this.eventService.register(ProductDetailsPageEvent, this.buildProductDetailsPageEvent());
        this.eventService.register(CategoryPageResultsEvent, this.buildCategoryResultsPageEvent());
    }
    buildProductDetailsPageEvent() {
        return this.eventService.get(NavigationEvent).pipe(filter((navigationEvent) => navigationEvent.semanticRoute === 'product'), switchMap((navigationEvent) => this.productService.get(navigationEvent.context.id).pipe(filter((product) => Boolean(product)), take(1), map((product) => createFrom(ProductDetailsPageEvent, {
            navigation: navigationEvent,
            categories: product?.categories,
            code: product?.code,
            name: product?.name,
            price: product?.price,
        })))));
    }
    buildCategoryResultsPageEvent() {
        const searchResults$ = this.productSearchService.getResults().pipe(
        // skipping the initial value, and preventing emission of the previous search state
        skip(1));
        return this.eventService.get(NavigationEvent).pipe(switchMap((navigationEvent) => {
            if (navigationEvent?.semanticRoute !== 'category') {
                return EMPTY;
            }
            return searchResults$.pipe(map((searchResults) => createFrom(CategoryPageResultsEvent, {
                navigation: navigationEvent,
                ...{
                    categoryCode: navigationEvent?.context?.id,
                    numberOfResults: searchResults?.pagination?.totalResults ?? 0,
                    categoryName: searchResults.breadcrumbs?.[0].facetValueName,
                },
            })));
        }));
    }
    buildSearchPageResultsEvent() {
        const searchResults$ = this.productSearchService.getResults().pipe(
        // skipping the initial value, and preventing emission of the previous search state
        skip(1));
        return this.eventService.get(NavigationEvent).pipe(switchMap((navigationEvent) => {
            if (navigationEvent?.semanticRoute !== 'search') {
                return EMPTY;
            }
            return searchResults$.pipe(map((searchResults) => createFrom(SearchPageResultsEvent, {
                navigation: navigationEvent,
                ...{
                    searchTerm: searchResults?.freeTextSearch ?? '',
                    numberOfResults: searchResults?.pagination?.totalResults ?? 0,
                },
            })));
        }));
    }
}
ProductPageEventBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductPageEventBuilder, deps: [{ token: i1.EventService }, { token: i1.ProductService }, { token: i1.ProductSearchService }], target: i0.ɵɵFactoryTarget.Injectable });
ProductPageEventBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductPageEventBuilder, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductPageEventBuilder, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.EventService }, { type: i1.ProductService }, { type: i1.ProductSearchService }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductPageEventModule {
    constructor(_productPageEventBuilder) {
        // Intentional empty constructor
    }
}
ProductPageEventModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductPageEventModule, deps: [{ token: ProductPageEventBuilder }], target: i0.ɵɵFactoryTarget.NgModule });
ProductPageEventModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: ProductPageEventModule });
ProductPageEventModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductPageEventModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: ProductPageEventModule, decorators: [{
            type: NgModule,
            args: [{}]
        }], ctorParameters: function () { return [{ type: ProductPageEventBuilder }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const mediaConfig = {
    mediaFormats: {
        mobile: { width: 400 },
        tablet: { width: 770 },
        desktop: { width: 1140 },
        widescreen: { width: 1400 },
        // product media
        cartIcon: { width: 65 },
        thumbnail: { width: 96 },
        product: { width: 284 },
        zoom: { width: 515 },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * The layout configuration is used to define the overall layout of the storefront.
 * The configuration includes the following aspects:
 * - breakpoint layout (AKA screen layout)
 * - Page sections slot configuration (i.e. header vs footer)
 * - page template slot configuration (i.e. landing page template vs PDP page template)
 * - deferred loading configuration
 *
 * The page slot configurations is directly related to the data in the backend. If you use the
 * Spartacus sample-data, you will have an aligned setup. However, if you introduce custom page
 * templates and/or slots, you most likely need to further adjust or replace this configuration.
 */
const layoutConfig = {
    // deferredLoading: {
    //   strategy: DeferLoadingStrategy.DEFER,
    //   intersectionMargin: '50px',
    // },
    layoutSlots: {
        header: {
            lg: {
                slots: [
                    'PreHeader',
                    'SiteContext',
                    'SiteLinks',
                    'SiteLogo',
                    'SearchBox',
                    'SiteLogin',
                    'MiniCart',
                    'NavigationBar',
                ],
            },
            slots: ['PreHeader', 'SiteLogo', 'SearchBox', 'MiniCart'],
        },
        navigation: {
            lg: { slots: [] },
            slots: ['SiteLogin', 'NavigationBar', 'SiteContext', 'SiteLinks'],
        },
        footer: {
            slots: ['Footer'],
        },
        LandingPage2Template: {
            pageFold: 'Section2B',
            slots: [
                'Section1',
                'Section2A',
                'Section2B',
                'Section2C',
                'Section3',
                'Section4',
                'Section5',
            ],
        },
        ContentPage1Template: {
            slots: ['Section2A', 'Section2B'],
        },
        CategoryPageTemplate: {
            pageFold: 'Section2',
            slots: ['Section1', 'Section2', 'Section3'],
        },
        ProductListPageTemplate: {
            slots: ['ProductLeftRefinements', 'ProductListSlot'],
        },
        ProductGridPageTemplate: {
            slots: ['ProductLeftRefinements', 'ProductGridSlot'],
        },
        SearchResultsListPageTemplate: {
            slots: [
                'Section2',
                'ProductLeftRefinements',
                'SearchResultsListSlot',
                'Section4',
            ],
        },
        SearchResultsGridPageTemplate: {
            slots: [
                'Section2',
                'ProductLeftRefinements',
                'SearchResultsGridSlot',
                'Section4',
            ],
        },
        ProductDetailsPageTemplate: {
            lg: {
                pageFold: 'UpSelling',
            },
            pageFold: 'Summary',
            slots: [
                'Summary',
                'UpSelling',
                'CrossSelling',
                'Tabs',
                'PlaceholderContentSlot',
            ],
        },
        CartPageTemplate: {
            slots: ['TopContent', 'CenterRightContentSlot', 'EmptyCartMiddleContent'],
        },
        AccountPageTemplate: {
            slots: ['BodyContent', 'SideContent'],
        },
        LoginPageTemplate: {
            slots: ['LeftContentSlot', 'RightContentSlot'],
        },
        ErrorPageTemplate: {
            slots: ['TopContent', 'MiddleContent', 'BottomContent'],
        },
        OrderConfirmationPageTemplate: {
            slots: ['BodyContent', 'SideContent'],
        },
        MultiStepCheckoutSummaryPageTemplate: {
            slots: ['TopContent', 'BodyContent', 'SideContent', 'BottomContent'],
        },
        CheckoutLoginPageTemplate: {
            slots: ['RightContentSlot'],
        },
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultCmsContentProviders = [
    provideCmsStructure({
        componentId: 'HamburgerMenuComponent',
        pageSlotPosition: 'PreHeader',
    }),
    provideCmsStructure({
        componentId: 'LoginComponent',
        pageSlotPosition: 'SiteLogin',
    }),
];

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
const defaultOnNavigateConfig = {
    enableResetViewOnNavigate: {
        active: true,
        ignoreQueryString: false,
        ignoreRoutes: [],
    },
};

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class OnNavigateConfig {
}
OnNavigateConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OnNavigateConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
OnNavigateConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OnNavigateConfig, providedIn: 'root', useExisting: Config });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OnNavigateConfig, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useExisting: Config,
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

class OnNavigateService {
    get hostComponent() {
        return this.injector.get(ApplicationRef)?.components?.[0];
    }
    constructor(config, router, viewportScroller, injector) {
        this.config = config;
        this.router = router;
        this.viewportScroller = viewportScroller;
        this.injector = injector;
    }
    /**
     * Reads configuration and enables features based on flags set.
     */
    initializeWithConfig() {
        if (this.config?.enableResetViewOnNavigate?.active) {
            this.setResetViewOnNavigate(this.config.enableResetViewOnNavigate.active);
        }
    }
    /**
     * Resets view back to the original position when performing a back navigation and to the top when performing a front navigation
     * and sets the focus back to the top of the page before skiplinks for any type of navigation
     * @param enable Enable or disable this feature
     */
    setResetViewOnNavigate(enable) {
        this.subscription?.unsubscribe();
        if (enable) {
            // Disable automatic scroll restoration to avoid race conditions
            this.viewportScroller.setHistoryScrollRestoration('manual');
            this.subscription = this.router.events
                .pipe(filter((event) => event instanceof Scroll), pairwise())
                .subscribe((event) => {
                const previousRoute = event[0];
                const currentRoute = event[1];
                const position = currentRoute.position;
                if (position) {
                    // allow the pages to be repainted before scrolling to proper position
                    setTimeout(() => this.viewportScroller.scrollToPosition(position));
                }
                else {
                    if (this.config.enableResetViewOnNavigate?.ignoreQueryString &&
                        this.isPathEqual(previousRoute, currentRoute)) {
                        return;
                    }
                    if (this.isChildRoute(currentRoute)) {
                        return;
                    }
                    setTimeout(() => this.viewportScroller.scrollToPosition([0, 0]), 100);
                }
                this.hostComponent?.location?.nativeElement.focus();
            });
        }
    }
    /**
     * Verifies if the current route is a child route from the given ignore config route
     *
     * @param route
     * @returns boolean whether the route is a child route
     */
    isChildRoute(route) {
        return (this.config.enableResetViewOnNavigate?.ignoreRoutes?.some((configRoute) => route.routerEvent.urlAfterRedirects.split('/').includes(configRoute)) ?? false);
    }
    /**
     * Verifies if the previous and current route are the same without the query string
     *
     * @param previousRoute
     * @param currentRoute
     * @returns boolean depending on the previous and current route are equal without the query strings
     */
    isPathEqual(previousRoute, currentRoute) {
        return (previousRoute.routerEvent.urlAfterRedirects.split('?')[0] ===
            currentRoute.routerEvent.urlAfterRedirects.split('?')[0]);
    }
}
OnNavigateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OnNavigateService, deps: [{ token: OnNavigateConfig }, { token: i1$2.Router }, { token: i3.ViewportScroller }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
OnNavigateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OnNavigateService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: OnNavigateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: OnNavigateConfig }, { type: i1$2.Router }, { type: i3.ViewportScroller }, { type: i0.Injector }]; } });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class AppRoutingModule {
}
AppRoutingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AppRoutingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AppRoutingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: AppRoutingModule, imports: [i1$2.RouterModule] });
AppRoutingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AppRoutingModule, providers: [
        provideDefaultConfig(defaultOnNavigateConfig),
        {
            provide: APP_INITIALIZER,
            useFactory: onNavigateFactory,
            deps: [OnNavigateService],
            multi: true,
        },
    ], imports: [RouterModule.forRoot([], {
            anchorScrolling: 'enabled',
            initialNavigation: 'enabledBlocking',
        })] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: AppRoutingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        RouterModule.forRoot([], {
                            anchorScrolling: 'enabled',
                            initialNavigation: 'enabledBlocking',
                        }),
                    ],
                    providers: [
                        provideDefaultConfig(defaultOnNavigateConfig),
                        {
                            provide: APP_INITIALIZER,
                            useFactory: onNavigateFactory,
                            deps: [OnNavigateService],
                            multi: true,
                        },
                    ],
                }]
        }] });
function onNavigateFactory(onNavigateService) {
    const isReady = () => onNavigateService.initializeWithConfig();
    return isReady;
}

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Utils for Angular forms
 */
var FormUtils;
(function (FormUtils) {
    /**
     * Calls the native Angular method `#updateValueAndValidity` for the given from control
     * and all its descendants (in case when it's `FormGroup` or `FormArray`).
     *
     * In particular it's useful for triggering re-emission of observables
     * `valueChanges` and `statusChanges` for all descendant form controls.
     *
     * _Note: Dropping this function may be considered, when it's implemented natively
     * by Angular. See https://github.com/angular/angular/issues/6170_
     *
     * @param control form control
     * @param options additional options
     * * `emitEvent`: When true or not given (the default), the `statusChanges` and
     * `valueChanges` observables emit the latest status and value. When false,
     * it doesn't trigger observables emission.
     */
    function deepUpdateValueAndValidity(control, options = {}) {
        if (control instanceof UntypedFormGroup ||
            control instanceof UntypedFormArray) {
            Object.values(control.controls).forEach((childControl) => {
                deepUpdateValueAndValidity(childControl, options);
            });
        }
        control.updateValueAndValidity({
            onlySelf: true,
            emitEvent: options.emitEvent,
        });
    }
    FormUtils.deepUpdateValueAndValidity = deepUpdateValueAndValidity;
})(FormUtils || (FormUtils = {}));

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
class BaseStorefrontModule {
}
BaseStorefrontModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BaseStorefrontModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BaseStorefrontModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.4", ngImport: i0, type: BaseStorefrontModule, imports: [i1.BaseCoreModule, RouterModule,
        GlobalMessageComponentModule,
        OutletModule,
        OutletRefModule,
        PwaModule,
        PageLayoutModule,
        SeoModule, PageComponentModule, PageSlotModule,
        SkipLinkModule,
        KeyboardFocusModule,
        LayoutModule, RoutingModule, MediaModule, OutletModule, StorefrontComponentModule], exports: [LayoutModule, StorefrontComponentModule] });
BaseStorefrontModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BaseStorefrontModule, imports: [BaseCoreModule.forRoot(),
        RouterModule,
        GlobalMessageComponentModule,
        OutletModule,
        OutletRefModule,
        PwaModule,
        PageLayoutModule,
        SeoModule,
        PageComponentModule.forRoot(),
        PageSlotModule,
        SkipLinkModule,
        KeyboardFocusModule,
        LayoutModule,
        RoutingModule.forRoot(),
        MediaModule.forRoot(),
        OutletModule.forRoot(),
        StorefrontComponentModule, LayoutModule, StorefrontComponentModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: BaseStorefrontModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        BaseCoreModule.forRoot(),
                        RouterModule,
                        GlobalMessageComponentModule,
                        OutletModule,
                        OutletRefModule,
                        PwaModule,
                        PageLayoutModule,
                        SeoModule,
                        PageComponentModule.forRoot(),
                        PageSlotModule,
                        SkipLinkModule,
                        KeyboardFocusModule,
                        LayoutModule,
                        RoutingModule.forRoot(),
                        MediaModule.forRoot(),
                        OutletModule.forRoot(),
                        StorefrontComponentModule,
                    ],
                    exports: [LayoutModule, StorefrontComponentModule],
                }]
        }] });

/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/** AUGMENTABLE_TYPES_END */

/**
 * Generated bundle index. Do not edit.
 */

export { AVOID_STACKED_OUTLETS, ActiveFacetsComponent, ActiveFacetsModule, AddToHomeScreenBannerComponent, AddToHomeScreenBtnComponent, AddToHomeScreenComponent, AddToHomeScreenService, AddressBookComponent, AddressBookComponentService, AddressBookModule, AddressFormComponent, AddressFormModule, AnonymousConsentDialogComponent, AnonymousConsentManagementBannerComponent, AnonymousConsentManagementBannerModule, AnonymousConsentOpenDialogComponent, AnonymousConsentsDialogModule, AppRoutingModule, AtMessageDirective, AtMessageModule, AvatarComponent, BREAKPOINT, BannerCarouselComponent, BannerCarouselModule, BannerComponent, BannerModule, BaseStorefrontModule, BreadcrumbComponent, BreadcrumbModule, BreadcrumbSchemaBuilder, BreakpointService, CardComponent, CardModule, CarouselComponent, CarouselModule, CarouselService, CategoryNavigationComponent, CategoryNavigationModule, CategoryPageResultsEvent, ChatMessagingModule, CmsComponentData, CmsComponentsService, CmsFeaturesService, CmsGuardsService, CmsI18nService, CmsInjectorService, CmsPageGuard, CmsPageGuardService, CmsParagraphModule, CmsRouteModule, CmsRoutesService, ComponentCreateEvent, ComponentDestroyEvent, ComponentEvent, ComponentHandler, ComponentHandlerService, ComponentWrapperDirective, ConsentManagementComponent, ConsentManagementFormComponent, ConsentManagementModule, ContextService, CouponCardComponent, CouponClaimComponent, CouponDialogComponent, CurrentProductService, CustomFormValidators, DIALOG_TYPE, DatePickerComponent, DatePickerModule, DatePickerService, DefaultComponentHandler, DeferLoaderService, DirectionConfig, DirectionMode, DirectionModule, DirectionService, ExportCsvFileService, FacetComponent, FacetGroupCollapsedState, FacetListComponent, FacetListModule, FacetModule, FacetService, FileDownloadService, FileReaderService, FileUploadComponent, FileUploadModule, FilesFormValidators, FocusDirective, FooterNavigationComponent, FooterNavigationModule, FormConfig, FormErrorsComponent, FormErrorsModule, FormUtils, GenericLinkComponent, GenericLinkComponentService, GenericLinkModule, GlobalMessageComponent, GlobalMessageComponentModule, HamburgerMenuComponent, HamburgerMenuModule, HamburgerMenuService, HighlightPipe, HomePageEvent, HomePageEventBuilder, HomePageEventModule, ICON_TYPE, IconComponent, IconConfig, IconLoaderService, IconModule, IconResourceType, IconTestingModule, ImageLoadingStrategy, ImportCsvFileService, InlineRenderStrategy, InlineRootRenderStrategy, InnerComponentsHostDirective, IntersectionService, ItemCounterComponent, ItemCounterModule, JSONLD_PRODUCT_BUILDER, JsonLdBaseProductBuilder, JsonLdBuilderModule, JsonLdDirective, JsonLdProductOfferBuilder, JsonLdProductReviewBuilder, JsonLdScriptFactory, KeyboardFocusModule, KeyboardFocusService, KeyboardFocusTestingModule, LanguageCurrencyComponent, LaunchDialogModule, LaunchDialogService, LaunchRenderStrategy, LayoutConfig, LayoutModule, LazyComponentHandler, LinkComponent, LinkModule, ListNavigationModule, LoginGuard, LoginRouteModule, LogoutGuard, LogoutModule, MediaComponent, MediaConfig, MediaModule, MediaService, MessageComponent, MessageComponentModule, MessagingComponent, MockIconComponent, MockIconLoaderService, MockKeyboardFocusDirective, MyCouponsComponent, MyCouponsComponentService, MyCouponsModule, MyInterestsComponent, MyInterestsModule, NavigationComponent, NavigationEvent, NavigationEventBuilder, NavigationEventModule, NavigationModule, NavigationService, NavigationUIComponent, NgSelectA11yDirective, NgSelectA11yModule, NotificationPreferenceComponent, NotificationPreferenceModule, OnNavigateConfig, OnNavigateService, OutletContextData, OutletDirective, OutletModule, OutletPosition, OutletRefDirective, OutletRefModule, OutletRenderStrategy, OutletRendererService, OutletService, PAGE_LAYOUT_HANDLER, PDFComponent, PDFModule, PRODUCT_DETAILS_URL_MATCHER, PRODUCT_LISTING_URL_MATCHER, PWAModuleConfig, PageComponentModule, PageEvent, PageLayoutComponent, PageLayoutModule, PageLayoutService, PageMetaLinkService, PageSection, PageSlotComponent, PageSlotModule, PageSlotService, PageTemplateDirective, PageTitleComponent, PageTitleModule, PaginationBuilder, PaginationComponent, PaginationConfig, PaginationItemType, PaginationModule, PaginationNavigationPosition, ParagraphComponent, PasswordVisibilityToggleComponent, PasswordVisibilityToggleDirective, PasswordVisibilityToggleModule, PaymentMethodsComponent, PaymentMethodsModule, PopoverComponent, PopoverDirective, PopoverEvent, PopoverModule, PopoverService, PositioningService, ProductAttributesComponent, ProductAttributesModule, ProductCarouselComponent, ProductCarouselItemComponent, ProductCarouselModule, ProductCarouselService, ProductDetailOutlets, ProductDetailsPageEvent, ProductDetailsPageModule, ProductDetailsTabComponent, ProductDetailsTabModule, ProductFacetNavigationComponent, ProductFacetNavigationModule, ProductFacetService, ProductGridItemComponent, ProductImagesComponent, ProductImagesModule, ProductIntroComponent, ProductIntroModule, ProductListComponent, ProductListComponentService, ProductListItemComponent, ProductListItemContext, ProductListItemContextSource, ProductListModule, ProductListOutlets, ProductListingPageModule, ProductPageEventBuilder, ProductPageEventModule, ProductReferencesComponent, ProductReferencesModule, ProductReviewsComponent, ProductReviewsModule, ProductSchemaBuilder, ProductScrollComponent, ProductSummaryComponent, ProductSummaryModule, ProductTabsModule, ProductViewComponent, ProgressButtonComponent, ProgressButtonModule, PromotionsComponent, PromotionsModule, PwaModule, RoutingContextService, RoutingModule, RoutingRenderStrategy, SCHEMA_BUILDER, ScrollToTopComponent, ScrollToTopModule, SearchBoxComponent, SearchBoxComponentService, SearchBoxModule, SearchBoxProductSelectedEvent, SearchBoxSuggestionSelectedEvent, SearchPageResultsEvent, SelectFocusUtility, SeoConfig, SeoMetaService, SeoModule, SiteContextComponentService, SiteContextSelectorComponent, SiteContextSelectorModule, SiteContextType, SkipLink, SkipLinkComponent, SkipLinkConfig, SkipLinkDirective, SkipLinkModule, SkipLinkScrollPosition, SkipLinkService, SortingComponent, SortingModule, SpinnerComponent, SpinnerModule, SplitViewComponent, SplitViewModule, SplitViewService, StarRatingComponent, StarRatingModule, StockNotificationComponent, StockNotificationDialogComponent, StockNotificationModule, StorefrontComponent, StorefrontComponentModule, StorefrontOutlets, StructuredDataModule, SuggestedAddressDialogComponent, SupplementHashAnchorsModule, SupplementHashAnchorsPipe, TabParagraphContainerComponent, TabParagraphContainerModule, TableComponent, TableConfig, TableDataCellComponent, TableDataCellModule, TableHeaderCellComponent, TableHeaderCellModule, TableLayout, TableModule, TableRendererService, TableService, ThemeModule, ThemeService, TotalComponent, TotalModule, TrapFocus, TruncatePipe, TruncateTextPopoverComponent, TruncateTextPopoverModule, USE_STACKED_OUTLETS, UserComponentModule, VideoComponent, VideoModule, ViewComponent, ViewConfig, ViewModes, controlsMustMatch, defaultCmsContentProviders, defaultLayoutConfig, defaultOnNavigateConfig, defaultPWAModuleConfig, defaultPaginationConfig, defaultSeoConfig, defaultSkipLinkConfig, defaultTableConfig, defaultViewConfig, fontawesomeIconConfig, getAddressNumbers, getSuffixUrlMatcher, initSeoService, layoutConfig, mediaConfig, onNavigateFactory, provideCmsStructure, provideOutlet, sortTitles, titleScores };
//# sourceMappingURL=spartacus-storefront.mjs.map
